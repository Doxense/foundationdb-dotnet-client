#region Copyright (c) 2023-2024 SnowBank SAS, (c) 2005-2023 Doxense SAS
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 	* Redistributions of source code must retain the above copyright
// 	  notice, this list of conditions and the following disclaimer.
// 	* Redistributions in binary form must reproduce the above copyright
// 	  notice, this list of conditions and the following disclaimer in the
// 	  documentation and/or other materials provided with the distribution.
// 	* Neither the name of SnowBank nor the
// 	  names of its contributors may be used to endorse or promote products
// 	  derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL SNOWBANK SAS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#endregion

//#define FULL_DEBUG

namespace Doxense.Serialization.Json.CodeGen
{
	using System;
	using System.CodeDom.Compiler;
	using System.Diagnostics;
	using Microsoft.CodeAnalysis;
	
	public partial class CrystalJsonSourceGenerator
	{

		internal const string JsonEncodedPropertyNameFullName = KnownTypeSymbols.CrystalJsonNamespace + ".JsonEncodedPropertyName";
		
		internal sealed class Emitter
		{
			
			private SourceProductionContext Context { get; }
			
			public CrystalJsonContainerMetadata Metadata { get; }

			public Emitter(SourceProductionContext ctx, CrystalJsonContainerMetadata metadata)
			{
				this.Context = ctx;
				this.Metadata = metadata;
			}

			public void GenerateCode()
			{
				this.Context.CancellationToken.ThrowIfCancellationRequested();

				Kenobi($"GEN [{DateTime.UtcNow:hh:mm:ss}]: {this.Metadata.Symbol.Name}");

				var code = GenerateConverterSource();
			
				Kenobi("Use the source:\r\n" + code);
			
				this.Context.AddSource($"{this.Metadata.Symbol.Name}.g.cs", code);
			}

			public string GenerateConverterSource()
			{
				var symbol = this.Metadata.Symbol;
				var includedTypes = this.Metadata.IncludedTypes;
				
				Kenobi($"Generated {symbol.Name} with {includedTypes.Count} included types");

				var sb = new CodeBuilder();
				sb.Comment("<auto-generated/>");
				sb.NewLine();

				sb.Comment($"Name: '{symbol.Name}'");
				sb.Comment($"NameSpace: '{symbol.NameSpace}'");
				sb.Comment($"Types: {includedTypes.Count}");
				foreach (var t in includedTypes)
				{
					sb.Comment($"- {t.Name}: {t.ToString()}");
				}
				sb.NewLine();

				//sb.AppendLine("#if NET8_0_OR_GREATER");
				//sb.NewLine();
				sb.AppendLine("#nullable enable annotations");
				sb.AppendLine("#nullable enable warnings"); //TODO: REVIEW: to disable or not to disable warnings?
				sb.NewLine();

				sb.Namespace(
					symbol.NameSpace,
					() =>
					{
						// we don't want to have to specify the namespace everytime
						sb.AppendLine($"using {KnownTypeSymbols.CrystalJsonNamespace};");
						// we also use a lot of helper static methods from this type
						sb.AppendLine($"using static {JsonSerializerExtensionsFullName};");
						sb.NewLine();

						sb.AppendLine("/// <summary>Generated source code for JSON operations on application types</summary>");
						//sb.Attribute<DynamicallyAccessedMembersAttribute>([sb.Constant(DynamicallyAccessedMemberTypes.All)]);
						sb.Attribute<GeneratedCodeAttribute>([sb.Constant(nameof(CrystalJsonSourceGenerator)), sb.Constant("0.1")]);
						sb.Attribute<DebuggerNonUserCodeAttribute>();
						sb.AppendLine($"public static partial class {symbol.Name}");
						sb.EnterBlock("Container");
						foreach (var typeDef in includedTypes)
						{
							GenerateCodeForType(sb, typeDef);
						}
						sb.LeaveBlock("Container");
						sb.NewLine();
					}
				);

				sb.NewLine();
				//sb.AppendLine("#endif");

				Kenobi("Done!");

				return sb.ToStringAndClear();
			}


			private string GetSerializerName(Type type) => type.Name;
			private string GetLocalSerializerRef(Type type) => $"{this.Metadata.Symbol.Name}.{GetSerializerName(type)}";

			private string GetReadOnlyProxyName(Type type) => $"{type.Name}ReadOnly";
			private string GetLocalReadOnlyProxyRef(Type type) => $"{this.Metadata.Name}.{GetReadOnlyProxyName(type)}";

			private string GetMutableProxyName(Type type) => $"{type.Name}Mutable";
			private string GetLocalMutableProxyRef(Type type) => $"{this.Metadata.Name}.{GetMutableProxyName(type)}";

			/// <summary>Returns the name of the generated const string with the serialized name of this member</summary>
			private string GetPropertyNameRef(CrystalJsonMemberMetadata member) => "PropertyNames." + member.MemberName;

			/// <summary>Returns the name of the generated static singleton with the definition of this member</summary>
			private string GetPropertyEncodedNameRef(CrystalJsonMemberMetadata member) => "PropertyEncodedNames." + member.MemberName;

			private string GetPropertyAccessorName(CrystalJsonMemberMetadata member) => $"{member.MemberName}Accessor";

			
			public void GenerateCodeForType(CodeBuilder sb, CrystalJsonTypeMetadata typeDef)
			{
				var typeFullName = typeDef.Symbol.FullyQualifiedName;
				var typeName = typeDef.Symbol.Name;

				var serializerName = typeName;
				var serializerTypeName = serializerName + "JsonConverter";
			
				sb.Comment($"Generating for type {typeDef.Symbol.FullyQualifiedName}");
				foreach (var member in typeDef.Members)
				{
					sb.Comment($"- {member.Name}: {member.ToString()}");
				}
				sb.NewLine();

				sb.AppendLine($"/// <summary>JSON converter for type <see cref=\"{typeFullName}\">{typeName}</see></summary>");
				sb.AppendLine($"public static {serializerTypeName} {serializerName} => m_cached{serializerName} ??= new();");
				sb.NewLine();
				sb.AppendLine($"private static {serializerTypeName}? m_cached{serializerName};");
				sb.NewLine();
			
				sb.AppendLine($"public sealed class {serializerTypeName} : {JsonConverterInterfaceFullName}<{typeFullName}>"); //TODO: implements!
				sb.EnterBlock("type:" + typeDef.Name);

				
				sb.AppendLine("#region Serialization...");
				sb.NewLine();

				sb.AppendLine("/// <summary>Names of all serialized members for this type</summary>");
				sb.AppendLine("public static class PropertyNames");
				sb.EnterBlock("properties");
				sb.NewLine();
				foreach (var member in typeDef.Members)
				{
					sb.AppendLine($"/// <summary>Serialized name of the <see cref=\"{typeName}.{member.MemberName}\"/> {(member.IsField ? "field" : "property")} of the <see cref=\"{typeName}\"/> {(member.Type.IsValueType ? "struct" : "class")}</summary>");
					sb.AppendLine($"public const string {member.MemberName} = {sb.Constant(member.Name)};");
					sb.NewLine();
				}

				sb.AppendLine($"public static string[] GetAllNames() => new [] {{ {string.Join(", ", typeDef.Members.Select(m => GetPropertyNameRef(m)))} }};"); //TODO: PERF!
				sb.NewLine();

				sb.LeaveBlock("properties");
				sb.NewLine();

				sb.AppendLine("/// <summary>Cached encoded names for all serialized members for this type</summary>");
				sb.AppendLine("public static class PropertyEncodedNames");
				sb.EnterBlock("properties");
				sb.NewLine();
				foreach (var member in typeDef.Members)
				{
					sb.AppendLine($"/// <summary>Encoded name of the <see cref=\"{typeName}.{member.MemberName}\"/> {(member.IsField ? "field" : "property")} of the <see cref=\"{typeName}\"/> {(member.Type.IsValueType ? "struct" : "class")}</summary>");
					sb.AppendLine($"public static readonly {JsonEncodedPropertyNameFullName} {member.MemberName} = new({GetPropertyNameRef(member)});");
					sb.NewLine();
				}
				sb.LeaveBlock("properties");
				sb.NewLine();
				
				// Serialize

				sb.AppendLine($"public void Serialize(CrystalJsonWriter writer, {typeFullName}? instance)");
				sb.EnterBlock();
				sb.AppendLine("var state = writer.BeginObject();");
				foreach (var member in typeDef.Members)
				{
					sb.AppendLine($"writer.WriteField({GetPropertyNameRef(member)}, instance.{member.MemberName});");
				}
				sb.AppendLine("writer.EndObject(state);");
				sb.LeaveBlock();
				sb.NewLine();

				sb.AppendLine("#endregion Serialization");
				sb.NewLine();
				
				// Pack

				sb.AppendLine($"public {JsonValueFullNameFullName} Pack({typeFullName}? instance, {CrystalJsonSettingsFullName}? settings = default, {ICrystalJsonTypeResolverFullName}? resolver = default)");
				sb.EnterBlock();
				sb.AppendLine("var obj = new JsonObject();");
				foreach (var member in typeDef.Members)
				{
					sb.AppendLine($"obj[{GetPropertyNameRef(member)}] = instance.{member.MemberName};");
				}
				sb.AppendLine("return obj;");
				sb.LeaveBlock();
				sb.NewLine();
			
				// UnPack

				sb.AppendLine($"public {typeFullName} Unpack({CrystalJsonSourceGenerator.JsonValueFullNameFullName} value, {ICrystalJsonTypeResolverFullName}? resolver = default)");
				sb.EnterBlock();
				sb.AppendLine("var obj = value.AsObject();");
				sb.AppendLine("return new ()");
				sb.EnterBlock();
				foreach (var member in typeDef.Members)
				{
					sb.AppendLine($"{member.MemberName} = obj.Get<{member.Type.FullyQualifiedName}>(\"{member.Name}\", default),");
				}
				sb.LeaveBlock(semicolon: true);
				sb.LeaveBlock();
				sb.NewLine();
			
				sb.LeaveBlock("type:" + typeDef.Name);
			}
			
		}
		
	}
	
}
