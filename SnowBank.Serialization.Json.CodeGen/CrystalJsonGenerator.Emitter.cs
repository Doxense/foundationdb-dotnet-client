#region Copyright (c) 2023-2025 SnowBank SAS, (c) 2005-2023 Doxense SAS
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 	* Redistributions of source code must retain the above copyright
// 	  notice, this list of conditions and the following disclaimer.
// 	* Redistributions in binary form must reproduce the above copyright
// 	  notice, this list of conditions and the following disclaimer in the
// 	  documentation and/or other materials provided with the distribution.
// 	* Neither the name of SnowBank nor the
// 	  names of its contributors may be used to endorse or promote products
// 	  derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL SNOWBANK SAS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#endregion

//#define FULL_DEBUG

namespace SnowBank.Serialization.Json.CodeGen
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using Microsoft.CodeAnalysis;
	
	public partial class CrystalJsonSourceGenerator
	{

		[SuppressMessage("ReSharper", "InconsistentNaming")]
		internal sealed class Emitter
		{

			#region Attributes Names ...

			private const string DebuggerNonUserCodeAttributeFullName = "global::System.Diagnostics.DebuggerNonUserCodeAttribute";

			private const string DisallowNullAttributeFullName = "global::System.Diagnostics.CodeAnalysis.DisallowNullAttribute";

			private const string DoesNotReturnAttributeFullName = "global::System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute";

			private const string DynamicallyAccessedMembersAttributeFullName = "global::System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute";

			private const string DynamicallyAccessedMemberTypesFullName = "global::System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes";

			private const string GeneratedCodeAttributeFullName = "global::System.CodeDom.Compiler.GeneratedCodeAttribute";

			private const string ExcludeFromCodeCoverageAttributeFullName = "global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute";

			private const string MaybeNullWhenAttributeFullName = "global::System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute";

			private const string NotNullIfNotNullAttributeFullName = "global::System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute";

			private const string DictionaryFullName = "global::System.Collections.Generic.Dictionary";

			private const string FrozenDictionaryFullName = "global::System.Collections.Frozen.FrozenDictionary";

			#endregion

			private SourceProductionContext Context { get; }

			private CrystalJsonContainerMetadata Metadata { get; }

			private Dictionary<TypeRef, CrystalJsonTypeMetadata> TypeMap { get; }

			private Dictionary<TypeRef, (CrystalJsonTypeMetadata Parent, object? Discriminator)> PolymorphicMap { get; }

			public Emitter(SourceProductionContext ctx, CrystalJsonContainerMetadata metadata)
			{
				this.Context = ctx;
				this.Metadata = metadata;

				var map = new Dictionary<TypeRef, CrystalJsonTypeMetadata>();
				foreach (var type in metadata.IncludedTypes)
				{
					map[type.Type.Ref] = type;
				}
				this.TypeMap = map;

				// build the set of derived types to their "base" type
				var polymorphicMap = new Dictionary<TypeRef, (CrystalJsonTypeMetadata Parent, object? Discriminator)>();
				foreach (var type in map.Values)
				{
					if (type.DerivedTypes.Count == 0) continue;
					foreach (var (_, derivedType, discriminator) in type.DerivedTypes)
					{
						polymorphicMap[derivedType.Ref] = (type, discriminator);
					}
				}

				this.PolymorphicMap = polymorphicMap;
			}

			private static void AddFileHeaders(CSharpCodeBuilder sb)
			{
				sb.Comment("<auto-generated/>");
				sb.NewLine();
				sb.AppendLine("#nullable enable annotations");
				sb.AppendLine("#nullable enable warnings");
				sb.AppendLine("#pragma warning disable CS0612, CS0618");
				sb.NewLine();
			}

			public void GenerateCode()
			{
				this.Context.CancellationToken.ThrowIfCancellationRequested();

				var symbol = this.Metadata.Type;
				var includedTypes = this.Metadata.IncludedTypes;
				
				Kenobi($"Generating container {symbol.Name} with {includedTypes.Count} included types");
				Kenobi($"Name: '{symbol.FullyQualifiedName}'");
				Kenobi($"Types: {includedTypes.Count}");

				// first we generated a "primary" file for the container, that will include any static methods (that are not specific to a type)

				{
					var sb = new CSharpCodeBuilder();
					AddFileHeaders(sb);

					sb.AppendLine($"namespace {symbol.NameSpace}");
					sb.EnterBlock("namespace");

					sb.XmlComment("<summary>Generated source code for JSON operations on application types</summary>");
					sb.AppendLine($"[{DynamicallyAccessedMembersAttributeFullName}({DynamicallyAccessedMemberTypesFullName}.All)]");
					sb.AppendLine($"[{GeneratedCodeAttributeFullName}(\"{nameof(CrystalJsonSourceGenerator)}\", \"0.1\")]");
					sb.AppendLine($"[{DebuggerNonUserCodeAttributeFullName}]");
					sb.AppendLine($"[{ExcludeFromCodeCoverageAttributeFullName}]");
					sb.AppendLine($"public static partial class {symbol.Name}");
					sb.EnterBlock("container");
					sb.NewLine();

					sb.XmlComment($"<summary>Returns a <see cref=\"{KnownTypeSymbols.ICrystalJsonTypeResolverFullName}\">resolver</see> that exposes all the generated converters in this container</summary>");
					sb.AppendLine($"public static {KnownTypeSymbols.ICrystalJsonTypeResolverFullName} GetResolver() => TypeMapper.Default;");
					sb.NewLine();

					// TypeMapper
					sb.XmlComment("<summary>Mapper that bundles all the types that are managed by this custom serializer context</summary>");
					sb.AppendLine($"internal sealed class TypeMapper : {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}");
					sb.EnterBlock("TypeMapper");
					{
						sb.NewLine();

						sb.XmlComment("<summary>Default mapper for all types in this container</summary>");
						sb.AppendLine("public static readonly TypeMapper Default = new();");
						sb.NewLine();

						sb.AppendLine($"private {FrozenDictionaryFullName}<Type, {KnownTypeSymbols.IJsonConverterInterfaceFullName}> ConvertersByType {{ get; }}");
						sb.NewLine();
						sb.AppendLine($"private {FrozenDictionaryFullName}<Type, {KnownTypeSymbols.IJsonConverterInterfaceFullName}> ConvertersByTypeExtended {{ get; }}");
						sb.NewLine();

						// ctor()
						sb.InheritDoc();
						sb.AppendLine("private TypeMapper()");
						sb.EnterBlock("ctor");
						// map of all application types
						sb.AppendLine($"var map = new {DictionaryFullName}<Type, {KnownTypeSymbols.IJsonConverterInterfaceFullName}>();");
						foreach (var type in includedTypes)
						{
							sb.AppendLine($"map[typeof({type.Type.FullyQualifiedName})] = {GetLocalSerializerRef(type)};");
						}
						sb.AppendLine($"this.ConvertersByType = {FrozenDictionaryFullName}.ToFrozenDictionary(map);");
						// extended maps that also includes the generated proxies
						foreach (var type in includedTypes)
						{
							sb.AppendLine($"map[typeof({GetReadOnlyProxyName(type.Type)})] = {GetLocalSerializerRef(type)};");
							sb.AppendLine($"map[typeof({GetWritableProxyName(type.Type)})] = {GetLocalSerializerRef(type)};");
						}
						sb.AppendLine($"this.ConvertersByTypeExtended = {FrozenDictionaryFullName}.ToFrozenDictionary(map);");
						sb.LeaveBlock("ctor");
						sb.NewLine();

						// TryGetConverterFor(Type)
						sb.InheritDoc();
						sb.AppendLine($"public bool TryGetConverterFor(Type type, [{MaybeNullWhenAttributeFullName}(false)] out {KnownTypeSymbols.IJsonConverterInterfaceFullName} converter)");
						sb.EnterBlock();
						{
							sb.AppendLine("return this.ConvertersByTypeExtended.TryGetValue(type, out converter);");
						}
						sb.LeaveBlock();
						sb.NewLine();

						// TryGetConverterFor<T>()
						sb.InheritDoc();
						sb.AppendLine($"public bool TryGetConverterFor<T>([{MaybeNullWhenAttributeFullName}(false)] out {KnownTypeSymbols.IJsonConverterInterfaceFullName}<T> converter)");
						sb.EnterBlock();
						{
							sb.AppendLine("if (!this.ConvertersByType.TryGetValue(typeof(T), out var instance))");
							sb.EnterBlock();
							sb.AppendLine("converter = null;");
							sb.AppendLine("return false;");
							sb.LeaveBlock();
							sb.AppendLine($"converter = System.Runtime.CompilerServices.Unsafe.As<{KnownTypeSymbols.IJsonConverterInterfaceFullName}<T>>(instance);");
							sb.AppendLine("return true;");
						}
						sb.LeaveBlock();
						sb.NewLine();

						// GetConverterFor<T>
						sb.AppendLine($"public {KnownTypeSymbols.IJsonConverterInterfaceFullName}<T>? GetConverterFor<T>()");
						sb.EnterBlock();
						{
							sb.AppendLine("if (!this.ConvertersByType.TryGetValue(typeof(T), out var instance))");
							sb.EnterBlock();
							sb.AppendLine("return null;");
							sb.LeaveBlock();
							sb.AppendLine($"return System.Runtime.CompilerServices.Unsafe.As<{KnownTypeSymbols.IJsonConverterInterfaceFullName}<T>>(instance);");
						}
						sb.LeaveBlock();
						sb.NewLine();

						// TryResolveTypeDefinition()
						sb.AppendLine($"public bool TryResolveTypeDefinition(Type type, [{MaybeNullWhenAttributeFullName}(false)] out {KnownTypeSymbols.CrystalJsonTypeDefinitionFullName} definition)");
						sb.EnterBlock();
						sb.AppendLine("if (!TryGetConverterFor(type, out var converter))");
						sb.EnterBlock();
						sb.AppendLine("definition = null;");
						sb.AppendLine("return false;");
						sb.LeaveBlock();
						sb.AppendLine("definition = converter.GetDefinition();");
						sb.AppendLine("return definition != null;");
						sb.LeaveBlock();
						sb.NewLine();

						// TryResolveTypeDefinition<T>()
						sb.AppendLine($"public bool TryResolveTypeDefinition<T>([{MaybeNullWhenAttributeFullName}(false)] out {KnownTypeSymbols.CrystalJsonTypeDefinitionFullName} definition)");
						sb.EnterBlock();
						sb.AppendLine("if (!TryGetConverterFor<T>(out var converter))");
						sb.EnterBlock();
						sb.AppendLine("definition = null;");
						sb.AppendLine("return false;");
						sb.LeaveBlock();
						sb.AppendLine("definition = converter.GetDefinition();");
						sb.AppendLine("return definition != null;");
						sb.LeaveBlock();
						sb.NewLine();
					}
					sb.LeaveBlock("TypeMapper");
					sb.NewLine();

					sb.LeaveBlock("container");
					sb.NewLine();

					sb.LeaveBlock("namespace");
					sb.NewLine();

					this.Context.AddSource($"{this.Metadata.Type.Name}.g.cs", sb.ToString());
				}

				// then, we generate one file for each of the serialized type
				foreach (var typeDef in includedTypes)
				{
					Kenobi($"Generating code for {typeDef.Type.FullyQualifiedName}");
					var sb = new CSharpCodeBuilder();
					AddFileHeaders(sb);
#if DEBUG
					{
						sb.BeginRegion("Type Definition (DEBUG)");
						sb.Comment(typeDef.Name + ":");
						var buf = new System.Text.StringBuilder();
						typeDef.Explain(buf, "- ");
						sb.Comment(buf.ToString());
						sb.EndRegion();
						sb.NewLine();
					}
#endif

					sb.AppendLine($"namespace {symbol.NameSpace}");
					sb.EnterBlock("namespace");

					// we don't want to have to specify the namespace everytime
					sb.AppendLine($"using {KnownTypeSymbols.CrystalJsonNamespace};");
					// we also use a lot of helper static methods from this type
					sb.NewLine();

					sb.AppendLine($"public static partial class {symbol.Name}");
					sb.EnterBlock("Container");

					try
					{
						GenerateCodeForType(sb, typeDef);
					}
					catch (Exception ex)
					{
						Kenobi("CRASH: failed to generate " + typeDef.Name + ": " + ex.ToString());

						var generated = sb.ToString();
						// to help with diagnosing the crash, we will include the code generated so far inside #if ... #endif

						sb.Clear();
						sb.NewLine();
						sb.Comment("ERROR: generator failed!");
						sb.Comment(ex.ToString());
						sb.NewLine();
						sb.Comment("Code generated until the crash:");
						sb.AppendLine("#if false");
						sb.NewLine();
						sb.Output.Append(generated.Replace("#region", "_#region").Replace("#endregion", "_#endregion").Replace("#if", "_#if").Replace("#endif", "_#endif").Replace("#else", "_#else").Replace("#elif", "_#elif"));
						sb.Comment(ex.ToString());
						sb.NewLine();
						sb.AppendLine("#endif");
						sb.NewLine();

						this.Context.AddSource($"{this.Metadata.Type.Name}.{typeDef.Name}.g.cs", sb.ToString());

						this.Context.ReportDiagnostic(
							Diagnostic.Create(new(
								"CJSON0003",
								"Failed to emit JSON code",
								"Failed to emit the generate source-code for for type {0} in {1}: [{2}] {3}.",
								"SnowBank.Serialization.Json.CodeGen",
								DiagnosticSeverity.Error,
								isEnabledByDefault: true
							), null, [ typeDef.Name, this.Metadata.Name, ex.GetType().Name, ex.Message ])
						);
					}

					sb.LeaveBlock("Container");
					sb.NewLine();

					sb.LeaveBlock("namespace");
					sb.NewLine();

					var hintName = typeDef.Name;
					if (typeDef.Type.IsGenericType())
					{
						hintName = $"{hintName}`{typeDef.Type.TypeArguments.Count}";
						foreach (var arg in typeDef.Type.TypeArguments)
						{
							hintName += "_" + arg.Name;
						}
					}

					this.Context.AddSource($"{this.Metadata.Type.Name}.{hintName}.g.cs", sb.ToString());
				}
				Kenobi("Done!");
			}

			private string GetSerializerName(TypeMetadata type)
			{
				if (!type.IsGenericType()) return type.Name;
				return DecorateGenericSerializerName(type);

				static string DecorateGenericSerializerName(TypeMetadata type)
				{
					var sb = new StringBuilder();
					sb.Append(type.Name);
					foreach (var t in type.TypeArguments)
					{
						sb.Append('_');
						sb.Append(t.Name);
					}
					return sb.ToString();
				}
			}

			private string GetLocalSerializerRef(CrystalJsonTypeMetadata metadata) => $"{this.Metadata.Type.Name}.{GetSerializerName(metadata.Type)}.Default";
			private string GetLocalSerializerRef(TypeMetadata metadata) => $"{this.Metadata.Type.Name}.{GetSerializerName(metadata)}.Default";

			private string GetConverterName(CrystalJsonTypeMetadata metadata) => GetSerializerName(metadata.Type) + ".JsonConverter";

			private string GetReadOnlyProxyName(TypeMetadata type) => $"{GetSerializerName(type)}.ReadOnly";
			private string GetLocalReadOnlyProxyRef(CrystalJsonTypeMetadata metadata) => $"{this.Metadata.Name}.{GetReadOnlyProxyName(metadata.Type)}";

			private string GetWritableProxyName(TypeMetadata type) => $"{GetSerializerName(type)}.Writable";
			private string GetLocalWritableProxyRef(CrystalJsonTypeMetadata metadata) => $"{this.Metadata.Name}.{GetWritableProxyName(metadata.Type)}";

			/// <summary>Returns the name of the generated const string with the serialized name of this member, from within the converter itself</summary>
			private string GetLocalPropertyNameRef(CrystalJsonMemberMetadata member) => "PropertyNames." + member.MemberName;

			/// <summary>Returns the name of the generated const string with the serialized name of this member, from another part of the generated code</summary>
			private string GetTargetPropertyNameRef(CrystalJsonTypeMetadata type, CrystalJsonMemberMetadata member) => $"{this.Metadata.Name}.{this.GetSerializerName(type.Type)}.PropertyNames.{member.MemberName}";

			/// <summary>Returns the name of the generated static singleton with the definition of this member</summary>
			private string GetPropertyEncodedNameRef(CrystalJsonMemberMetadata member) => "PropertyEncodedNames." + member.MemberName;

			/// <summary>Generates all types required to serialize a specific type</summary>
			private void GenerateCodeForType(CSharpCodeBuilder sb, CrystalJsonTypeMetadata typeDef)
			{
				var typeName = typeDef.Type.Name;
				var typeFullName = typeDef.Type.FullyQualifiedName;
				var typeCref = CSharpCodeBuilder.EscapeCref(typeFullName);

				// we need to get back the type symbol from the compilation (which we do not store in the metadata, since it changes everytime)

				var serializerName = typeName;
				if (typeDef.Type.IsGenericType())
				{
					foreach (var t in typeDef.Type.TypeArguments)
					{
						serializerName += "_" + t.Name;
					}
				}

				var serializerTypeName = GetConverterName(typeDef);
				var jsonConverterInterfaceName = $"{KnownTypeSymbols.IJsonConverterInterfaceFullName}<{typeFullName}>";

				var readOnlyProxyTypeName = GetReadOnlyProxyName(typeDef.Type);
				var writableProxyTypeName = GetWritableProxyName(typeDef.Type);

				var readOnlyProxyInterfaceName = $"{KnownTypeSymbols.IJsonReadOnlyProxyFullName}<{typeFullName}, {readOnlyProxyTypeName}, {writableProxyTypeName}>";
				var writableProxyInterfaceName = $"{KnownTypeSymbols.IJsonWritableProxyFullName}<{typeFullName}, {writableProxyTypeName}>";

#if FULL_DEBUG
				sb.Comment($"Generating for type {typeDef.Type.FullyQualifiedName}");
				foreach (var member in typeDef.Members)
				{
					sb.Comment($"- {member.Name}: {member.ToString()}");
				}
				sb.NewLine();
#endif

				sb.XmlComment($"<summary>Set of JSON converters and other various helpers for type <see cref=\"{typeCref}\">{typeName}</see></summary>");
				sb.AppendLine("public static class " + serializerName);
				sb.EnterBlock();
				sb.NewLine();

				sb.XmlComment($"<summary>JSON converter for type <see cref=\"{typeCref}\">{typeName}</see></summary>");
				sb.AppendLine($"public static {serializerTypeName} Default => m_cachedSerializer ??= new();");
				sb.NewLine();
				sb.AppendLine($"private static {serializerTypeName}? m_cachedSerializer;");
				sb.NewLine();

				sb.BeginRegion("Proxy Helpers...");
				sb.NewLine();

				WriteProxyStaticHelpers(sb, typeDef, typeFullName, typeCref);

				sb.EndRegion();
				sb.NewLine();

				#region Metadata...

				sb.BeginRegion("Metadata...");
				sb.NewLine();

				sb.XmlComment("<summary>Names of all serialized members for this type</summary>");
				sb.AppendLine("public static class PropertyNames");
				sb.EnterBlock("properties");
				sb.NewLine();
				foreach (var member in typeDef.Members)
				{
					sb.XmlComment($"<summary>Serialized name of the <see cref=\"{typeCref}.{member.MemberName}\"/> {(member.IsField ? "field" : "property")} of the <see cref=\"{typeCref}\"/> {(member.Type.IsValueType() ? "struct" : member.Type.IsRecord ? "record" : "class")}</summary>");
					sb.AppendLine($"public const string {member.MemberName} = {CSharpCodeBuilder.Constant(member.Name)};");
					sb.NewLine();
				}

				sb.AppendLine($"public static string[] GetAllNames() => new [] {{ {string.Join(", ", typeDef.Members.Select(this.GetLocalPropertyNameRef))} }};"); //TODO: PERF!
				sb.NewLine();

				sb.LeaveBlock("properties");
				sb.NewLine();

				sb.XmlComment("<summary>Cached encoded names for all serialized members for this type</summary>");
				sb.AppendLine("public static class PropertyEncodedNames");
				sb.EnterBlock("properties");
				sb.NewLine();
				foreach (var member in typeDef.Members)
				{
					sb.XmlComment($"<summary>Encoded name of the <see cref=\"{typeCref}.{member.MemberName}\"/> {(member.IsField ? "field" : "property")} of the <see cref=\"{typeCref}\"/> {(member.Type.IsValueType() ? "struct" : member.Type.IsRecord ? "record" : "class")}</summary>");
					sb.AppendLine($"public static readonly {KnownTypeSymbols.JsonEncodedPropertyNameFullName} {member.MemberName} = new({GetLocalPropertyNameRef(member)});");
					sb.NewLine();
				}
				sb.LeaveBlock("properties");
				sb.NewLine();

				sb.EndRegion();
				sb.NewLine();

				#endregion

				#region JsonConverter class...

				sb.AppendLine($"public sealed class JsonConverter : {KnownTypeSymbols.IJsonConverterInterfaceFullName}<{typeFullName}, {readOnlyProxyTypeName}, {writableProxyTypeName}>"); //TODO: implements!
				sb.EnterBlock("JsonConverter");
				
				#region Type Definition...

				sb.BeginRegion("Conversion Helpers...");
				sb.NewLine();

				WriteTypeDefinitionHelpers(sb, typeDef);

				sb.EndRegion();
				sb.NewLine();

				#endregion
				
				#region Helpers...

				sb.BeginRegion("Conversion Helpers...");
				sb.NewLine();

				sb.InheritDoc();
				sb.AppendLine($"public Type GetTargetType() => typeof({typeDef.Type.FullyQualifiedName});");
				sb.NewLine();

				WriteProxyInstanceHelpers(sb, typeDef, typeCref);

				sb.EndRegion();
				sb.NewLine();

				#endregion

				#region Serialize...

				sb.BeginRegion($"IJsonSerializer<{typeName}>...");
				sb.NewLine();

				WriteSerializeMethod(sb, typeDef, typeCref);

				sb.EndRegion();
				sb.NewLine();

				#endregion

				#region Pack...

				sb.BeginRegion($"IJsonPacker<{typeName}>...");
				sb.NewLine();

				WritePackMethod(sb, typeDef);

				sb.EndRegion();
				sb.NewLine();

				#endregion

				#region UnPack...

				sb.BeginRegion($"IJsonDeserializer<{typeName}>...");
				sb.NewLine();

				WriteUnpackMethod(sb, typeDef, typeCref);

				sb.EndRegion();
				sb.NewLine();

				#endregion

				sb.LeaveBlock("JsonConverter");
				sb.NewLine();

				#endregion

				#region Read-Only Proxy...

				// IJsonReadOnlyProxy<T>
				sb.XmlComment($"<summary>Wraps a <see cref=\"{KnownTypeSymbols.JsonObjectFullName}\"/> into a read-only type-safe view that emulates the type <see cref=\"{typeCref}\"/></summary>");
				sb.XmlComment($"<seealso cref=\"{KnownTypeSymbols.IJsonReadOnlyProxyFullName}{{T}}\"/>");
				sb.Struct(
					"public readonly",
					"ReadOnly",
					[ readOnlyProxyInterfaceName ],
					[],
					() =>
					{
						// m_value
						sb.XmlComment("<summary>Observable JSON Value wrapped by this instance</summary>");
						sb.AppendLine($"private readonly {KnownTypeSymbols.ObservableJsonValueFullName} m_value;");
						sb.NewLine();

						// ctor()
						sb.AppendLine($"public ReadOnly({KnownTypeSymbols.ObservableJsonValueFullName} value)");
						sb.EnterBlock();
						sb.AppendLine("m_value = value;");
						sb.LeaveBlock();
						sb.NewLine();

						#region Methods...

						sb.BeginRegion("Public Helpers...");
						sb.NewLine();

						// static Create()
						sb.InheritDoc();
						sb.AppendLine($"public static {readOnlyProxyTypeName} Create({KnownTypeSymbols.ObservableJsonValueFullName} value, {jsonConverterInterfaceName}? converter = null)");
						sb.AppendLine("\t=> new(value);");
						sb.NewLine();

						// static Create()
						sb.InheritDoc();
						sb.AppendLine($"public static {readOnlyProxyTypeName} Create({KnownTypeSymbols.JsonValueFullName} value, {jsonConverterInterfaceName}? converter = null)");
						sb.AppendLine($"\t=> new({KnownTypeSymbols.ObservableJsonValueFullName}.Untracked(value));");
						sb.NewLine();

						// static Create()
						sb.InheritDoc();
						sb.AppendLine($"public static {readOnlyProxyTypeName} Create({KnownTypeSymbols.IObservableJsonContextFullName} ctx, {KnownTypeSymbols.JsonValueFullName} value, {jsonConverterInterfaceName}? converter = null)");
						sb.AppendLine($"\t=> new({KnownTypeSymbols.ObservableJsonValueFullName}.Tracked(ctx, value));");
						sb.NewLine();

						// static Create()
						sb.InheritDoc();
						sb.AppendLine($"public static {readOnlyProxyTypeName} Create({typeDef.Type.FullyQualifiedNameAnnotated} value, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = null, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = null)");
						sb.AppendLine($"\t=> new({KnownTypeSymbols.ObservableJsonValueFullName}.Untracked({GetLocalSerializerRef(typeDef)}.Pack(value, settings.AsReadOnly(), resolver)));");
						sb.NewLine();

						// static Create()
						sb.InheritDoc();
						sb.AppendLine($"public static {readOnlyProxyTypeName} Create({KnownTypeSymbols.IObservableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedNameAnnotated} value, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = null, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = null)");
						sb.AppendLine($"\t=> new({KnownTypeSymbols.ObservableJsonValueFullName}.Tracked(ctx, {GetLocalSerializerRef(typeDef)}.Pack(value, settings.AsReadOnly(), resolver)));");
						sb.NewLine();

						// static Converter
						sb.InheritDoc();
						sb.AppendLine($"public static {jsonConverterInterfaceName} Converter => {GetLocalSerializerRef(typeDef)};");
						sb.NewLine();

						// TValue ToValue()
						sb.InheritDoc();
						sb.AppendLine($"public {typeDef.Type.FullyQualifiedName} ToValue() => {GetLocalSerializerRef(typeDef)}.Unpack(m_value.ToJsonValue());"); //TODO: resolver?
						sb.NewLine();

						// GetContext()
						sb.InheritDoc();
						sb.AppendLine($"public {KnownTypeSymbols.IObservableJsonContextFullName}? GetContext() => m_value.GetContext();");
						sb.NewLine();

						// bool IsNullOrMissing()
						sb.XmlComment("<summary>Tests if this object is either null or missing</summary>");
						sb.XmlComment("<returns><c>true</c> if the wrapped JSON value is null or empty; otherwise, <c>false</c>.</returns>");
						sb.AppendLine("public bool IsNullOrMissing() => m_value.IsNullOrMissing();");
						sb.NewLine();

						// bool Exists()
						sb.XmlComment("<summary>Tests if this object is present</summary>");
						sb.XmlComment("<returns><c>false</c> if the wrapped JSON value is null or empty; otherwise, <c>true</c>.</returns>");
						sb.AppendLine("public bool Exists() => m_value.Exists();");
						sb.NewLine();

						// bool IsObject()
						sb.XmlComment("<summary>Tests if the wrapped value is a valid JSON Object.</summary>");
						sb.XmlComment("<returns><c>true</c> if the wrapped JSON value is a non-null Object; otherwise, <c>false</c></returns>");
						sb.AppendLine("public bool IsObject() => m_value.IsOfType(JsonType.Object);");
						sb.NewLine();

						// bool IsObjectOrMissing()
						sb.XmlComment("<summary>Tests if the wrapped value is a valid JSON Object.</summary>");
						sb.XmlComment("<returns><c>true</c> if the wrapped JSON value is a non-null Object; otherwise, <c>false</c></returns>");
						sb.AppendLine("public bool IsObjectOrMissing() => m_value.IsOfTypeOrNull(JsonType.Object);");
						sb.NewLine();

						// Get()
						sb.InheritDoc();
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} Get() => m_value;");
						sb.NewLine();

						// ToJsonValue()
						sb.InheritDoc();
						sb.AppendLine($"public {KnownTypeSymbols.JsonValueFullName} ToJsonValue() => m_value.ToJsonValue();");
						sb.NewLine();

						// ToMutable()
						sb.InheritDoc();
						sb.AppendLine($"public {writableProxyTypeName} ToMutable() => new({KnownTypeSymbols.MutableJsonValueFullName}.Untracked(m_value.GetJsonUnsafe().Copy()));");
						sb.NewLine();

						// this[string]
						sb.InheritDoc();
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} this[string name] => m_value.Get(name);");
						sb.NewLine();

						// Get(string)
						sb.InheritDoc();
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} Get(string name) => m_value.Get(name);");
						sb.NewLine();

						// Get<T>(string)
						sb.InheritDoc();
						sb.AppendLine("public T Get<T>(string name) where T : notnull => m_value.Get<T>(name);");
						sb.NewLine();

						// Get<T>(string, T)
						sb.InheritDoc();
						sb.AppendLine($"[return: {NotNullIfNotNullAttributeFullName}(nameof(defaultValue))]");
						sb.AppendLine("public T? Get<T>(string name, T defaultValue) => m_value.Get<T>(name, defaultValue);");
						sb.NewLine();

						// this[ReadOnlyMemory<char>]
						sb.InheritDoc();
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} this[ReadOnlyMemory<char> name] => m_value.Get(name);");
						sb.NewLine();

						// Get(ReadOnlyMemory<char>)
						sb.InheritDoc();
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} Get(ReadOnlyMemory<char> name) => m_value.Get(name);");
						sb.NewLine();

						// Get<T>(ReadOnlyMemory<char>)
						sb.InheritDoc();
						sb.AppendLine("public T Get<T>(ReadOnlyMemory<char> name) where T : notnull => m_value.Get<T>(name);");
						sb.NewLine();

						// Get<T>(ReadOnlyMemory<char>, T)
						sb.InheritDoc();
						sb.AppendLine($"[return: {NotNullIfNotNullAttributeFullName}(nameof(defaultValue))]");
						sb.AppendLine("public T? Get<T>(ReadOnlyMemory<char> name, T defaultValue) => m_value.Get<T>(name, defaultValue);");
						sb.NewLine();

						// Get(JsonPath)
						sb.InheritDoc();
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} Get({KnownTypeSymbols.JsonPathFullName} path) => m_value.Get(path);");
						sb.NewLine();

						// Get<T>(JsonPath)
						sb.InheritDoc();
						sb.AppendLine($"public T Get<T>({KnownTypeSymbols.JsonPathFullName} path) where T : notnull => m_value.Get<T>(path);");
						sb.NewLine();

						// Get<T>(JsonPath, T)
						sb.InheritDoc();
						sb.AppendLine($"[return: {NotNullIfNotNullAttributeFullName}(nameof(defaultValue))]");
						sb.AppendLine($"public T? Get<T>({KnownTypeSymbols.JsonPathFullName} path, T defaultValue) => m_value.Get<T>(path, defaultValue);");
						sb.NewLine();

						// Get(int)
						sb.InheritDoc();
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} Get(int index) => m_value.Get(index);");
						sb.NewLine();

						// Get(Index)
						sb.InheritDoc();
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} Get(Index index) => m_value.Get(index);");
						sb.NewLine();

						// TReadOnly With(Action<TMutable>)
						sb.InheritDoc();
						sb.AppendLine($"public {readOnlyProxyTypeName} With(Action<{writableProxyTypeName}> modifier)");
						sb.EnterBlock();
						sb.AppendLine("var copy = m_value.GetJsonUnsafe().Copy();");
						sb.AppendLine($"modifier(new({KnownTypeSymbols.MutableJsonValueFullName}.Untracked(copy)));");
						sb.AppendLine("return new(m_value.Visit(copy.Freeze()));");
						sb.LeaveBlock();
						sb.NewLine();

						sb.InheritDoc();
						sb.AppendLine("public override bool Equals(object? other) => other switch");
						sb.EnterBlock();
						sb.AppendLine($"{readOnlyProxyTypeName} value => m_value.Equals(value.m_value),");
						sb.AppendLine($"{KnownTypeSymbols.ObservableJsonValueFullName} value => m_value.Equals(value),");
						sb.AppendLine($"{KnownTypeSymbols.JsonValueFullName} value => m_value.Equals(value),");
						sb.AppendLine("null => m_value.IsNullOrMissing(),");
						sb.AppendLine("_ => false,");
						sb.LeaveBlock(suffix: ';');
						sb.NewLine();

						sb.InheritDoc();
						sb.AppendLine("public override int GetHashCode() => m_value.ToJsonValue().GetHashCode();");
						sb.NewLine();

						sb.InheritDoc();
						sb.AppendLine($"public bool Equals({readOnlyProxyTypeName} value) => m_value.Equals(value.m_value);");
						sb.NewLine();

						sb.InheritDoc();
						sb.AppendLine($"public bool Equals({KnownTypeSymbols.ObservableJsonValueFullName}? value) => m_value.Equals(value);");
						sb.NewLine();

						sb.InheritDoc();
						sb.AppendLine($"public bool Equals({KnownTypeSymbols.JsonValueFullName}? value) => m_value.Equals(value);");
						sb.NewLine();

						sb.InheritDoc();
						sb.AppendLine($"public override string ToString() => \"({typeName}) \" + m_value.ToString();");
						sb.NewLine();

						// IJsonSerializable
						sb.InheritDoc();
						sb.AppendLine($"void {KnownTypeSymbols.IJsonSerializableFullName}.JsonSerialize({KnownTypeSymbols.CrystalJsonWriterFullName} writer) => m_value.ToJsonValue().JsonSerialize(writer);");
						sb.NewLine();

						// IJsonPackable
						sb.InheritDoc();
						sb.AppendLine($"{KnownTypeSymbols.JsonValueFullName} {KnownTypeSymbols.IJsonPackableFullName}.JsonPack({KnownTypeSymbols.CrystalJsonSettingsFullName} settings, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName} resolver) => m_value.ToJsonValue();");
						sb.NewLine();

						sb.EndRegion();
						sb.NewLine();

						#endregion

						#region Members

						sb.BeginRegion("Type Safe Members...");
						sb.NewLine();

						foreach (var member in typeDef.Members)
						{
							//HACKHACK: TODO: BUGBUG: generate the proper literal for the default of the type ("default", "null", "0", "false", ...)

							string? getterExpr = null;
							string proxyType = member.Type.FullyQualifiedNameAnnotated;

							if (IsLocallyGeneratedType(member.Type, out var target, out _))
							{
								getterExpr = $"/* local-deserializer */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
								proxyType = GetLocalReadOnlyProxyRef(target);
							}
							else if (member.Type.IsStringLike() || member.Type.IsBooleanLike() || member.Type.IsNumberLike() || member.Type.IsDateLike())
							{
								//use default getter
								getterExpr = null;
							}
							else if (member.Type.JsonType is not JsonPrimitiveType.None)
							{
								getterExpr = member.Type.JsonType switch
								{
									JsonPrimitiveType.Object => $"/* direct-json-object */ m_value[{this.GetTargetPropertyNameRef(typeDef, member)}].ToJsonValue().{(member.IsNullableRefType() ? "AsObjectOrDefault" : member.IsRequired ? "AsObject" : "AsObjectOrEmpty")}()",
									JsonPrimitiveType.Array => $"/* direct-json-array */ m_value[{this.GetTargetPropertyNameRef(typeDef, member)}].ToJsonValue().{(member.IsNullableRefType() ? "AsArrayOrDefault" : member.IsRequired ? "AsArray" : "AsArrayOrEmpty")}()",
									//TODO: JsonString, JsonNumber, ... (are they really used?)
									_ => $"/* direct-json-value */ m_value[{this.GetTargetPropertyNameRef(typeDef, member)}].ToJsonValue()"
								};
							}
							else if (member.Type.IsJsonDeserializable)
							{
								getterExpr = $"/* json-deserializable */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.UnpackJsonDeserializable<{member.Type.FullyQualifiedName}>(m_value[{GetTargetPropertyNameRef(typeDef, member)}].ToJsonValue(), {member.DefaultLiteral}, null)"; //TODO: default value!
							}
							else if (member.Type.IsNullableOfT(out var underlyingType) && underlyingType.IsJsonDeserializable)
							{
								getterExpr = $"/* nullable-json-deserializable */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.UnpackNullableJsonDeserializable<{underlyingType.FullyQualifiedName}>(m_value[{GetTargetPropertyNameRef(typeDef, member)}].ToJsonValue(), {member.DefaultLiteral}, null)"; //TODO: default value!
							}
							else if (member.Type.IsDictionary(out var keyType, out var valueType))
							{
								if (keyType.IsString())
								{
									if (IsLocallyGeneratedType(valueType, out target, out _))
									{
										getterExpr = $"/* dict-local */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
										proxyType = $"{KnownTypeSymbols.JsonReadOnlyProxyDictionaryFullName}<{valueType.FullyQualifiedName}, {GetLocalReadOnlyProxyRef(target)}>";
									}
									else
									{
										getterExpr = $"/* dict-fallback */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
										proxyType = $"{KnownTypeSymbols.JsonReadOnlyProxyDictionaryFullName}<{valueType.FullyQualifiedName}>";
									}
								}
							}
							else if (member.Type.IsEnumerable(out var elemType))
							{
								if (IsLocallyGeneratedType(elemType, out target, out _))
								{
									getterExpr = $"/* enumerable-local */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
									proxyType = $"{KnownTypeSymbols.JsonReadOnlyProxyArrayFullName}<{elemType.FullyQualifiedName}, {GetLocalReadOnlyProxyRef(target)}>";
								}
								else
								{
									getterExpr = $"/* enumerable-fallback */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
									proxyType = $"{KnownTypeSymbols.JsonReadOnlyProxyArrayFullName}<{elemType.FullyQualifiedName}>";
								}
							}

							if (getterExpr == null)
							{
								if (member.IsNullableRefType())
								{
									getterExpr = $"/* ref-nullable */ m_value.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetTargetPropertyNameRef(typeDef, member)}, {member.DefaultLiteral})";
								}
								else if (member.IsRequired)
								{
									getterExpr = $"/* required */ m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)})";
								}
								else if (member.Type.IsValueType() && !member.Type.IsNullableOfT())
								{ // TODO: BUGBUG: it is the same as the next statement?
									getterExpr = $"/* vt-not-null */ m_value.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetTargetPropertyNameRef(typeDef, member)}, {member.DefaultLiteral})";
								}
								else
								{
									getterExpr = $"/* else */ m_value.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetTargetPropertyNameRef(typeDef, member)}, {member.DefaultLiteral})";
								}
							}

							sb.InheritDoc(CSharpCodeBuilder.EscapeCref(typeFullName, member.MemberName));
							sb.AppendLine($"public {proxyType} {member.MemberName} => {getterExpr};");
							sb.NewLine();

							// for required member, we also generate a HasXYZ() method that will allow the caller to check if the field is valid (before calling the property that would throw if this is not the case)
							if (member.IsRequired)
							{
								sb.XmlComment($"<summary>Tests if the object has a valid value for the <see cref=\"{member.MemberName}\"/> property.</summary>");
								sb.AppendLine($"public bool Has{member.MemberName}() => m_value.ContainsKey({GetTargetPropertyNameRef(typeDef, member)});");
								sb.NewLine();
							}
						}

						sb.EndRegion();
						sb.NewLine();

						#endregion
					}
				);

				#endregion

				#region Writable Proxy...

				//note: we cannot generate a readonly struct, otherwise the following would not be allowed
				//  obj.Foo = 123; // this can work
				//	obj.Bar.Bar = 123; // this fails to compile because "obj.Bar" is not a valid 'this' for the Baz setter

				// IJsonWritableProxy<T>
				sb.XmlComment($"<summary>Wraps a <see cref=\"{KnownTypeSymbols.JsonObjectFullName}\"/> into a writable type-safe view that emulates the type <see cref=\"{typeCref}\"/></summary>");
				sb.XmlComment($"<seealso cref=\"{KnownTypeSymbols.IJsonWritableProxyFullName}{{T}}\"/>");
				sb.Record(
					"public sealed",
					"Writable",
					[
						KnownTypeSymbols.JsonWritableProxyObjectBaseFullName,
						writableProxyInterfaceName
					],
					[],
					() =>
					{
						// ctor()
						sb.AppendLine($"public Writable({KnownTypeSymbols.MutableJsonValueFullName} value) : base(value)");
						sb.EnterBlock();
						sb.LeaveBlock();
						sb.NewLine();

						#region Methods...

						sb.BeginRegion("Public Methods...");
						sb.NewLine();

						// static Create()
						sb.InheritDoc();
						sb.AppendLine($"public static {writableProxyTypeName} Create({KnownTypeSymbols.MutableJsonValueFullName} value, {jsonConverterInterfaceName}? converter = null) => new(value);");
						sb.NewLine();

						// static Create()
						sb.InheritDoc();
						sb.AppendLine($"public static {writableProxyTypeName} Create({KnownTypeSymbols.JsonValueFullName} value) => new({KnownTypeSymbols.MutableJsonValueFullName}.Untracked(value));");
						sb.NewLine();

						// static Create()
						sb.InheritDoc();
						sb.AppendLine($"public static {writableProxyTypeName} Create({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {KnownTypeSymbols.JsonValueFullName} value) => new({KnownTypeSymbols.MutableJsonValueFullName}.Tracked(ctx, value));");
						sb.NewLine();

						// static Create()
						sb.InheritDoc();
						sb.AppendLine($"public static {writableProxyTypeName} Create({typeDef.Type.FullyQualifiedNameAnnotated} value, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = null, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = null) => new({KnownTypeSymbols.MutableJsonValueFullName}.Untracked({GetLocalSerializerRef(typeDef)}.Pack(value, settings.AsMutable(), resolver)));");
						sb.NewLine();

						// static Create()
						sb.InheritDoc();
						sb.AppendLine($"public static {writableProxyTypeName} Create({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedNameAnnotated} value, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = null, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = null) => new({KnownTypeSymbols.MutableJsonValueFullName}.Tracked(ctx, {GetLocalSerializerRef(typeDef)}.Pack(value, settings.AsMutable(), resolver)));");
						sb.NewLine();

						// static Converter
						sb.InheritDoc();
						sb.AppendLine($"public static {jsonConverterInterfaceName} Converter => {GetLocalSerializerRef(typeDef)};");
						sb.NewLine();

						// TMutable FromValue(TValue)
						sb.XmlComment($"<summary>Pack an instance of <see cref=\"{typeCref}\"/> into a mutable JSON proxy</summary>");
						sb.AppendLine($"public static {writableProxyTypeName} FromValue({typeDef.Type.FullyQualifiedName} value)");
						sb.EnterBlock();
						if (!typeDef.Type.IsValueType())
						{
							sb.AppendLine("ArgumentNullException.ThrowIfNull(value);");
						}
						sb.AppendLine($"return new({KnownTypeSymbols.MutableJsonValueFullName}.Untracked({GetLocalSerializerRef(typeDef)}.Pack(value, {KnownTypeSymbols.CrystalJsonSettingsFullName}.Json)));");
						sb.LeaveBlock();
						sb.NewLine();

						// TMutable FromValue(TValue)
						sb.XmlComment($"<summary>Pack an instance of <see cref=\"{typeCref}\"/> into a mutable JSON proxy</summary>");
						sb.AppendLine($"public static {writableProxyTypeName} FromValue({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedName} value)");
						sb.EnterBlock();
						if (!typeDef.Type.IsValueType())
						{
							sb.AppendLine("ArgumentNullException.ThrowIfNull(value);");
						}
						sb.AppendLine($"return new({KnownTypeSymbols.MutableJsonValueFullName}.Tracked(ctx, {GetLocalSerializerRef(typeDef)}.Pack(value, {KnownTypeSymbols.CrystalJsonSettingsFullName}.Json)));");
						sb.LeaveBlock();
						sb.NewLine();

						// ToValue()
						sb.InheritDoc();
						sb.AppendLine($"public {typeDef.Type.FullyQualifiedName} ToValue() => {GetLocalSerializerRef(typeDef)}.Unpack(m_value.ToJsonValue());"); //TODO: resolver?
						sb.NewLine();

						// TReadOnly ToReadOnly()
						sb.InheritDoc();
						sb.AppendLine($"public {readOnlyProxyTypeName} ToReadOnly() => new({KnownTypeSymbols.ObservableJsonValueFullName}.Untracked(m_value.ToJsonValue().ToReadOnly()));");
						sb.NewLine();

						// Set(TReadOnly)
						sb.XmlComment("<summary>Replaces the value of this instance</summary>");
						sb.AppendLine($"public void Set({readOnlyProxyTypeName} value) => m_value.Set(value.ToJsonValue());");
						sb.NewLine();

						// Set(TWritable)
						sb.XmlComment("<summary>Replaces the value of this instance</summary>");
						sb.AppendLine($"public void Set({writableProxyTypeName} value) => m_value.Set(value.ToJsonValue());");
						sb.NewLine();

						// Set(T)
						sb.XmlComment("<summary>Replaces the value of this instance</summary>");
						sb.AppendLine($"public void Set({typeDef.Type.FullyQualifiedName} instance) => m_value.Set({GetLocalSerializerRef(typeDef)}.Pack(instance, {KnownTypeSymbols.CrystalJsonSettingsFullName}.Json));");
						sb.NewLine();

						// GetHashCode()
						sb.InheritDoc();
						sb.AppendLine($"[{DoesNotReturnAttributeFullName}]");
						sb.AppendLine("public override int GetHashCode() => throw new NotSupportedException();");
						sb.NewLine();

						// Equals(TWritable)
						sb.InheritDoc();
						sb.AppendLine($"public bool Equals({writableProxyTypeName}? value) => m_value.Equals(value?.m_value);");
						sb.NewLine();

						// ToString()
						sb.InheritDoc();
						sb.AppendLine($"public override string ToString() => \"({typeName}) \" + m_value.ToString();");
						sb.NewLine();

						sb.EndRegion();
						sb.NewLine();

						#endregion

						#region Members

						sb.BeginRegion("Public Members...");
						sb.NewLine();
						foreach (var member in typeDef.Members)
						{
							var defaultValue = member.DefaultLiteral;

							string proxyType = member.Type.FullyQualifiedNameAnnotated;
							string? setterExpr = null;
							string? getterExpr = null;
							string? attributeExpr = null;

							if (IsLocallyGeneratedType(member.Type, out var target, out _))
							{
								proxyType = GetLocalWritableProxyRef(target);
								getterExpr = $"/* proxy */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
								setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value.ToJsonValue())";
							}
							else if (member.Type.IsStringLike() || member.Type.IsBooleanLike() || member.Type.IsNumberLike() || member.Type.IsDateLike())
							{
								if (member.Type.IsString())
								{
									if (member.IsRequired)
									{
										attributeExpr = $"[{DisallowNullAttributeFullName}]";
										if (!proxyType.EndsWith("?")) proxyType += "?";
									}
									getterExpr ??= $"/* fast-string */ m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToStringOrDefault({defaultValue})";
								}
								else if (member.IsNullableRefType())
								{
									getterExpr ??= $"/* ref-nullable */ m_value.Get<{member.Type.FullyQualifiedName}?>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
								}
								else if (member.IsRequired)
								{
									if (!member.IsNotNull)
									{
										attributeExpr = $"[{DisallowNullAttributeFullName}]";
										if (!proxyType.EndsWith("?")) proxyType += "?";
									}
									getterExpr ??= member.Type.SpecialType switch
									{
										SpecialType.System_Char => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToChar({defaultValue})",
										SpecialType.System_Boolean => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToBoolean({defaultValue})",
										SpecialType.System_Int32 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt32({defaultValue})",
										SpecialType.System_UInt32 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToUInt32({defaultValue})",
										SpecialType.System_Int64 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt64({defaultValue})",
										SpecialType.System_UInt64 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToUInt64({defaultValue})",
										SpecialType.System_Single => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToSingle({defaultValue})",
										SpecialType.System_Double => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDouble({defaultValue})",
										SpecialType.System_Decimal => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDecimal({defaultValue})",
										SpecialType.System_DateTime => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDateTime({defaultValue})",
										_ => $"m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})"
									};
									getterExpr = "/* required */ " + getterExpr;
								}
								else if (member.Type.IsValueType() && !member.Type.IsNullableOfT())
								{
									getterExpr ??= member.Type.SpecialType switch
									{
										SpecialType.System_Boolean => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToBoolean({defaultValue})",
										SpecialType.System_Char => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToChar({defaultValue})",
										SpecialType.System_Int32 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt32({defaultValue})",
										SpecialType.System_UInt32 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToUInt32({defaultValue})",
										SpecialType.System_Int64 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt64({defaultValue})",
										SpecialType.System_UInt64 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToUInt64({defaultValue})",
										SpecialType.System_Single => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToSingle({defaultValue})",
										SpecialType.System_Double => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDouble({defaultValue})",
										SpecialType.System_Decimal => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDecimal({defaultValue})",
										SpecialType.System_DateTime => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDateTime({defaultValue})",
										_ => $"m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})"
									};
									getterExpr = "/* value-type */ " + getterExpr;
								}
								else if (member.Type.IsNullableOfT())
								{
									getterExpr ??= member.Type.SpecialType switch
									{
										SpecialType.System_Boolean => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToBooleanOrDefault({defaultValue})",
										SpecialType.System_Char => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToCharOrDefault({defaultValue})",
										SpecialType.System_Int32 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt32OrDefault({defaultValue})",
										SpecialType.System_UInt32 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToUInt32OrDefault({defaultValue})",
										SpecialType.System_Int64 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt64OrDefault({defaultValue})",
										SpecialType.System_UInt64 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToUInt64OrDefault({defaultValue})",
										SpecialType.System_Single => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToSingleOrDefault({defaultValue})",
										SpecialType.System_Double => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDoubleOrDefault({defaultValue})",
										SpecialType.System_Decimal => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDecimalOrDefault({defaultValue})",
										SpecialType.System_DateTime => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDateTimeOrDefault({defaultValue})",
										_ => $"m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})"
									};
									getterExpr = "/* vt-nullable */ " + getterExpr;
								}
								else
								{
									getterExpr ??= $"/* else */ m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
								}

								if (member.Type.IsStringLike(allowNullables: true))
								{
									setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
								else if (member.Type.IsBooleanLike(allowNullables: true))
								{
									setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
								else if (member.Type.IsNumberLike(allowNullables: true))
								{
									setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
								else if (member.Type.IsDateLike(allowNullables: true))
								{
									setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
							}
							else if (member.Type.JsonType is not JsonPrimitiveType.None)
							{
								setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value?.ToJsonValue() ?? JsonNull.Null)";
								proxyType = KnownTypeSymbols.MutableJsonValueFullName;
								getterExpr = $"/* json */ m_value[{GetTargetPropertyNameRef(typeDef, member)}]";
							}
							else if (member.Type.IsDictionary(out var keyType, out var valueType))
							{
								if (keyType.IsString())
								{
									if (IsLocallyGeneratedType(valueType, out target, out _))
									{
										proxyType = $"{KnownTypeSymbols.JsonWritableProxyDictionaryFullName}<{valueType.FullyQualifiedName}, {this.GetLocalWritableProxyRef(target)}>";
										getterExpr = $"/* dict-proxy */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
										setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value.ToJsonValue())";
									}
									else if (valueType.IsStringLike() || valueType.IsBooleanLike() || valueType.IsNumberLike() || valueType.IsDateLike())
									{
										proxyType = $"{KnownTypeSymbols.JsonWritableProxyDictionaryFullName}<{valueType.FullyQualifiedNameAnnotated}>";
										getterExpr = $"/* dict */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
										setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value.ToJsonValue())";
									}
									//TODO: other types?
								}
							}
							else if (member.Type.IsEnumerable(out var elemType))
							{
								if (IsLocallyGeneratedType(elemType, out target, out _))
								{
									proxyType = $"{KnownTypeSymbols.JsonWritableProxyArrayFullName}<{elemType.FullyQualifiedName}, {this.GetLocalWritableProxyRef(target)}>";
									getterExpr = $"/* array-proxy */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
									setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value.ToJsonValue())";
								}
								else if (elemType.IsStringLike() || elemType.IsBooleanLike() || elemType.IsNumberLike() || elemType.IsDateLike())
								{
									proxyType = $"{KnownTypeSymbols.JsonWritableProxyArrayFullName}<{elemType.FullyQualifiedName}>";
									getterExpr = $"/* array */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
									setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value.ToJsonValue())";
								}
								//TODO: other types?
							}

							if (getterExpr == null)
							{
								if (member.IsNullableRefType())
								{
									getterExpr = $"/* fallback-ref-nullable */ m_value.Get<{member.Type.FullyQualifiedName}?>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
								}
								else if (member.IsRequired)
								{
									getterExpr = $"/* fallback-required */ m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)})";
								}
								else
								{
									getterExpr = $"/* fallback-else */ m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
								}
							}

							if (setterExpr == null)
							{
								if (member.IsNullableRefType())
								{
									setterExpr ??= $"m_value.Set<{member.Type.FullyQualifiedName}?>({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
								else
								{
									setterExpr ??= $"m_value.Set<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
							}

							sb.InheritDoc(CSharpCodeBuilder.EscapeCref(typeDef.Type.FullyQualifiedName, member.MemberName));
							if (attributeExpr != null) sb.AppendLine(attributeExpr);
							sb.AppendLine($"public {proxyType} {member.MemberName}");
							sb.EnterBlock();
							sb.AppendLine($"get => {getterExpr};");
							sb.AppendLine($"set => {setterExpr};");
							sb.LeaveBlock();
							sb.NewLine();
						}

						sb.EndRegion();
						sb.NewLine();

						#endregion

					}
				);

				#endregion

				sb.LeaveBlock();
				sb.NewLine();

			}

			private void WriteProxyStaticHelpers(CSharpCodeBuilder sb, CrystalJsonTypeMetadata typeDef, string typeFullName, string typeCref)
			{
				// Serialize(...)
				if (typeDef.Type.IsValueType())
				{
					sb.XmlComment($"<summary>Writes a JSON representation of a value of type <see cref=\"{typeCref}\" /> to the specified output</summary>");
					sb.AppendLine($"public static void Serialize({KnownTypeSymbols.CrystalJsonWriterFullName} writer, {typeDef.Type.FullyQualifiedName}? instance) => Default.Serialize(writer, instance);");
					sb.NewLine();
				}
				sb.XmlComment($"<summary>Writes a JSON representation of a value of type <see cref=\"{typeCref}\" /> to the specified output</summary>");
				sb.AppendLine($"public static void Serialize({KnownTypeSymbols.CrystalJsonWriterFullName} writer, {typeDef.Type.FullyQualifiedName}{(typeDef.Type.IsValueType() ? "" : "?")} instance) => Default.Serialize(writer, instance);");
				sb.NewLine();

				// ToJsonText(...)
				sb.XmlComment($"<summary>Serializes a value of type <see cref=\"{typeCref}\" /> into a string literal</summary>");
				sb.AppendLine($"public static string ToJsonText({typeDef.Type.FullyQualifiedNameAnnotated} instance, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default) => Default.ToJson(instance, settings, resolver);");
				sb.NewLine();

				// ToJsonBytes(...)
				sb.XmlComment($"<summary>Serializes a value of type <see cref=\"{typeCref}\" /> into a byte array</summary>");
				sb.AppendLine($"public static byte[] ToJsonBytes({typeDef.Type.FullyQualifiedNameAnnotated} instance, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default) => {KnownTypeSymbols.CrystalJsonFullName}.ToBytes(instance, Default, settings ?? {KnownTypeSymbols.CrystalJsonSettingsFullName}.JsonCompact, resolver);");
				sb.NewLine();

				// ToJsonSlice(...)
				sb.XmlComment($"<summary>Serializes a value of type <see cref=\"{typeCref}\" /> into a <see cref=\"{KnownTypeSymbols.SliceFullName}\"/></summary>");
				sb.AppendLine($"public static {KnownTypeSymbols.SliceFullName} ToJsonSlice({typeDef.Type.FullyQualifiedNameAnnotated} instance, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default) => {KnownTypeSymbols.CrystalJsonFullName}.ToSlice(instance, Default, settings ?? {KnownTypeSymbols.CrystalJsonSettingsFullName}.JsonCompact, resolver);");
				sb.NewLine();

				// ToJsonSlice(...)
				sb.XmlComment($"<summary>Serializes a value of type <see cref=\"{typeCref}\" /> into a <see cref=\"{KnownTypeSymbols.SliceFullName}\"/>, using the specified <see cref=\"{KnownTypeSymbols.ArrayPoolFullName}{{T}}\"/></summary>");
				sb.AppendLine($"public static {KnownTypeSymbols.SliceOwnerFullName} ToJsonSlice({typeDef.Type.FullyQualifiedNameAnnotated} instance, {KnownTypeSymbols.ArrayPoolFullName}<byte>? pool, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default) => {KnownTypeSymbols.CrystalJsonFullName}.ToSlice(instance, Default, pool, settings ?? {KnownTypeSymbols.CrystalJsonSettingsFullName}.JsonCompact, resolver);");
				sb.NewLine();

				// Deserialize(...)
				sb.AppendLine($"public static {typeDef.Type.FullyQualifiedName} Deserialize(string jsonText, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default) => Default.Deserialize(jsonText, settings, resolver);");
				sb.NewLine();

				// Pack(...)
				if (typeDef.Type.IsValueType())
				{
					sb.XmlComment($"<summary>Converts an instance of this type into the equivalent <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/></summary>");
					sb.AppendLine($"public static {KnownTypeSymbols.JsonValueFullName} Pack({typeDef.Type.FullyQualifiedName}? instance, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default) => Default.Pack(instance, settings, resolver);");
					sb.NewLine();
				}

				sb.XmlComment($"<summary>Converts an instance of this type into the equivalent <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/></summary>");
				sb.AppendLine($"public static {KnownTypeSymbols.JsonValueFullName} Pack({typeDef.Type.FullyQualifiedName}{(typeDef.Type.IsValueType() ? "" : "?")} instance, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default) => Default.Pack(instance, settings, resolver);");
				sb.NewLine();

				// Unpack(...)
				sb.XmlComment($"<summary>Deserializes a JSON value into an instance of type <see cref=\"{typeCref}\" /></summary>");
				sb.AppendLine($"public static {typeDef.Type.FullyQualifiedNameAnnotated} Unpack({KnownTypeSymbols.JsonValueFullName} value, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default) => Default.Unpack(value, resolver);");
				sb.NewLine();

				// ToReadOnly(JsonValue)
				sb.XmlComment($"<summary>Returns a read-only JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as getter-only properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>The read-only view cannot modify the original JSON value but, unless <paramref name=\"value\"/> is itself read-only, any changes to the original will be reflected in the view.</para>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly(value);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue; // ERROR: will not compile (there is no setter defined for this member)");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.XmlComment($"<seealso cref=\"ToMutable({KnownTypeSymbols.JsonValueFullName})\">If you need a writable view</seealso>");
				sb.AppendLine($"public static {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({KnownTypeSymbols.JsonValueFullName} value) => {GetLocalReadOnlyProxyRef(typeDef)}.Create({KnownTypeSymbols.ObservableJsonValueFullName}.Untracked(value), Default);");
				sb.NewLine();

				// ToReadOnly(IObservableJsonContext, JsonValue)
				sb.XmlComment($"<summary>Returns a read-only JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as getter-only properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>The read-only view cannot modify the original JSON value but, unless <paramref name=\"value\"/> is itself read-only, any changes to the original will be reflected in the view.</para>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly(value);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue; // ERROR: will not compile (there is no setter defined for this member)");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.XmlComment($"<seealso cref=\"ToMutable({KnownTypeSymbols.JsonValueFullName})\">If you need a writable view</seealso>");
				sb.AppendLine($"public static {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({KnownTypeSymbols.IObservableJsonContextFullName} ctx, {KnownTypeSymbols.JsonValueFullName} value) => {GetLocalReadOnlyProxyRef(typeDef)}.Create({KnownTypeSymbols.ObservableJsonValueFullName}.Tracked(ctx, value), Default);");
				sb.NewLine();

				// ToReadOnly(TValue)
				sb.XmlComment($"<summary>Converts an instance of type <see cref=\"{typeCref}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeCref}\"/> as getter-only properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly(instance);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName};");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = /* ... */; // ERROR: will not compile (there is no setter defined for this member)");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.AppendLine($"public static {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalReadOnlyProxyRef(typeDef)}.Create(instance);");
				sb.NewLine();

				// ToReadOnly(IObservableJsonContext, TValue)
				sb.XmlComment($"<summary>Converts an instance of type <see cref=\"{typeCref}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeCref}\"/> as getter-only properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly(instance);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName};");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = /* ... */; // ERROR: will not compile (there is no setter defined for this member)");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.AppendLine($"public static {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({KnownTypeSymbols.IObservableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalReadOnlyProxyRef(typeDef)}.Create(ctx, instance);");
				sb.NewLine();

				// ToMutable(MutableJsonValue)
				sb.XmlComment($"<summary>Returns a writable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalWritableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.XmlComment($"<para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(json);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue; // change the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.XmlComment($"<seealso cref=\"ToReadOnly({KnownTypeSymbols.JsonValueFullName})\">If you need a read-only view</seealso>");
				sb.AppendLine($"public static {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.MutableJsonValueFullName} value) => {GetLocalWritableProxyRef(typeDef)}.Create(value, converter: Default);");
				sb.NewLine();

				// ToMutable(JsonValue)
				sb.XmlComment($"<summary>Returns a writable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalWritableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.XmlComment($"<para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(json);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue; // change the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.XmlComment($"<seealso cref=\"ToReadOnly({KnownTypeSymbols.JsonValueFullName})\">If you need a read-only view</seealso>");
				sb.AppendLine($"public static {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.JsonValueFullName} value) => {GetLocalWritableProxyRef(typeDef)}.Create({KnownTypeSymbols.MutableJsonValueFullName}.Untracked(value), converter: Default);");
				sb.NewLine();

				// ToMutable(IMutableJsonContext, JsonValue)
				sb.XmlComment($"<summary>Returns a writable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalWritableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.XmlComment($"<para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(json);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue; // change the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.XmlComment($"<seealso cref=\"ToReadOnly({KnownTypeSymbols.JsonValueFullName})\">If you need a read-only view</seealso>");
				sb.AppendLine($"public static {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {KnownTypeSymbols.JsonValueFullName} value) => {GetLocalWritableProxyRef(typeDef)}.Create({KnownTypeSymbols.MutableJsonValueFullName}.Tracked(ctx, value), converter: Default);");
				sb.NewLine();

				// ToMutable(TValue)
				sb.XmlComment($"<summary>Converts an instance of type <see cref=\"{typeCref}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(instance);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName};");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue;");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.AppendLine($"public static {GetLocalWritableProxyRef(typeDef)} ToMutable({typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalWritableProxyRef(typeDef)}.Create(instance);");
				sb.NewLine();

				// ToMutable(IMutableJsonContext, TValue)
				sb.XmlComment($"<summary>Converts an instance of type <see cref=\"{typeCref}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(instance);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName};");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue;");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.AppendLine($"public static {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalWritableProxyRef(typeDef)}.Create(ctx, instance);");
				sb.NewLine();

			}

			private void WriteProxyInstanceHelpers(CSharpCodeBuilder sb, CrystalJsonTypeMetadata typeDef, string typeCref)
			{

				// TryMapMemberToPropertyName()
				sb.InheritDoc();
				sb.AppendLine($"public bool TryMapMemberToPropertyName(string memberName, [{MaybeNullWhenAttributeFullName}(false)] out string propertyName)");
				sb.EnterBlock();
				sb.AppendLine("propertyName = memberName switch");
				sb.EnterBlock();
				foreach (var member in typeDef.Members)
				{
					sb.AppendLine($"nameof({typeDef.Type.FullyQualifiedName}.{member.MemberName}) => {GetLocalPropertyNameRef(member)},");
				}

				sb.AppendLine("_ => null,");
				sb.LeaveBlock(suffix: ';');
				sb.AppendLine("return propertyName != null;");
				sb.LeaveBlock();
				sb.NewLine();

				// TryMapMemberToPropertyName()
				sb.InheritDoc();
				sb.AppendLine($"public bool TryMapPropertyToMemberName(string propertyName, [{MaybeNullWhenAttributeFullName}(false)] out string memberName)");
				sb.EnterBlock();
				sb.AppendLine("memberName = propertyName switch");
				sb.EnterBlock();
				foreach (var member in typeDef.Members)
				{
					sb.AppendLine($"{GetLocalPropertyNameRef(member)} => nameof({typeDef.Type.FullyQualifiedName}.{member.MemberName}),");
				}

				sb.AppendLine("_ => null,");
				sb.LeaveBlock(suffix: ';');
				sb.AppendLine("return memberName != null;");
				sb.LeaveBlock();
				sb.NewLine();

				// ToReadOnly(JsonValue)
				sb.XmlComment($"<summary>Returns a read-only JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as getter-only properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>The read-only view cannot modify the original JSON value but, unless <paramref name=\"value\"/> is itself read-only, any changes to the original will be reflected in the view.</para>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly(json);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue; // ERROR: will not compile (there is no setter defined for this member)");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.XmlComment($"<seealso cref=\"ToMutable({KnownTypeSymbols.JsonValueFullName})\">If you need a writable view</seealso>");
				sb.AppendLine($"public {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({KnownTypeSymbols.JsonValueFullName} value) => {GetLocalReadOnlyProxyRef(typeDef)}.Create({KnownTypeSymbols.ObservableJsonValueFullName}.Untracked(value), Default);");
				sb.NewLine();

				// ToReadOnly(IObservableJsonContext, JsonValue)
				sb.XmlComment($"<summary>Returns a read-only JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as getter-only properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>The read-only view cannot modify the original JSON value but, unless <paramref name=\"value\"/> is itself read-only, any changes to the original will be reflected in the view.</para>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly(json);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue; // ERROR: will not compile (there is no setter defined for this member)");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.XmlComment($"<seealso cref=\"ToMutable({KnownTypeSymbols.JsonValueFullName})\">If you need a writable view</seealso>");
				sb.AppendLine($"public {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({KnownTypeSymbols.IObservableJsonContextFullName} ctx, {KnownTypeSymbols.JsonValueFullName} value) => {GetLocalReadOnlyProxyRef(typeDef)}.Create({KnownTypeSymbols.ObservableJsonValueFullName}.Tracked(ctx, value), this);");
				sb.NewLine();

				// ToReadOnly(TValue)
				sb.XmlComment($"<summary>Converts an instance of type <see cref=\"{typeCref}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeCref}\"/> as getter-only properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly(instance);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName};");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = /* ... */; // ERROR: will not compile (there is no setter defined for this member)");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.AppendLine($"public {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalReadOnlyProxyRef(typeDef)}.Create(instance);");
				sb.NewLine();

				// ToReadOnly(IObservableJsonContext, TValue)
				sb.XmlComment($"<summary>Converts an instance of type <see cref=\"{typeCref}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeCref}\"/> as getter-only properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly(instance);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName};");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = /* ... */; // ERROR: will not compile (there is no setter defined for this member)");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.AppendLine($"public {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({KnownTypeSymbols.IObservableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalReadOnlyProxyRef(typeDef)}.Create(ctx, instance);");
				sb.NewLine();

				// ToMutable(MutableJsonValue)
				sb.XmlComment($"<summary>Returns a writable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalWritableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.XmlComment($"<para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(json);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue; // changes the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.XmlComment($"<seealso cref=\"ToReadOnly({KnownTypeSymbols.JsonValueFullName})\">If you need a read-only view</seealso>");
				sb.AppendLine($"public {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.MutableJsonValueFullName} value) => {GetLocalWritableProxyRef(typeDef)}.Create(value, converter: this);");
				sb.NewLine();

				// ToMutable(JsonValue)
				sb.XmlComment($"<summary>Returns a writable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalWritableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.XmlComment($"<para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(json);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue; // changes the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.XmlComment($"<seealso cref=\"ToReadOnly({KnownTypeSymbols.JsonValueFullName})\">If you need a read-only view</seealso>");
				sb.AppendLine($"public {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.JsonValueFullName} value) => {GetLocalWritableProxyRef(typeDef)}.Create({KnownTypeSymbols.MutableJsonValueFullName}.Untracked(value), converter: this);");
				sb.NewLine();

				// ToMutable(IMutableJsonContext, JsonValue)
				sb.XmlComment($"<summary>Returns a writable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalWritableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.XmlComment($"<para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(json);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue; // changes the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.XmlComment($"<seealso cref=\"ToReadOnly({KnownTypeSymbols.JsonValueFullName})\">If you need a read-only view</seealso>");
				sb.AppendLine($"public {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {KnownTypeSymbols.JsonValueFullName} value) => {GetLocalWritableProxyRef(typeDef)}.Create({KnownTypeSymbols.MutableJsonValueFullName}.Tracked(ctx, value), converter: this);");
				sb.NewLine();

				// ToMutable(TValue)
				sb.XmlComment($"<summary>Converts an instance of type <see cref=\"{typeCref}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>\r\n");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(instance);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName};");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue;");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.AppendLine($"public {GetLocalWritableProxyRef(typeDef)} ToMutable({typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalWritableProxyRef(typeDef)}.Create(instance);");
				sb.NewLine();

				// ToMutable(IMutableJsonContext, TValue)
				sb.XmlComment($"<summary>Converts an instance of type <see cref=\"{typeCref}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.XmlComment($"<returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>\r\n");
				sb.XmlComment("<remarks>");
				sb.XmlComment("<para>How to use:<code>");
				sb.XmlComment($"var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.XmlComment("// ...");
				sb.XmlComment($"var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(instance);");
				sb.XmlComment($"var value = proxy.{typeDef.Members[0].MemberName};");
				sb.XmlComment($"proxy.{typeDef.Members[0].MemberName} = newValue;");
				sb.XmlComment("</code></para>");
				sb.XmlComment("</remarks>");
				sb.AppendLine($"public {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalWritableProxyRef(typeDef)}.Create(ctx, instance);");
				sb.NewLine();
			}

			private void WriteTypeDefinitionHelpers(CSharpCodeBuilder sb, CrystalJsonTypeMetadata typeDef)
			{
				// GetTypeDefinition()
				sb.XmlComment("<summary>Returns the definition for this type</summary>");
				sb.AppendLine($"public {KnownTypeSymbols.CrystalJsonTypeDefinitionFullName} GetDefinition() => m_typeDefinition ??= CreateDefinition();");
				sb.NewLine();
				sb.AppendLine($"private {KnownTypeSymbols.CrystalJsonTypeDefinitionFullName}? m_typeDefinition;");
				sb.NewLine();
				sb.XmlComment("<summary>Returns the definition for this type</summary>");
				sb.AppendLine($"private static {KnownTypeSymbols.CrystalJsonTypeDefinitionFullName} CreateDefinition()");
				sb.EnterBlock();

				sb.BeginRegion("Members...");
				sb.AppendLine($"{KnownTypeSymbols.CrystalJsonMemberDefinitionFullName}[] members =");
				sb.EnterCollection();
				List<string> flags = [ ];
				foreach (var member in typeDef.Members)
				{
					// construct the member's flags
					flags.Clear();
					flags.Add(KnownTypeSymbols.CrystalJsonMemberFlagsFullName + ".SourceGenerated");
					if (member.IsNotNull) flags.Add(KnownTypeSymbols.CrystalJsonMemberFlagsFullName + ".NotNull");
					if (member.HasNonZeroDefault) flags.Add(KnownTypeSymbols.CrystalJsonMemberFlagsFullName + ".NonZeroDefault");
					if (member.IsReadOnly) flags.Add(KnownTypeSymbols.CrystalJsonMemberFlagsFullName + ".ReadOnly");
					if (member.IsInitOnly) flags.Add(KnownTypeSymbols.CrystalJsonMemberFlagsFullName + ".InitOnly");
					if (member.IsRequired) flags.Add(KnownTypeSymbols.CrystalJsonMemberFlagsFullName + ".Required");
					if (member.IsKey) flags.Add(KnownTypeSymbols.CrystalJsonMemberFlagsFullName + ".Key");

					sb.AppendLine("new()");
					sb.EnterBlock(comment: member.MemberName);
					sb.AppendLine($"Type = typeof({member.Type.FullyQualifiedName}),");
					sb.AppendLine($"Flags = {string.Join(" | ", flags)},");
					sb.AppendLine($"Name = {GetLocalPropertyNameRef(member)},");
					sb.AppendLine($"OriginalName = nameof({typeDef.Type.FullyQualifiedName}.{member.MemberName}),");
					sb.AppendLine($"EncodedName = {GetPropertyEncodedNameRef(member)},");
					if (member.Type.NullableOfType != null) sb.AppendLine($"NullableOfType = typeof({member.Type.NullableOfType.FullyQualifiedName}),");
					if (member.DefaultLiteral is "default")
					{
						sb.AppendLine($"DefaultValue = default({member.Type.FullyQualifiedNameAnnotated}),");
					}
					else
					{
						sb.AppendLine($"DefaultValue = {member.DefaultLiteral},");
					}
					//TODO: Attributes? is it needed?
					sb.AppendLine($"Getter = (instance) => (({typeDef.Type.FullyQualifiedName}) instance).{member.MemberName},");
					if (!member.IsReadOnly && !member.IsInitOnly)
					{
						if (member.Type.IsValueType())
						{ // struct that _could_ be null
							sb.AppendLine($"Setter = (instance, value) => (({typeDef.Type.FullyQualifiedName}) instance).{member.MemberName} = value is not null ? ({member.Type.FullyQualifiedName}) value : {member.DefaultLiteral} /* value-type */,");
						}
						else if (member.HasNonZeroDefault)
						{ // a ref type _could_ be null, but the setter does not allow it...
							sb.AppendLine($"Setter = (instance, value) => (({typeDef.Type.FullyQualifiedName}) instance).{member.MemberName} = value is not null ? ({member.Type.FullyQualifiedName}) value : {member.DefaultLiteral} /* has-default-value */,");
						}
						else if (member.IsNotNull && member.Type.IsEnumerable(out _))
						{ // not-null collection type without a default value, we will inject a default empty collection expression
							sb.AppendLine($"Setter = (instance, value) => (({typeDef.Type.FullyQualifiedName}) instance).{member.MemberName} = value is not null ? ({member.Type.FullyQualifiedName}) value : [ ] /* not-null-collection */,");
						}
						else
						{
							sb.AppendLine($"Setter = (instance, value) => (({typeDef.Type.FullyQualifiedName}) instance).{member.MemberName} = ({member.Type.FullyQualifiedNameAnnotated}) value /* fallback */,");
						}
					}

					// if we are deserializing a (non-nullable) ValueType, the "instance" arg could still be null!
					// => it will call the Nullable<T> variant of Default.Serialize(...) which should be generated automatically
					sb.AppendLine($"Visitor = (instance, declaredType, runtimeType, writer) => Default.Serialize(writer, ({typeDef.Type.FullyQualifiedName}?) instance),");

					if (IsLocallyGeneratedType(member.Type, out var target, out _))
					{
						sb.AppendLine($"Binder = (instance, type, resolver) => instance is not null ? {GetLocalSerializerRef(target)}.Unpack(instance, resolver) : {KnownTypeSymbols.JsonNullFullName}.Null,");
					}
					else if (member.Type.SpecialType == SpecialType.System_String)
					{
						sb.AppendLine("Binder = (instance, type, resolver) => instance?.ToStringOrDefault(),");
					}
					else if (member.Type.SpecialType == SpecialType.System_Boolean)
					{
						sb.AppendLine("Binder = (instance, type, resolver) => instance?.ToBooleanOrDefault(),");
					}
					else if (member.Type.SpecialType == SpecialType.System_Int32)
					{
						sb.AppendLine("Binder = (instance, type, resolver) => instance?.ToInt32OrDefault(),");
					}
					else if (member.Type.SpecialType == SpecialType.System_Int64)
					{
						sb.AppendLine("Binder = (instance, type, resolver) => instance?.ToInt64OrDefault(),");
					}
					else if (member.Type.IsGuid())
					{
						sb.AppendLine("Binder = (instance, type, resolver) => instance?.ToGuidOrDefault(),");
					}
					else if (member.Type.IsDateTime())
					{
						sb.AppendLine("Binder = (instance, type, resolver) => instance?.ToDateTimeOrDefault(),");
					}
					else if (member.Type.IsDateTimeOffset())
					{
						sb.AppendLine("Binder = (instance, type, resolver) => instance?.ToDateTimeOffsetOrDefault(),");
					}
					else
					{
						sb.AppendLine($"Binder = (instance, type, resolver) => (instance ?? {KnownTypeSymbols.JsonNullFullName}.Missing).Bind(type, resolver),");
					}
					sb.LeaveBlock(suffix: ',');
				}
				sb.LeaveCollection(suffix: ';');
				sb.EndRegion();

				sb.AppendLine($"{KnownTypeSymbols.CrystalJsonTypeVisitorFullName} visitor = (({KnownTypeSymbols.IJsonConverterInterfaceFullName}) {GetLocalSerializerRef(typeDef)}).Serialize;");

				sb.AppendLine($"{KnownTypeSymbols.CrystalJsonTypeBinderFullName} binder = (instance, type, resolver) => instance is not null ? Default.Unpack(instance, resolver) : {KnownTypeSymbols.JsonNullFullName}.Null;");
				if (typeDef.IsPolymorphic)
				{
					sb.AppendLine($"var map = new Dictionary<JsonValue, Type>({KnownTypeSymbols.JsonValueComparerFullName}.Default);");
					foreach (var x in typeDef.DerivedTypes)
					{
						if (x.Discriminator is not null)
						{
							sb.AppendLine($"map[{ConvertDiscriminatorValueToJsonLiteral(x.Discriminator)}] = typeof({x.Type.FullyQualifiedName});");
						}
					}
					var discriminatorPropertyName = $"new({CSharpCodeBuilder.Constant(typeDef.TypeDiscriminatorPropertyName ?? "$type")})";
					sb.AppendLine($"return new(typeof({typeDef.Type.FullyQualifiedName}), {KnownTypeSymbols.CrystalJsonTypeFlagsFullName}.SourceGenerated, binder, null, members, visitor, null, {discriminatorPropertyName}, null, map);");
				}
				else if (this.PolymorphicMap.TryGetValue(typeDef.Type.Ref, out var polymorphicMetadata))
				{
					var discriminatorPropertyName = $"new({CSharpCodeBuilder.Constant(polymorphicMetadata.Parent.TypeDiscriminatorPropertyName ?? "$type")})";
					var discriminatorValue = ConvertDiscriminatorValueToJsonLiteral(polymorphicMetadata.Discriminator);
					sb.AppendLine($"return new(typeof({typeDef.Type.FullyQualifiedName}), {KnownTypeSymbols.CrystalJsonTypeFlagsFullName}.SourceGenerated, binder, null, members, visitor, null, {discriminatorPropertyName}, {discriminatorValue}, null);");
				}
				else
				{
					sb.AppendLine($"return new(typeof({typeDef.Type.FullyQualifiedName}), {KnownTypeSymbols.CrystalJsonTypeFlagsFullName}.SourceGenerated, binder, null, members, visitor, null, null, null, null);");
				}
				sb.LeaveBlock();
				sb.NewLine();

			}

			private void WriteUnpackMethod(CSharpCodeBuilder sb, CrystalJsonTypeMetadata typeDef, string typeCref)
			{
				sb.InheritDoc();
				sb.AppendLine($"object? {KnownTypeSymbols.IJsonConverterInterfaceFullName}.BindJsonValue({KnownTypeSymbols.JsonValueFullName} value, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver) => Unpack(value, default);");
				sb.NewLine();

				sb.XmlComment($"<summary>Deserializes a JSON value into an instance of type <see cref=\"{typeCref}\" /></summary>");
				sb.AppendLine($"public {typeDef.Type.FullyQualifiedName} Unpack({KnownTypeSymbols.JsonValueFullName} value, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default)");
				sb.EnterBlock();

				if (typeDef.IsPolymorphic)
				{ // this is a polymorphic type, we have to dispatch to the corresponding derived type converter!

					// get the type discriminator
					sb.AppendLine($"var discriminator = value[{CSharpCodeBuilder.Constant(typeDef.TypeDiscriminatorPropertyName ?? "$type")}];");
					foreach (var (_, derivedType, discriminator) in typeDef.DerivedTypes)
					{
						if (derivedType.IsAbstract)
						{ // don't include intermediary abstract types, we will only process the concrete types (the ones that we can actually create a runtime)
							continue;
						}
						switch (discriminator)
						{
							case null:
							{
								//REVIEW: how do we handle this case?
								break;
							}
							case string s:
							{
								sb.AppendLine($"if (discriminator.ValueEquals({CSharpCodeBuilder.Constant(s)})) return {GetLocalSerializerRef(derivedType)}.Unpack(value, resolver);");
								break;
							}
							case int n:
							{
								sb.AppendLine($"if (discriminator.ValueEquals({CSharpCodeBuilder.Constant(n)})) return {GetLocalSerializerRef(derivedType)}.Unpack(value, resolver);");
								break;
							}
							default:
							{
								sb.AppendLine($"#error Invalid discriminator value type for derived type {derivedType.Name} of parent type {typeDef.Name}");
								break;
							}
						}
					}

					sb.AppendLine($"throw {KnownTypeSymbols.JsonBindingExceptionFullName}.CannotDeserializeCustomTypeWithUnknownTypeDiscriminator(value, typeof({typeDef.Type.FullyQualifiedName}), discriminator);");
					sb.LeaveBlock();
					sb.NewLine();
					return;
				}

				bool hasPolymorphicDefinition = this.PolymorphicMap.TryGetValue(typeDef.Type.Ref, out var polymorphicMetadata);
				if (!typeDef.Type.IsSealed)
				{ // do we have a parent ?
					if (hasPolymorphicDefinition)
					{ // defer to the parent type which should have all the derived types under this one
						//PERF: we _could_ optimize by having a smaller switch with only de types under us?
						sb.AppendLine($"return ({typeDef.Type.FullyQualifiedName}) {GetLocalSerializerRef(polymorphicMetadata.Parent)}.Unpack(value, resolver);");
						sb.LeaveBlock();
						sb.NewLine();
						return;
					}
				}

				sb.AppendLine("var obj = value.AsObject();");

				//BUGBUG: we need to check that, if there is a $type, it matches with the expected value ?

				sb.AppendLine("return new ()");
				sb.EnterBlock();
				foreach (var member in typeDef.Members)
				{
					bool isNullableOfType = member.Type.IsNullableOfT(out var underlyingType);

					if (IsLocallyGeneratedType(member.Type, out var target, out var isNullableOfT))
					{
						if (member.IsRequired)
						{
							// REVIEW: what if isNullableOfT is true ? this is a bit weird to have nullable value type that is also required??
							sb.AppendLine($"{member.MemberName} = /* local-required */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.UnpackRequired<{member.Type.FullyQualifiedName}>({GetLocalSerializerRef(target)}, obj[{GetLocalPropertyNameRef(member)}], resolver, obj, {CSharpCodeBuilder.Constant(member.MemberName)}),");
						}
						else if (isNullableOfT)
						{
							sb.AppendLine($"{member.MemberName} = /* local-optional-nullable */ {GetLocalSerializerRef(target)}.UnpackNullable(obj[{GetLocalPropertyNameRef(member)}], resolver),");
						}
						else
						{
							sb.AppendLine($"{member.MemberName} = /* local-optional */ {GetLocalSerializerRef(target)}.Unpack(obj[{GetLocalPropertyNameRef(member)}], resolver),");
						}
						continue;
					}

					if (member.Type.IsJsonDeserializable)
					{
						if (member.IsRequired)
						{
							sb.AppendLine($"{member.MemberName} = /* deserializable-required */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.UnpackRequiredJsonDeserializable<{member.Type.FullyQualifiedName}>(obj[{GetLocalPropertyNameRef(member)}], resolver, obj, {CSharpCodeBuilder.Constant(member.MemberName)}),");
						}
						else
						{
							sb.AppendLine($"{member.MemberName} = /* deserializable-optional */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.UnpackJsonDeserializable<{member.Type.FullyQualifiedNameAnnotated}>.Unpack(obj[{GetLocalPropertyNameRef(member)}], resolver),");
						}
						continue;
					}

					if (member.Type.IsPrimitive)
					{
						if (member.IsRequired)
						{
							sb.AppendLine($"{member.MemberName} = /* fast-required */ obj.Get<{member.Type.FullyQualifiedName}>({GetLocalPropertyNameRef(member)}),");
						}
						else
						{
							sb.AppendLine($"{member.MemberName} = /* fast-optional */ obj.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetLocalPropertyNameRef(member)}, {member.DefaultLiteral}),");
						}
						continue;
					}

					if (member.Type.IsEnumerable(out var elemType))
					{
						// note: we have to also know the target enumerable type: array? list? other?

						string sequenceShape = member.Type.IsArray() ? "Array" : member.Type.IsList() ? "List" : member.Type.IsEnumerableInterface(out _) ? "Enumerable" : "Unknown"; //TODO: support more ?
						if (sequenceShape != "Unknown")
						{
							if (IsLocallyGeneratedType(elemType, out target, out isNullableOfT))
							{
								if (member.IsRequired)
								{
									// REVIEW: what if isNullableOfT is true ? this is a bit weird to have nullable value type that is also required??
									sb.AppendLine($"{member.MemberName} = /* local-required-{sequenceShape} */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.UnpackRequired{sequenceShape}({GetLocalSerializerRef(target)}, obj[{GetLocalPropertyNameRef(member)}], resolver, obj, {CSharpCodeBuilder.Constant(member.MemberName)})!,");
								}
								else if (isNullableOfT)
								{
									sb.AppendLine($"{member.MemberName} = /* local-optional-nullable-{sequenceShape} */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.UnpackNullable{sequenceShape}({GetLocalSerializerRef(target)}, obj[{GetLocalPropertyNameRef(member)}], {member.DefaultLiteral}, resolver)!,");
								}
								else
								{
									sb.AppendLine($"{member.MemberName} = /* local-optional-{sequenceShape} */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.Unpack{sequenceShape}({GetLocalSerializerRef(target)}, obj[{GetLocalPropertyNameRef(member)}], {member.DefaultLiteral}, resolver)!,");
								}
								continue;
							}

							string elemShape = elemType.SpecialType switch
							{
								SpecialType.System_String => "String",
								SpecialType.System_Int32 => "Int32",
								SpecialType.System_Int64 => "Int64",
								SpecialType.System_Double => "Double",
								_ => "Unknown"
							};
							if (elemShape != "Unknown")
							{
								if (member.IsRequired)
								{
									sb.AppendLine($"{member.MemberName} = /* string-required-{sequenceShape} */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.UnpackRequired{elemShape}{sequenceShape}(obj[{GetLocalPropertyNameRef(member)}], obj, {CSharpCodeBuilder.Constant(member.MemberName)})!,");
								}
								else
								{
									sb.AppendLine($"{member.MemberName} = /* string-optional-{sequenceShape} */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.Unpack{elemShape}{sequenceShape}(obj[{GetLocalPropertyNameRef(member)}], {member.DefaultLiteral})!,");
								}
								continue;
							}

							//TODO: support for Int32, Int64, Guid, etc...? (including their nullable variants)

							if (member.IsRequired)
							{
								sb.AppendLine($"{member.MemberName} = /* fallback-required-{sequenceShape} */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.UnpackRequired{sequenceShape}<{elemType.FullyQualifiedName}>(obj[{GetLocalPropertyNameRef(member)}], resolver, obj, {CSharpCodeBuilder.Constant(member.MemberName)})!,");
							}
							else
							{
								sb.AppendLine($"{member.MemberName} = /* fallback-optional-{sequenceShape} */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.Unpack{sequenceShape}<{elemType.FullyQualifiedName}>(obj[{GetLocalPropertyNameRef(member)}], {member.DefaultLiteral}, resolver)!,");
							}
							continue;
						}
					}

					string jsonExpr;
					if (member.Type.JsonType is JsonPrimitiveType.Object)
					{
						jsonExpr = $"/* json-object */ obj.{(member.IsRequired ? "GetObject" : "GetObjectOrDefault")}({GetLocalPropertyNameRef(member)})";
					}
					else if (member.Type.JsonType is JsonPrimitiveType.Array)
					{
						jsonExpr = $"/* json-array */ obj.{(member.IsRequired ? "GetArray" : "GetArrayOrDefault")}({GetLocalPropertyNameRef(member)})";
					}
					else if (member.IsRequired)
					{
						jsonExpr = $"/* required */ obj.GetValue({GetLocalPropertyNameRef(member)})";
					}
					else
					{
						jsonExpr = $"/* ref-nullable */ obj.GetValueOrDefault({GetLocalPropertyNameRef(member)})";
					}

					string getterExpr;
					if (member.Type.JsonType is not JsonPrimitiveType.None)
					{
						getterExpr = member.Type.JsonType switch
						{
							JsonPrimitiveType.Value or JsonPrimitiveType.Object or JsonPrimitiveType.Array => jsonExpr,
							_ => $"((Json{member.Type.JsonType}) {jsonExpr})" //TODO: we don't have specialized "As" methods for them!
						};
					}
					else if (member.IsRequired)
					{
						getterExpr = $"{jsonExpr}.As<{member.Type.FullyQualifiedName}>({member.DefaultLiteral})!";
					}
					else
					{
						getterExpr = $"{jsonExpr}.As<{member.Type.FullyQualifiedNameAnnotated}>({member.DefaultLiteral})";
					}

					sb.AppendLine($"{member.MemberName} = {getterExpr},");

				}
				sb.LeaveBlock(suffix: ';');
				sb.LeaveBlock();
				sb.NewLine();
			}

			private void WritePackMethod(CSharpCodeBuilder sb, CrystalJsonTypeMetadata typeDef)
			{
				if (typeDef.Type.IsValueType())
				{
					sb.XmlComment($"<summary>Converts an instance of this type into the equivalent <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/></summary>");
					sb.AppendLine($"public {KnownTypeSymbols.JsonValueFullName} Pack({typeDef.Type.FullyQualifiedName}? instance, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default)");
					sb.EnterBlock();
					sb.AppendLine("if (instance is null)");
					sb.EnterBlock();
					sb.AppendLine($"return {KnownTypeSymbols.JsonNullFullName}.Null;");
					sb.LeaveBlock();
					sb.AppendLine("return Pack(instance.Value, settings, resolver);");
					sb.LeaveBlock();
					sb.NewLine();
				}

				sb.InheritDoc();
				sb.AppendLine($"public {KnownTypeSymbols.JsonValueFullName} Pack({typeDef.Type.FullyQualifiedName}{(!typeDef.Type.IsValueType() ? "?" : "")} instance, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default)");
				sb.EnterBlock("Pack");

				if (!typeDef.Type.IsValueType())
				{ // ref types can be null, we will return JsonNull.Null in this case
					sb.AppendLine("if (instance is null)");
					sb.EnterBlock();
					sb.AppendLine($"return {KnownTypeSymbols.JsonNullFullName}.Null;");
					sb.LeaveBlock();
					sb.NewLine();
				}

				// if the type is polymorphic, we have to dispatch to the corresponding serializer
				if (typeDef.IsPolymorphic)
				{
					sb.AppendLine("switch(instance)");
					sb.EnterBlock();
					foreach (var (_, derivedType, _) in typeDef.DerivedTypes)
					{
						if (derivedType.IsAbstract) continue; // skip abstract types
						//BUGBUG: TODO: we may need to sort the types from most specific to less specific, ex: "case Greyhound" then "case Dog", otherwise "case Dog" would match all Greyhound instances if evaluated first!
						//note: if we compute the "depth" of each type (from the top most abstract class or interface), we could simply sort them from highest to lowest!
						sb.AppendLine($"case {derivedType.FullyQualifiedName} x: return {GetLocalSerializerRef(derivedType)}.Pack(x, settings, resolver);");
					}
					sb.AppendLine($"default: throw {KnownTypeSymbols.JsonSerializationExceptionFullName}.CannotPackDerivedTypeWithUnknownTypeDiscriminator(instance.GetType(), typeof({typeDef.Type.FullyQualifiedName}));");
					sb.LeaveBlock();

					sb.LeaveBlock("Pack");
					sb.NewLine();
					return;
				}

				bool hasPolymorphicDefinition = this.PolymorphicMap.TryGetValue(typeDef.Type.Ref, out var polymorphicMetadata);

				if (typeDef.Type.IsAbstract)
				{ // do we have a parent ?
					if (hasPolymorphicDefinition)
					{ // defer to the parent type which should have all the derived types under this one
						//PERF: we _could_ optimize by having a smaller switch with only de types under us?
						sb.AppendLine($"return {GetLocalSerializerRef(polymorphicMetadata.Parent)}.Pack(instance, settings, resolver);");
						sb.LeaveBlock("Pack");
						sb.NewLine();
						return;
					}
				}

				// if the type is not sealed, we may have a derived type, we must defer serialization to this type!
				if (!typeDef.Type.IsSealed)
				{
					//BUGBUG: detect if we have a generated serialize for this derived type?
					sb.AppendLine($"if (instance.GetType() != typeof({typeDef.Type.FullyQualifiedName}))");
					sb.EnterBlock();
					sb.AppendLine($"throw {KnownTypeSymbols.JsonSerializationExceptionFullName}.CannotPackDerivedTypeWithUnknownTypeDiscriminator(instance.GetType(), typeof({typeDef.Type.FullyQualifiedName}));");
					sb.LeaveBlock("Pack");
					sb.NewLine();
				}

				sb.AppendLine($"var obj = new {KnownTypeSymbols.JsonObjectFullName}({typeDef.Members.Count});");
				sb.NewLine();

				if (hasPolymorphicDefinition)
				{
					sb.Comment("Add the discriminator property for this derived type");
					var typeDiscriminatorPropertyName = polymorphicMetadata.Parent.TypeDiscriminatorPropertyName ?? "$type";
					if (polymorphicMetadata.Discriminator is string s)
					{
						sb.AppendLine($"obj[{CSharpCodeBuilder.Constant(typeDiscriminatorPropertyName)}] = {CSharpCodeBuilder.Constant(s)};"); //TODO: create a static readonly for the JsonString!
					}
					else if (polymorphicMetadata.Discriminator is int n)
					{
						sb.AppendLine($"obj[{typeDiscriminatorPropertyName}] = {CSharpCodeBuilder.Constant(n)};"); //TODO: create a static readonly for the JsonNumber!
					}
					else if (polymorphicMetadata.Discriminator is null)
					{
						sb.AppendLine($"#error You must specify a valid type discriminator for derived type {typeDef.Name} of parent type {polymorphicMetadata.Parent.Name}");
					}
					else
					{
						sb.AppendLine($"#error Invalid discriminator value type for derived type {typeDef.Name} of parent type {polymorphicMetadata.Parent.Name}");
					}
					sb.NewLine();
				}

				foreach (var member in typeDef.Members)
				{
					sb.Comment($"\"{member.Name}\" => {member.Type.FullName}{(member.IsNullableRefType() ? "?" : "")} {member.MemberName}{(member.IsKey ? ", KEY" : "")}{(member.IsField ? ", field" : ", prop")}{(member.IsRequired ? ", required" : "")}{(member.IsInitOnly ? ", initOnly" : member.IsReadOnly ? ", readOnly" : "")}");

					var getterExpr = $"instance.{member.MemberName}"; //TODO: maybe use unsafe accessors for some fields?
					var packerExpr = GetMemberPackerExpression(member, getterExpr);

					if (member.Type.IsNullableOfT())
					{
						sb.AppendLine($"obj.AddIfNotNull({GetLocalPropertyNameRef(member)}, {packerExpr});");
					}
					else if (member.IsNotNull)
					{
						sb.AppendLine($"obj.Add({GetLocalPropertyNameRef(member)}, {packerExpr});");
					}
					else
					{
						sb.AppendLine($"obj.AddIfNotNull({GetLocalPropertyNameRef(member)}, {packerExpr});");
					}
					sb.NewLine();
				}
				sb.AppendLine($"return settings.IsReadOnly() ? {KnownTypeSymbols.CrystalJsonMarshallFullName}.FreezeTopLevel(obj) : obj;");
				sb.LeaveBlock("Pack");
				sb.NewLine();
			}

			private void WriteSerializeMethod(CSharpCodeBuilder sb, CrystalJsonTypeMetadata typeDef, string typeCref)
			{
				sb.InheritDoc();
				sb.AppendLine($"void IJsonConverter.Serialize(object? instance, Type declaringType, Type? runtimeType, {KnownTypeSymbols.CrystalJsonWriterFullName} writer)");
				sb.EnterBlock();
				if (typeDef.Type.IsValueType())
				{ // null cannot be cast into a value type, handle this specifically here
					sb.AppendLine("if (instance is null)");
					sb.EnterBlock();
					sb.AppendLine("writer.WriteNull();");
					sb.AppendLine("return;");
					sb.LeaveBlock();
				}
				// check that we have a compatible type
				sb.AppendLine($"if (instance is not {typeDef.Type.FullyQualifiedName} value)");
				sb.EnterBlock();
				sb.AppendLine("throw CrystalJson.Errors.Serialization_DoesNotKnowHowToSerializeType(runtimeType ?? declaringType);");
				sb.LeaveBlock();
				sb.AppendLine("Serialize(writer, value);");
				sb.LeaveBlock();
				sb.NewLine();

				if (typeDef.Type.IsValueType())
				{
					sb.XmlComment("/// <summary>Writes a JSON representation of a nullable value to the specified output</summary>");
					sb.AppendLine($"public void Serialize({KnownTypeSymbols.CrystalJsonWriterFullName} writer, {typeDef.Type.FullyQualifiedName}? instance)");
					sb.EnterBlock();
					sb.AppendLine("if (instance is null)");
					sb.EnterBlock();
					sb.AppendLine("writer.WriteNull();");
					sb.AppendLine("return;");
					sb.LeaveBlock();
					sb.AppendLine("Serialize(writer, instance.Value);");
					sb.LeaveBlock();
					sb.NewLine();
				}

				sb.InheritDoc();
				sb.AppendLine($"public void Serialize({KnownTypeSymbols.CrystalJsonWriterFullName} writer, {typeDef.Type.FullyQualifiedName}{(typeDef.Type.IsValueType() ? "" : "?")} instance)");
				sb.EnterBlock("Serialize()");

				if (!typeDef.Type.IsValueType())
				{ // ref types can be null, we will write "null" in this case
					sb.AppendLine("if (instance is null)");
					sb.EnterBlock();
					sb.AppendLine("writer.WriteNull();");
					sb.AppendLine("return;");
					sb.LeaveBlock();
				}

				//TODO: handle IJsonSerializer<T> and IJsonSerializable

				// if the type is polymorphic, we have to dispatch to the corresponding serializer
				if (typeDef.IsPolymorphic)
				{
					sb.AppendLine("switch(instance)");
					sb.EnterBlock();
					foreach (var (_, derivedType, _) in typeDef.DerivedTypes)
					{
						if (derivedType.IsAbstract) continue;
						sb.AppendLine($"case {derivedType.FullyQualifiedName} x: {GetLocalSerializerRef(derivedType)}.Serialize(writer, x); break;");
					}
					sb.AppendLine($"default: throw {KnownTypeSymbols.JsonSerializationExceptionFullName}.CannotSerializeDerivedTypeWithoutTypeDiscriminator(instance.GetType(), typeof({typeDef.Type.FullyQualifiedName}));");
					sb.LeaveBlock();

					sb.LeaveBlock("Serialize()");
					sb.NewLine();
					return;
				}

				bool hasPolymorphicDefinition = this.PolymorphicMap.TryGetValue(typeDef.Type.Ref, out var polymorphicMetadata);

				if (typeDef.Type.IsAbstract)
				{ // do we have a parent ?
					if (hasPolymorphicDefinition)
					{ // defer to the parent type which should have all the derived types under this one
						//REVIEW: TODO: we _could_ optimize by having a smaller switch with only de types under us?
						sb.AppendLine($"{GetLocalSerializerRef(polymorphicMetadata.Parent)}.Serialize(writer, instance);");
						sb.LeaveBlock("Serialize()");
						sb.NewLine();
						return;
					}
				}

				// if the type is not sealed, we may have a derived type, we must defer serialization to this type!
				if (!typeDef.Type.IsSealed)
				{
					//TODO: we should have a local method that can dispatch known types!
					sb.AppendLine($"if (instance.GetType() != typeof({typeDef.Type.FullyQualifiedName}))");
					sb.EnterBlock();
					sb.AppendLine("throw new NotSupportedException(\"Cannot serialize a polymorphic type. You must add at least one [JsonDerivedType] to the base class or interface.\");");
					//sb.AppendLine($"{KnownTypeSymbols.CrystalJsonVisitorFullName}.VisitValue(instance, typeof({typeFullName}), writer);");
					//sb.AppendLine("return;");
					sb.LeaveBlock();
				}

				sb.NewLine();
				sb.AppendLine("var state = writer.BeginObject();");

				if (hasPolymorphicDefinition)
				{
					sb.Comment("Add the discriminator property for this derived type");
					var typeDiscriminatorPropertyName = polymorphicMetadata.Parent.TypeDiscriminatorPropertyName ?? "$type";
					if (polymorphicMetadata.Discriminator is string s)
					{
						sb.AppendLine($"writer.WriteField({CSharpCodeBuilder.Constant(typeDiscriminatorPropertyName)}, {CSharpCodeBuilder.Constant(s)});");
					}
					else if (polymorphicMetadata.Discriminator is int n)
					{
						sb.AppendLine($"writer.WriteField({typeDiscriminatorPropertyName}, {CSharpCodeBuilder.Constant(n)});");
					}
					else
					{
						sb.AppendLine("#error Invalid discriminator value type");
					}
				}

				foreach (var member in typeDef.Members)
				{
					this.WriteMemberSerializer(sb, member);
				}
				sb.NewLine();
				sb.AppendLine("writer.EndObject(state);");
				sb.LeaveBlock("Serialize()");
				sb.NewLine();
			}

			private string GetMemberPackerExpression(CrystalJsonMemberMetadata member, string getterExpr)
			{
				if (IsLocallyGeneratedType(member.Type, out var target, out _))
				{
					return $"/* local-serializer */ {GetLocalSerializerRef(target)}.Pack({getterExpr}, settings, resolver)";
				}

				// unwrap any Nullable<T> (most packing methods handle both!)
				var concreteType = member.Type.NullableOfType ?? member.Type;
				if (concreteType.IsBooleanLike())
				{
					return $"/* fast-boolean */ {KnownTypeSymbols.JsonBooleanFullName}.Return({getterExpr})";
				}
				if (concreteType.IsStringLike())
				{
					return $"/* fast-string */ {KnownTypeSymbols.JsonStringFullName}.Return({getterExpr})";
				}
				if (concreteType.IsNumberLike())
				{
					return $"/* fast-number */ {KnownTypeSymbols.JsonNumberFullName}.Return({getterExpr})";
				}
				if (concreteType.IsDateLike())
				{
					return $"/* fast-date */ {KnownTypeSymbols.JsonDateTimeFullName}.Return({getterExpr})";
				}

				if (member.Type.JsonType is not JsonPrimitiveType.None)
				{
					// it's already a JSON value, but we may need to convert it to readonly!
					return $"/* fast-json */ settings.IsReadOnly() ? ({getterExpr})?.ToReadOnly() : ({getterExpr})";
				}

				if (concreteType.JsonType is not JsonPrimitiveType.None)
				{
					return $"/* direct-json-value */ {getterExpr}";
				}

				if (concreteType.IsJsonPackable)
				{
					return $"/* packable */ {KnownTypeSymbols.JsonValueFullName}.FromValue({getterExpr}, settings, resolver)";
				}

				if (concreteType.IsDictionary(out var keyType, out var valueType))
				{
					if (keyType.IsString())
					{
						if (IsLocallyGeneratedType(valueType, out target, out _))
						{
							return $"/* local-dict */ {GetLocalSerializerRef(target)}.PackObject({getterExpr}, settings, resolver)";
						}
						if (!valueType.IsValueType())
						{
							return $"/* fallback-dict */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.PackEnumerable({getterExpr}, settings, resolver)";
						}
					}
					//else: int? other well known type?
				}
				else if (concreteType.IsEnumerable(out var elemType))
				{
					// if the elem type is a local type, we will use the generated serializer
					if (IsLocallyGeneratedType(elemType, out target, out _))
					{
						if (concreteType.IsArray())
						{
							return $"/* local-pack-array */ {GetLocalSerializerRef(target)}.PackArray({getterExpr}, settings, resolver)";
						}
						if (concreteType.IsList())
						{
							return $"/* local-pack-list */ {GetLocalSerializerRef(target)}.PackList({getterExpr}, settings, resolver)";
						}
						if (!elemType.IsValueType())
						{
							return $"/* local-pack-enumerable */ {GetLocalSerializerRef(target)}.PackEnumerable({getterExpr}, settings, resolver)";
						}
					}
					else if (elemType.IsPrimitive)
					{ // for primitive types, we should have a fast direct implementation
						if (concreteType.IsArray())
						{
							return $"/* fast-pack-array */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.PackArray({getterExpr}, settings, resolver)";
						}
						if (concreteType.IsList())
						{
							return $"/* fast-pack-list */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.PackList({getterExpr}, settings, resolver)";
						}
						if (!concreteType.IsValueType())
						{
							return $"/* fast-pack-enumerable */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.PackEnumerable({getterExpr}, settings, resolver)";
						}
					}
					else
					{ // otherwise, use runtime serialization
						if (concreteType.IsArray())
						{
							return $"/* fallback-pack-array */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.PackArray({getterExpr}, settings, resolver)";
						}
						if (concreteType.IsList())
						{
							return $"/* fallback-pack-list */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.PackList({getterExpr}, settings, resolver)";
						}
						if (!concreteType.IsValueType())
						{
							return $"/* fallback-pack-enumerable */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.PackEnumerable({getterExpr}, settings, resolver)";
						}
					}
				}

				return $"/* fallback */ {KnownTypeSymbols.JsonValueFullName}.FromValue({getterExpr}, settings, resolver)";
			}

			private static string ConvertDiscriminatorValueToJsonLiteral(object? value) => value switch
			{
				string s => $"{KnownTypeSymbols.JsonStringFullName}.Return({CSharpCodeBuilder.Constant(s)})",
				int n => $"{KnownTypeSymbols.JsonNumberFullName}.Return({CSharpCodeBuilder.Constant(n)})",
				_ => "null"
			};

			private static bool IsFastPathSerializable(TypeMetadata type)
			{
				// Note: we assume we always have Nullable<T> variants helpers in the fast path!
				type = type.NullableOfType ?? type;

				switch (type.SpecialType)
				{
					case SpecialType.System_Boolean:
					case SpecialType.System_Char:
					case SpecialType.System_SByte:
					case SpecialType.System_Byte:
					case SpecialType.System_Int16:
					case SpecialType.System_UInt16:
					case SpecialType.System_Int32:
					case SpecialType.System_UInt32:
					case SpecialType.System_Int64:
					case SpecialType.System_UInt64:
					case SpecialType.System_Decimal:
					case SpecialType.System_Single:
					case SpecialType.System_Double:
					case SpecialType.System_String:
					case SpecialType.System_DateTime:
					{
						return true;
					}
				}

				if (type.NameSpace == "System")
				{
					switch (type.Name)
					{
						case nameof(DateTimeOffset):
						case nameof(Guid):
						case "DateOnly":
						case "TimeOnly":
						case "Int128":
						case "UInt128":
						case "Half":
						{
							return true;
						}
					}
				}

				if (type.NameSpace == "NodaTime")
				{
					switch (type.Name)
					{
						case "Instant":
						case "Duration":
						//TODO: add more!
						{
							return true;
						}
					}
				}

				return false;
			}

			/// <summary>Test if a type has some locally generated serialization methods</summary>
			private bool IsLocallyGeneratedType(TypeRef type, [MaybeNullWhen(false)] out CrystalJsonTypeMetadata metadata)
			{
				return this.TypeMap.TryGetValue(type, out metadata);
			}

			/// <summary>Test if a type has some locally generated serialization methods</summary>
			private bool IsLocallyGeneratedType(TypeMetadata type, [MaybeNullWhen(false)] out CrystalJsonTypeMetadata metadata, out bool nullableOfT)
			{
				nullableOfT = type.IsNullableOfT(out var underlyingType);

				return this.IsLocallyGeneratedType((underlyingType ?? type).Ref, out metadata);
			}

			private void WriteMemberSerializer(CSharpCodeBuilder sb, CrystalJsonMemberMetadata member)
			{
				sb.NewLine();
				sb.Comment($"{member.Type.Name} {member.MemberName} => \"{member.Name}\"");

				var propertyName = GetPropertyEncodedNameRef(member);
				var getterExpr = "instance." + member.MemberName;

				if (IsFastPathSerializable(member.Type))
				{
					// there is a dedicated method for this type
					sb.AppendLine($"writer.WriteField({propertyName}, {getterExpr}); // fast-path");
					return;
				}

				if (IsLocallyGeneratedType(member.Type, out var subDef, out _))
				{ // we have a local generated serializer for this!
					sb.AppendLine($"writer.WriteField({propertyName}, {getterExpr}, {this.GetLocalSerializerRef(subDef)}); // local-serializer");
					return;
				}

				if (member.Type.SpecialType == SpecialType.System_Nullable_T)
				{
					sb.AppendLine("// nullable!");
					//TODO?
				}

				//TODO: test if implements IJsonSerializable

				if (member.Type.JsonType is not JsonPrimitiveType.None)
				{ // this is a JsonValue
					sb.AppendLine($"writer.WriteField({propertyName}, {getterExpr}); // fast-json");
					return;
				}

				if (member.Type.IsJsonSerializable)
				{ // the type has its own JsonSerialize method that we will call directly
					sb.AppendLine($"writer.WriteFieldJsonSerializable({propertyName}, {getterExpr}); // json-serializable");
					return;
				}

				if (member.Type.IsDictionary(out var keyType, out var valueType))
				{
					if (keyType.IsString())
					{
						if (IsLocallyGeneratedType(valueType, out subDef, out _))
						{
							sb.AppendLine($"writer.WriteFieldDictionary({propertyName}, {getterExpr}, {GetLocalSerializerRef(subDef)}); // dict-local-serializer");
						}
						else
						{
							sb.AppendLine($"writer.WriteFieldDictionary({propertyName}, {getterExpr}); // dict-fallback");
						}
						return;
					}
				}
				else if (member.Type.IsEnumerable(out var elemType))
				{
					if (IsLocallyGeneratedType(elemType, out subDef, out _))
					{ // we have a local generated serializer for this!
						sb.AppendLine($"writer.WriteFieldArray({propertyName}, {getterExpr}, {this.GetLocalSerializerRef(subDef)}); // enumerable-local-serializer");
						return;
					}

					sb.AppendLine($"writer.WriteFieldArray({propertyName}, {getterExpr}); // enumerable-fallback");
					return;
				}

				// fallback to invoking the generic WriteField<T>(...) method
				sb.AppendLine($"writer.WriteField({propertyName}, {getterExpr}); // fallback");
			}

		}

	}

}


namespace System.Diagnostics.CodeAnalysis
{

#if !NETSTANDARD2_1

	/// <summary>Specifies that when a method returns <see cref="ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
	[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
	internal sealed class MaybeNullWhenAttribute : Attribute
	{
		/// <summary>Initializes the attribute with the specified return value condition.</summary>
		/// <param name="returnValue">
		/// The return value condition. If the method returns this value, the associated parameter may be null.
		/// </param>
		public MaybeNullWhenAttribute(bool returnValue) => ReturnValue = returnValue;

		/// <summary>Gets the return value condition.</summary>
		public bool ReturnValue { get; }
	}

#endif

}
