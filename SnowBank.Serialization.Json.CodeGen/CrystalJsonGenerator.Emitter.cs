#region Copyright (c) 2023-2024 SnowBank SAS, (c) 2005-2023 Doxense SAS
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 	* Redistributions of source code must retain the above copyright
// 	  notice, this list of conditions and the following disclaimer.
// 	* Redistributions in binary form must reproduce the above copyright
// 	  notice, this list of conditions and the following disclaimer in the
// 	  documentation and/or other materials provided with the distribution.
// 	* Neither the name of SnowBank nor the
// 	  names of its contributors may be used to endorse or promote products
// 	  derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL SNOWBANK SAS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#endregion

//#define FULL_DEBUG

namespace SnowBank.Serialization.Json.CodeGen
{
	using System;
	using System.Collections.Generic;
	using Microsoft.CodeAnalysis;
	
	public partial class CrystalJsonSourceGenerator
	{

		[SuppressMessage("ReSharper", "InconsistentNaming")]
		internal sealed class Emitter
		{

			internal const string GeneratedCodeAttributeFullName = "System.CodeDom.Compiler.GeneratedCodeAttribute";

			internal const string DebuggerNonUserCodeAttributeFullName = "System.Diagnostics.DebuggerNonUserCodeAttribute";

			internal const string DynamicallyAccessedMembersAttributeFullName = "System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute";

			internal const string DynamicallyAccessedMemberTypesFullName = "System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes";

			private SourceProductionContext Context { get; }
			
			public CrystalJsonContainerMetadata Metadata { get; }

			private Dictionary<TypeRef, CrystalJsonTypeMetadata> TypeMap { get; }

			public Emitter(SourceProductionContext ctx, CrystalJsonContainerMetadata metadata)
			{
				this.Context = ctx;
				this.Metadata = metadata;

				var map = new Dictionary<TypeRef, CrystalJsonTypeMetadata>();
				foreach (var type in metadata.IncludedTypes)
				{
					map[type.Type.Ref] = type;
				}
				this.TypeMap = map;
			}

			private void AddFileHeaders(CodeBuilder sb)
			{
				sb.Comment("<auto-generated/>");
				sb.NewLine();
				sb.AppendLine("#nullable enable annotations");
				sb.AppendLine("#nullable enable warnings");
				sb.AppendLine("#pragma warning disable CS0612, CS0618");
				sb.NewLine();
			}

			public void GenerateCode()
			{
				this.Context.CancellationToken.ThrowIfCancellationRequested();

				var symbol = this.Metadata.Type;
				var includedTypes = this.Metadata.IncludedTypes;
				
				Kenobi($"Generating container {symbol.Name} with {includedTypes.Count} included types");
				Kenobi($"Name: '{symbol.FullyQualifiedName}'");
				Kenobi($"Types: {includedTypes.Count}");

				// first we generated a "primary" file for the container, that will include any static methods (that are not specific to a type)

				{
					var sb = new CodeBuilder();
					AddFileHeaders(sb);

					sb.AppendLine($"namespace {symbol.NameSpace}");
					sb.EnterBlock("namespace");

					sb.AppendLine("/// <summary>Generated source code for JSON operations on application types</summary>");
					sb.AppendLine($"[{DynamicallyAccessedMembersAttributeFullName}({DynamicallyAccessedMemberTypesFullName}.All)]");
					sb.AppendLine($"[{GeneratedCodeAttributeFullName}(\"{nameof(CrystalJsonSourceGenerator)}\", \"0.1\")]");
					sb.AppendLine($"[{DebuggerNonUserCodeAttributeFullName}]");
					sb.AppendLine($"public static partial class {symbol.Name}");
					sb.EnterBlock("container");
					sb.NewLine();

					//TODO: static code?

					sb.AppendLine($"public static {KnownTypeSymbols.IJsonConverterInterfaceFullName}<T> GetConverterFor<T>()");
					sb.EnterBlock("TryGetConverter");
					foreach (var type in includedTypes)
					{
						sb.AppendLine($"if (typeof(T) == typeof({type.Type.FullyQualifiedName})) return System.Runtime.CompilerServices.Unsafe.As<{KnownTypeSymbols.IJsonConverterInterfaceFullName}<T>>({GetLocalSerializerRef(type)});");
					}
					sb.AppendLine($"return {KnownTypeSymbols.CrystalJsonFullName}.DefaultResolver.GetDefaultConverter<T>();");
					sb.LeaveBlock("TryGetConverter");
					sb.NewLine();

					sb.LeaveBlock("container");
					sb.NewLine();

					sb.LeaveBlock("namespace");
					sb.NewLine();

					this.Context.AddSource($"{this.Metadata.Type.Name}.g.cs", sb.ToString());
				}

				// then, we generate one file for each of the serialized type
				foreach (var typeDef in includedTypes)
				{
					Kenobi($"Generating code for {typeDef.Type.FullyQualifiedName}");
					var sb = new CodeBuilder();
					AddFileHeaders(sb);
#if true || FULL_DEBUG
					{
						sb.Comment("Type Definition:");
						sb.Comment(typeDef.Name + ":");
						var buf = new System.Text.StringBuilder();
						typeDef.Explain(buf, "- ");
						sb.Comment(buf.ToString());
						sb.NewLine();
					}
#endif

					sb.AppendLine($"namespace {symbol.NameSpace}");
					sb.EnterBlock("namespace");

					// we don't want to have to specify the namespace everytime
					sb.AppendLine($"using {KnownTypeSymbols.CrystalJsonNamespace};");
					// we also use a lot of helper static methods from this type
					sb.NewLine();

					sb.AppendLine($"public static partial class {symbol.Name}");
					sb.EnterBlock("Container");

					try
					{
						GenerateCodeForType(sb, typeDef);
					}
					catch (Exception ex)
					{
						//TODO: inject a diagnostic!
						Kenobi("CRASH: failed to generate " + typeDef.Name + ": " + ex.ToString());

						this.Context.AddSource($"{this.Metadata.Type.Name}.{typeDef.Name}.g.cs", sb.ToString());

						sb.Clear();
						sb.NewLine();
						sb.Comment("ERROR: generator failed!");
						sb.Comment(ex.ToString());
						sb.NewLine();
						// note: we need to write _something_ to the file, otherwise we may get errors like "Only one compilation unit can have top-level statements."
						sb.AppendLine($"namespace {symbol.NameSpace}");
						sb.EnterBlock("namespace");

						// we don't want to have to specify the namespace everytime
						sb.AppendLine($"using {KnownTypeSymbols.CrystalJsonNamespace};");
						// we also use a lot of helper static methods from this type
						sb.AppendLine($"using static {KnownTypeSymbols.JsonSerializerExtensionsFullName};");
						sb.NewLine();

						sb.AppendLine($"public static partial class {symbol.Name}");
						sb.EnterBlock("Container");

						sb.AppendLine($"#error Generation failed for {symbol.Name}: {ex.ToString().Replace("\r\n", "  ")}");
						sb.NewLine();
					}

					sb.LeaveBlock("Container");
					sb.NewLine();

					sb.LeaveBlock("namespace");
					sb.NewLine();

					this.Context.AddSource($"{this.Metadata.Type.Name}.{typeDef.Name}.g.cs", sb.ToString());
				}
				Kenobi("Done!");
			}

			private string GetSerializerName(TypeMetadata type) => type.Name;
			private string GetLocalSerializerRef(CrystalJsonTypeMetadata metadata) => $"{this.Metadata.Type.Name}.{GetSerializerName(metadata.Type)}";

			private string GetConverterName(CrystalJsonTypeMetadata metadata) => metadata.Name + "JsonConverter";

			private string GetReadOnlyProxyName(TypeMetadata type) => $"{type.Name}ReadOnly";
			private string GetLocalReadOnlyProxyRef(CrystalJsonTypeMetadata metadata) => $"{this.Metadata.Name}.{GetReadOnlyProxyName(metadata.Type)}";

			private string GetMutableProxyName(TypeMetadata type) => $"{type.Name}Mutable";
			private string GetLocalMutableProxyRef(CrystalJsonTypeMetadata metadata) => $"{this.Metadata.Name}.{GetMutableProxyName(metadata.Type)}";

			private string GetObservableProxyName(TypeMetadata type) => $"{type.Name}Observable";
			private string GetLocalObservableProxyRef(CrystalJsonTypeMetadata metadata) => $"{this.Metadata.Name}.{GetObservableProxyName(metadata.Type)}";

			/// <summary>Returns the name of the generated const string with the serialized name of this member, from within the converter itself</summary>
			private string GetLocalPropertyNameRef(CrystalJsonMemberMetadata member) => "PropertyNames." + member.MemberName;

			/// <summary>Returns the name of the generated const string with the serialized name of this member, from another part of the generated code</summary>
			private string GetTargetPropertyNameRef(CrystalJsonTypeMetadata type, CrystalJsonMemberMetadata member) => GetConverterName(type) + ".PropertyNames." + member.MemberName;

			/// <summary>Returns the name of the generated static singleton with the definition of this member</summary>
			private string GetPropertyEncodedNameRef(CrystalJsonMemberMetadata member) => "PropertyEncodedNames." + member.MemberName;

			private string GetPropertyAccessorName(CrystalJsonMemberMetadata member) => $"{member.MemberName}Accessor";

			/// <summary>Generates all types required to serialize a specific type</summary>
			private void GenerateCodeForType(CodeBuilder sb, CrystalJsonTypeMetadata typeDef)
			{
				var typeName = typeDef.Type.Name;
				var typeFullName = typeDef.Type.FullyQualifiedName;

				// we need to get back the type symbol from the compilation (which we do not store in the metadata, since it changes everytime)

				var serializerName = typeName;
				var serializerTypeName = GetConverterName(typeDef);
				var jsonConverterInterfaceName = $"{KnownTypeSymbols.IJsonConverterInterfaceFullName}<{typeFullName}>";

				var readOnlyProxyTypeName = GetReadOnlyProxyName(typeDef.Type);
				var mutableProxyTypeName = GetMutableProxyName(typeDef.Type);
				var observableProxyTypeName = GetObservableProxyName(typeDef.Type);

				var readOnlyProxyInterfaceName = $"{KnownTypeSymbols.IJsonReadOnlyProxyFullName}<{typeFullName}, {readOnlyProxyTypeName}, {mutableProxyTypeName}>";
				var mutableProxyInterfaceName = $"{KnownTypeSymbols.IJsonMutableProxyFullName}<{typeFullName}, {mutableProxyTypeName}, {readOnlyProxyTypeName}>";
				var observableProxyInterfaceName = $"{KnownTypeSymbols.IJsonObservableProxyFullName}<{typeFullName}, {observableProxyTypeName}>";

#if FULL_DEBUG
				sb.Comment($"Generating for type {typeDef.Type.FullyQualifiedName}");
				foreach (var member in typeDef.Members)
				{
					sb.Comment($"- {member.Name}: {member.ToString()}");
				}
				sb.NewLine();
#endif

				sb.AppendLine($"/// <summary>JSON converter for type <see cref=\"{typeFullName}\">{typeName}</see></summary>");
				sb.AppendLine($"public static {serializerTypeName} {serializerName} => m_cached{serializerName} ??= new();");
				sb.NewLine();
				sb.AppendLine($"private static {serializerTypeName}? m_cached{serializerName};");
				sb.NewLine();

				#region JsonConverter class...

				sb.AppendLine($"public sealed class {serializerTypeName} : {KnownTypeSymbols.IJsonConverterInterfaceFullName}<{typeFullName}, {readOnlyProxyTypeName}, {mutableProxyTypeName}, {observableProxyTypeName}>"); //TODO: implements!
				sb.EnterBlock("JsonConverter:" + typeDef.Name);

				#region Metadata...

				sb.AppendLine("#region Metadata...");
				sb.NewLine();

				sb.AppendLine("/// <summary>Names of all serialized members for this type</summary>");
				sb.AppendLine("public static class PropertyNames");
				sb.EnterBlock("properties");
				sb.NewLine();
				foreach (var member in typeDef.Members)
				{
					sb.AppendLine($"/// <summary>Serialized name of the <see cref=\"{typeName}.{member.MemberName}\"/> {(member.IsField ? "field" : "property")} of the <see cref=\"{typeName}\"/> {(member.Type.IsValueType() ? "struct" : member.Type.IsRecord ? "record" : "class")}</summary>");
					sb.AppendLine($"public const string {member.MemberName} = {sb.Constant(member.Name)};");
					sb.NewLine();
				}

				sb.AppendLine($"public static string[] GetAllNames() => new [] {{ {string.Join(", ", typeDef.Members.Select(m => this.GetLocalPropertyNameRef(m)))} }};"); //TODO: PERF!
				sb.NewLine();

				sb.LeaveBlock("properties");
				sb.NewLine();

				sb.AppendLine("/// <summary>Cached encoded names for all serialized members for this type</summary>");
				sb.AppendLine("public static class PropertyEncodedNames");
				sb.EnterBlock("properties");
				sb.NewLine();
				foreach (var member in typeDef.Members)
				{
					sb.AppendLine($"/// <summary>Encoded name of the <see cref=\"{typeName}.{member.MemberName}\"/> {(member.IsField ? "field" : "property")} of the <see cref=\"{typeName}\"/> {(member.Type.IsValueType() ? "struct" : member.Type.IsRecord ? "record" : "class")}</summary>");
					sb.AppendLine($"public static readonly {KnownTypeSymbols.JsonEncodedPropertyNameFullName} {member.MemberName} = new({GetLocalPropertyNameRef(member)});");
					sb.NewLine();
				}
				sb.LeaveBlock("properties");
				sb.NewLine();

				sb.AppendLine("#endregion");
				sb.NewLine();

				#endregion

				#region Serialize...

				sb.AppendLine($"#region IJsonSerializer<{typeName}>...");
				sb.NewLine();

				WriteSerializeMethod(sb, typeDef, typeFullName);

				sb.AppendLine("#endregion");
				sb.NewLine();

				#endregion

				#region Pack...

				sb.AppendLine($"#region IJsonPacker<{typeName}>...");
				sb.NewLine();

				WritePackMethod(sb, typeDef);

				sb.AppendLine("#endregion");
				sb.NewLine();

				#endregion

				#region UnPack...

				sb.AppendLine($"#region IJsonDeserializer<{typeName}>...");
				sb.NewLine();

				WriteUnpackMethod(sb, typeDef, typeFullName);

				sb.AppendLine("#endregion");
				sb.NewLine();

				#endregion

				#region Proxy...

				sb.AppendLine($"#region Proxy Helpers...");
				sb.NewLine();

				WriteProxyHelpers(sb, typeDef, typeName);

				sb.AppendLine("#endregion");
				sb.NewLine();

				#endregion

				sb.LeaveBlock("JsonConverter:" + typeDef.Name);
				sb.NewLine();

				#endregion

				#region JsonReadOnlyProxy class...

				// IJsonReadOnlyProxy<T>
				sb.AppendLine($"/// <summary>Wraps a <see cref=\"{KnownTypeSymbols.JsonObjectFullName}\"/> into a read-only type-safe view that emulates the type <see cref=\"{typeName}\"/></summary>");
				sb.AppendLine($"/// <seealso cref=\"{KnownTypeSymbols.IJsonReadOnlyProxyFullName}{{T}}\"/>");
				sb.Struct(
					"public readonly record",
					readOnlyProxyTypeName,
					[readOnlyProxyInterfaceName],
					[],
					() =>
					{
						sb.AppendLine($"/// <summary>JSON Object that is wrapped</summary>");
						sb.AppendLine($"private readonly {KnownTypeSymbols.JsonObjectFullName}? m_obj;");
						sb.NewLine();

						// ctor()
						sb.AppendLine($"public {readOnlyProxyTypeName}({KnownTypeSymbols.JsonValueFullName} value) => m_obj = value.AsObjectOrDefault();"); //HACKACK: BUGBUG:
						sb.NewLine();

						#region Methods...

						sb.AppendLine("#region Public Methods...");
						sb.NewLine();

						// static Create()
						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public static {readOnlyProxyTypeName} Create({KnownTypeSymbols.JsonValueFullName} value, {jsonConverterInterfaceName}? converter = null) => new(value.AsObject());");
						sb.NewLine();

						// static Create()
						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public static {readOnlyProxyTypeName} Create({typeDef.Type.FullyQualifiedNameAnnotated} value, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = null, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = null) => new({GetLocalSerializerRef(typeDef)}.Pack(value, settings.AsReadOnly(), resolver));");
						sb.NewLine();

						// static Converter
						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public static {jsonConverterInterfaceName} Converter => {GetLocalSerializerRef(typeDef)};");
						sb.NewLine();

						// bool Exists()
						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public bool Exists() => m_obj != null;");
						sb.NewLine();

						// TValue ToValue()
						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public {typeDef.Type.FullyQualifiedName} ToValue() => {GetLocalSerializerRef(typeDef)}.Unpack(m_obj);"); //TODO: resolver?
						sb.NewLine();

						// JsonObject ToJson()
						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.JsonValueFullName} ToJson() => m_obj ?? JsonNull.Missing;");
						sb.NewLine();

						// TMutable ToMutable()
						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public {mutableProxyTypeName} ToMutable() => new(m_obj.Copy());");
						sb.NewLine();

						// TReadOnly With(Action<TMutable>)
						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public {readOnlyProxyTypeName} With(Action<{mutableProxyTypeName}> modifier)");
						sb.EnterBlock();
						sb.AppendLine($"var copy = m_obj.Copy();");
						sb.AppendLine($"modifier(new(copy));");
						sb.AppendLine($"return new(copy.Freeze());");
						sb.LeaveBlock();
						sb.NewLine();

						// IJsonSerializable
						sb.AppendLine($"void {KnownTypeSymbols.IJsonSerializableFullName}.JsonSerialize({KnownTypeSymbols.CrystalJsonWriterFullName} writer) => m_obj.JsonSerialize(writer);");
						sb.NewLine();

						// IJsonPackable
						sb.AppendLine($"{KnownTypeSymbols.JsonValueFullName} {KnownTypeSymbols.IJsonPackableFullName}.JsonPack({KnownTypeSymbols.CrystalJsonSettingsFullName} settings, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName} resolver) => m_obj;");
						sb.NewLine();

						sb.AppendLine("#endregion");
						sb.NewLine();

						#endregion

						#region Members

						sb.AppendLine("#region Public Members...");
						sb.NewLine();

						foreach (var member in typeDef.Members)
						{
							sb.AppendLine($"/// <inheritdoc cref=\"{typeFullName}.{member.MemberName}\" />");

							//HACKHACK: TODO: BUGBUG: generate the proper literal for the default of the type ("default", "null", "0", "false", ...)

							string? getterExpr = null;
							string proxyType = member.Type.FullyQualifiedNameAnnotated;

							if (IsLocallyGeneratedType(member.Type, out var target))
							{
								getterExpr = $"new(m_obj.{(member.IsNullableRefType() ? "GetObjectOrDefault" : member.IsRequired ? "GetObject" : "GetObjectOrEmpty")}({GetTargetPropertyNameRef(typeDef, member)}))";
								proxyType = GetLocalReadOnlyProxyRef(target);
							}
							else if (member.Type.IsStringLike() || member.Type.IsBooleanLike() || member.Type.IsNumberLike() || member.Type.IsDateLike())
							{
								//use default getter
								getterExpr = null;
							}
							else if (member.Type.JsonType is not JsonPrimitiveType.None)
							{
								getterExpr = member.Type.JsonType switch
								{
									JsonPrimitiveType.Object => $"/* direct-json-object */ m_obj.{(member.IsNullableRefType() ? "GetObjectOrDefault" : member.IsRequired ? "GetObject" : "GetObjectOrEmpty")}({this.GetTargetPropertyNameRef(typeDef, member)})",
									JsonPrimitiveType.Array => $"/* direct-json-array */ m_obj.{(member.IsNullableRefType() ? "GetArrayOrDefault" : member.IsRequired ? "GetArray" : "GetArrayOrEmpty")}({this.GetTargetPropertyNameRef(typeDef, member)})",
									//TODO: JsonString, JsonNumber, ... (are they really used?)
									_ => $"/* direct-json-value */ m_obj[{this.GetTargetPropertyNameRef(typeDef, member)}]"
								};
							}
							else if (member.Type.IsJsonSerializable)
							{
								getterExpr = null; //TODO?
							}
							else if (member.Type.IsDictionary(out var keyType, out var valueType))
							{
								if (keyType.IsString())
								{
									if (IsLocallyGeneratedType(valueType, out target))
									{
										getterExpr = $"new(m_obj.{(member.IsNullableRefType() ? "GetObjectOrDefault" : member.IsRequired ? "GetObject" : "GetObjectOrEmpty")}({GetTargetPropertyNameRef(typeDef, member)}))";
										proxyType = $"{KnownTypeSymbols.JsonReadOnlyProxyObjectFullName}<{valueType.FullyQualifiedName}, {GetLocalReadOnlyProxyRef(target)}>";
									}
									else
									{
										getterExpr = $"new(m_obj.{(member.IsNullableRefType() ? "GetObjectOrDefault" : member.IsRequired ? "GetObject" : "GetObjectOrEmpty")}({GetTargetPropertyNameRef(typeDef, member)}))";
										proxyType = $"{KnownTypeSymbols.JsonReadOnlyProxyObjectFullName}<{valueType.FullyQualifiedName}>";
									}
								}
							}
							else if (member.Type.IsEnumerable(out var elemType))
							{
								if (IsLocallyGeneratedType(elemType, out target))
								{
									getterExpr = $"new(m_obj.{(member.IsNullableRefType() ? "GetArrayOrDefault" : member.IsRequired ? "GetArray" : "GetArrayOrEmpty")}({GetTargetPropertyNameRef(typeDef, member)}))";
									proxyType = $"{KnownTypeSymbols.JsonReadOnlyProxyArrayFullName}<{elemType.FullyQualifiedName}, {GetLocalReadOnlyProxyRef(target)}>";
								}
								else
								{
									getterExpr = $"new(m_obj.{(member.IsNullableRefType() ? "GetArrayOrDefault" : member.IsRequired ? "GetArray" : "GetArrayOrEmpty")}({GetTargetPropertyNameRef(typeDef, member)}))";
									proxyType = $"{KnownTypeSymbols.JsonReadOnlyProxyArrayFullName}<{elemType.FullyQualifiedName}>";
								}
							}

							if (getterExpr == null)
							{
								if (member.IsNullableRefType())
								{
									getterExpr = $"m_obj.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetTargetPropertyNameRef(typeDef, member)}, {member.DefaultLiteral})";
								}
								else if (member.IsRequired)
								{
									getterExpr = $"m_obj.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)})";
								}
								else if (member.Type.IsValueType() && !member.Type.IsNullableOfT())
								{ // TODO: BUGBUG: it is the same as the next statement?
									getterExpr = $"m_obj.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetTargetPropertyNameRef(typeDef, member)}, {member.DefaultLiteral})";
								}
								else
								{
									getterExpr = $"m_obj.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetTargetPropertyNameRef(typeDef, member)}, {member.DefaultLiteral}!)";
								}
							}

							sb.AppendLine($"public {proxyType} {member.MemberName} => {getterExpr};");

							sb.NewLine();
						}

						sb.AppendLine("#endregion");
						sb.NewLine();

						#endregion
					}
				);

				#endregion

				#region JsonMutableProxy class...

				// IJsonMutableProxy<T>
				sb.AppendLine($"/// <summary>Wraps a <see cref=\"{KnownTypeSymbols.JsonObjectFullName}\"/> into a writable type-safe view that emulates the type <see cref=\"{typeName}\"/></summary>");
				sb.AppendLine($"/// <seealso cref=\"{KnownTypeSymbols.IJsonMutableProxyFullName}{{T}}\"/>");
				sb.Record(
					"public sealed",
					mutableProxyTypeName,
					[
						KnownTypeSymbols.JsonMutableProxyObjectBaseFullName,
						mutableProxyInterfaceName
					],
					[],
					() =>
					{
						//sb.AppendLine($"private readonly {KnownTypeSymbols.JsonObjectFullName} m_obj;");
						//sb.NewLine();

						// ctor()
						sb.AppendLine($"public {mutableProxyTypeName}({KnownTypeSymbols.JsonValueFullName} value, {KnownTypeSymbols.IJsonMutableParentFullName}? parent = null, {KnownTypeSymbols.JsonEncodedPropertyNameFullName}? name = null, int index = 0) : base(value, parent, name, index)");
						sb.EnterBlock();
						sb.LeaveBlock();
						sb.NewLine();

						#region Methods...

						sb.AppendLine("#region Public Methods...");
						sb.NewLine();

						// static Create()
						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public static {mutableProxyTypeName} Create({KnownTypeSymbols.JsonValueFullName} value, {KnownTypeSymbols.IJsonMutableParentFullName}? parent = null, {KnownTypeSymbols.JsonEncodedPropertyNameFullName}? name = null, int index = 0, {jsonConverterInterfaceName}? converter = null) => new(value, parent, name, index);");
						sb.NewLine();

						// static Create()
						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public static {mutableProxyTypeName} Create({typeDef.Type.FullyQualifiedNameAnnotated} value, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = null, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = null) => new({GetLocalSerializerRef(typeDef)}.Pack(value, settings.AsMutable(), resolver));");
						sb.NewLine();

						// static Converter
						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public static {jsonConverterInterfaceName} Converter => {GetLocalSerializerRef(typeDef)};");
						sb.NewLine();

						// TMutable FromValue(TValue)
						sb.AppendLine($"/// <summary>Pack an instance of <see cref=\"{typeDef.Type.FullyQualifiedName}\"/> into a mutable JSON proxy</summary>");
						sb.AppendLine($"public static {mutableProxyTypeName} FromValue({typeDef.Type.FullyQualifiedName} value)");
						sb.EnterBlock();
						if (!typeDef.Type.IsValueType())
						{
							sb.AppendLine("if (value is null) throw new ArgumentNullException(nameof(value));");
						}
						sb.AppendLine($"return new({GetLocalSerializerRef(typeDef)}.Pack(value, {KnownTypeSymbols.CrystalJsonSettingsFullName}.Json));");
						sb.LeaveBlock();
						sb.NewLine();

						// TValue ToValue()
						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public {typeDef.Type.FullyQualifiedName} ToValue() => {GetLocalSerializerRef(typeDef)}.Unpack(m_obj);"); //TODO: resolver?
						sb.NewLine();

						//// JsonObject ToJson()
						//sb.AppendLine($"/// <inheritdoc />");
						//sb.AppendLine($"public {KnownTypeSymbols.JsonValueFullName} ToJson() => m_obj;");
						//sb.NewLine();

						// TReadOnly ToReadOnly()
						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public {readOnlyProxyTypeName} ToReadOnly() => new (m_obj.ToReadOnly());");
						sb.NewLine();

						//// IJsonSerializable
						//sb.AppendLine("/// <inheritdoc />");
						//sb.AppendLine($"void {nameof(IJsonSerializable)}.{nameof(IJsonSerializable.JsonSerialize)}({nameof(CrystalJsonWriter)} writer) => m_obj.{nameof(IJsonSerializable.JsonSerialize)}(writer);");
						//sb.NewLine();

						//// IJsonPackable
						//sb.AppendLine("/// <inheritdoc />");
						//sb.AppendLine($"{KnownTypeSymbols.JsonValueFullName} {nameof(IJsonPackable)}.{nameof(IJsonPackable.JsonPack)}({nameof(CrystalJsonSettings)} settings, {nameof(ICrystalJsonTypeResolver)} resolver) => settings.{nameof(CrystalJsonSettingsExtensions.IsReadOnly)}() ? m_obj.{nameof(JsonObject.ToReadOnly)}() : m_obj;");
						//sb.NewLine();

						sb.AppendLine("#endregion");
						sb.NewLine();

						#endregion

						#region Members

						sb.AppendLine("#region Public Members...");
						sb.NewLine();
						foreach (var member in typeDef.Members)
						{
							var defaultValue = "default"; //BUGBUG: TODO: sb.Constant(member.Type, member.DefaultValue);

							string proxyType = member.Type.FullyQualifiedNameAnnotated;
							string? setterExpr = null;
							string? getterExpr = null;

							if (IsLocallyGeneratedType(member.Type, out var target))
							{
								proxyType = GetLocalMutableProxyRef(target);
								getterExpr = $"new(m_obj.{(member.IsRequired ? "GetObject" : "GetObjectOrEmpty")}({GetTargetPropertyNameRef(typeDef, member)}), name: {serializerTypeName}.{GetPropertyEncodedNameRef(member)})";
								setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}] = value.ToJson()";
							}
							else if (member.Type.IsStringLike() || member.Type.IsBooleanLike() || member.Type.IsNumberLike() || member.Type.IsDateLike())
							{
								if (member.IsNullableRefType())
								{
									if (member.Type.IsString())
									{
										getterExpr ??= $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}].ToStringOrDefault({defaultValue})";
									}
									else
									{
										getterExpr ??= $"m_obj.Get<{member.Type.FullyQualifiedName}?>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
									}
								}
								else if (member.IsRequired)
								{
									if (member.Type.IsString())
									{
										getterExpr ??= $"m_obj.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToString()";
									}
									if (member.Type.SpecialType == SpecialType.System_Int32)
									{
										getterExpr ??= $"m_obj.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt32()";
									}
									//TODO: more!
									else
									{
										getterExpr ??= $"m_obj.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)})";
									}
								}
								else if (member.Type.IsValueType() && !member.Type.IsNullableOfT())
								{
									if (member.Type.SpecialType == SpecialType.System_Int32)
									{
										getterExpr ??= $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}].ToInt32({defaultValue})";
									}
									else
									{
										getterExpr ??= $"m_obj.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
									}
								}
								else
								{
									getterExpr ??= $"m_obj.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue}!)";
								}

								if (member.Type.IsStringLike(allowNullables: true))
								{
									setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}] = {KnownTypeSymbols.JsonStringFullName}.Return(value)";
								}
								else if (member.Type.IsBooleanLike(allowNullables: true))
								{
									setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}] = {KnownTypeSymbols.JsonBooleanFullName}.Return(value)";
								}
								else if (member.Type.IsNumberLike(allowNullables: true))
								{
									setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}] = {KnownTypeSymbols.JsonNumberFullName}.Return(value)";
								}
								else if (member.Type.IsDateLike(allowNullables: true))
								{
									setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}] = {KnownTypeSymbols.JsonDateTimeFullName}.Return(value)";
								}
							}
							else if (member.Type.JsonType is not JsonPrimitiveType.None)
							{
								setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}] = value ?? JsonNull.Null";

								if (member.Type.JsonType is JsonPrimitiveType.Object)
								{
									getterExpr = $"m_obj.{(member.IsRequired ? "GetObject" : member.IsNotNull ? "GetObjectOrEmpty" : "GetObjectOrDefault")}({GetTargetPropertyNameRef(typeDef, member)}){(member.IsNotNull ? "" : "?")}.ToMutable()";
								}
								else if (member.Type.JsonType is JsonPrimitiveType.Array)
								{
									getterExpr = $"m_obj.{(member.IsRequired ? "GetArray" : member.IsNotNull ? "GetArrayOrEmpty" : "GetArrayOrDefault")}({GetTargetPropertyNameRef(typeDef, member)}){(member.IsNotNull ? "" : "?")}.ToMutable()";
								}
								//TODO: JsonString, JsonNumber, ... (are they really used?)
								else
								{
									getterExpr = $"m_obj.{(member.IsRequired ? "GetValue" : "GetValueOrDefault")}({GetTargetPropertyNameRef(typeDef, member)}){(member.IsNotNull ? "" : "?")}.ToMutable()";
								}
							}
							else if (member.Type.IsDictionary(out var keyType, out var valueType))
							{
								if (keyType.IsString())
								{
									if (IsLocallyGeneratedType(valueType, out target))
									{
										proxyType = $"{KnownTypeSymbols.JsonMutableProxyDictionaryFullName}<{valueType.FullyQualifiedName}, {this.GetLocalMutableProxyRef(target)}>";
										getterExpr = $"new(m_obj[{GetTargetPropertyNameRef(typeDef, member)}], parent: this, name: {serializerTypeName}.{GetPropertyEncodedNameRef(member)})";
										setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}] = value.ToJson()";
									}
								}
							}
							else if (member.Type.IsEnumerable(out var elemType))
							{
								if (IsLocallyGeneratedType(elemType, out target))
								{
									proxyType = $"{KnownTypeSymbols.JsonMutableProxyArrayFullName}<{elemType.FullyQualifiedName}, {this.GetLocalMutableProxyRef(target)}>";
									getterExpr = $"new(m_obj[{GetTargetPropertyNameRef(typeDef, member)}], parent: this, name: {serializerTypeName}.{GetPropertyEncodedNameRef(member)})";
									setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}] = value.ToJson()";
								}
							}

							if (getterExpr == null)
							{
								if (member.IsNullableRefType())
								{
									getterExpr = $"m_obj.Get<{member.Type.FullyQualifiedName}?>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
								}
								else if (member.IsRequired)
								{
									getterExpr = $"m_obj.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)})";
								}
								else
								{
									getterExpr = $"m_obj.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue}!)";
								}
							}

							if (setterExpr == null)
							{
								if (member.IsNullableRefType())
								{
									setterExpr ??= $"m_obj.Set<{member.Type.FullyQualifiedName}?>({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
								else
								{
									setterExpr ??= $"m_obj.Set<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
							}

							sb.AppendLine($"/// <inheritdoc cref=\"{typeDef.Type.FullyQualifiedName}.{member.MemberName}\" />");
							sb.AppendLine($"public {proxyType} {member.MemberName}");
							sb.EnterBlock();
							sb.AppendLine($"get => {getterExpr};");
							sb.AppendLine($"set => {setterExpr};");
							sb.LeaveBlock();
							sb.NewLine();
						}

						sb.AppendLine("#endregion");
						sb.NewLine();

						#endregion

					}
				);

				#endregion

				#region JsonObservableProxy class...

				// IJsonObservableProxy<T>
				sb.AppendLine($"/// <summary>Wraps a <see cref=\"{KnownTypeSymbols.JsonObjectFullName}\"/> into a writable type-safe view that emulates the type <see cref=\"{typeName}\"/></summary>");
				sb.AppendLine($"/// <seealso cref=\"{KnownTypeSymbols.IJsonObservableProxyFullName}{{T}}\"/>");
				sb.Record(
					"public sealed",
					observableProxyTypeName,
					[
						KnownTypeSymbols.JsonObservableProxyObjectBaseFullName,
						observableProxyInterfaceName
					],
					[],
					() =>
					{
						//sb.AppendLine($"private readonly {KnownTypeSymbols.JsonObjectFullName} m_obj;");
						//sb.NewLine();

						// ctor()
						sb.AppendLine($"public {observableProxyTypeName}({KnownTypeSymbols.ObservableJsonValueFullName} value) : base(value)");
						sb.EnterBlock();
						sb.LeaveBlock();
						sb.NewLine();

						#region Methods...

						sb.AppendLine("#region Public Methods...");
						sb.NewLine();

						// static Create(JsonValue)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {observableProxyTypeName} Create({KnownTypeSymbols.ObservableJsonValueFullName} value) => new(value);");
						sb.NewLine();

						// static Create(IObservableJsonTransaction, JsonValue)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {observableProxyTypeName} Create({KnownTypeSymbols.IObservableJsonTransaction} tr, {KnownTypeSymbols.JsonValueFullName} value) => new({KnownTypeSymbols.ObservableJsonFullName}.FromJson(tr, {KnownTypeSymbols.ObservableJsonPathFullName}.Root, value));");
						sb.NewLine();

						// static Create(IObservableJsonTransaction, JsonValue)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {observableProxyTypeName} Create({KnownTypeSymbols.IObservableJsonTransaction} tr, {typeDef.Type.FullyQualifiedNameAnnotated} value, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = null, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = null) => Create(tr, {GetLocalSerializerRef(typeDef)}.Pack(value, settings.AsMutable(), resolver));");
						sb.NewLine();

						// static Converter { get; }
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {jsonConverterInterfaceName} Converter => {GetLocalSerializerRef(typeDef)};");
						sb.NewLine();

						// TValue ToValue()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {typeDef.Type.FullyQualifiedName} ToValue() => {GetLocalSerializerRef(typeDef)}.Unpack(m_obj.Json);"); //TODO: resolver?
						sb.NewLine();

						// TReadOnly ToReadOnly()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {readOnlyProxyTypeName} ToReadOnly() => new (m_obj.Json.ToReadOnly());");
						sb.NewLine();

						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public void Set({KnownTypeSymbols.JsonValueFullName}? value) => m_obj.Set(value);");
						sb.NewLine();

						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public void Set(string name, {KnownTypeSymbols.JsonValueFullName}? value) => m_obj.Set(name, value);");
						sb.NewLine();

						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} this[string key] => m_obj[key];");
						sb.NewLine();

						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} this[int index] => m_obj[index];");
						sb.NewLine();

						sb.AppendLine($"/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} this[Index index] => m_obj[index];");
						sb.NewLine();

						sb.AppendLine("#endregion");
						sb.NewLine();

						#endregion

						#region Members

						sb.AppendLine("#region Public Members...");
						sb.NewLine();
						foreach (var member in typeDef.Members)
						{
							var defaultValue = "default"; //BUGBUG: TODO: sb.Constant(member.Type, member.DefaultValue);

							string proxyType = member.Type.FullyQualifiedNameAnnotated;
							string? setterExpr = null;
							string? getterExpr = null;

							if (IsLocallyGeneratedType(member.Type, out var target))
							{
								proxyType = GetLocalObservableProxyRef(target);
								getterExpr = $"new(m_obj[{GetTargetPropertyNameRef(typeDef, member)}])";
								setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}].Set(value.GetValue())";
							}
							else if (member.Type.IsStringLike() || member.Type.IsBooleanLike() || member.Type.IsNumberLike() || member.Type.IsDateLike())
							{
								if (member.IsNullableRefType())
								{
									if (member.Type.IsString())
									{
										getterExpr ??= $"m_obj.Json[{GetTargetPropertyNameRef(typeDef, member)}].ToStringOrDefault({defaultValue})";
									}
									else
									{
										getterExpr ??= $"m_obj.Json.Get<{member.Type.FullyQualifiedName}?>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
									}
								}
								else if (member.IsRequired)
								{
									if (member.Type.IsString())
									{
										getterExpr ??= $"m_obj.Json.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToString()";
									}
									if (member.Type.SpecialType == SpecialType.System_Int32)
									{
										getterExpr ??= $"m_obj.Json.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt32()";
									}
									//TODO: more!
									else
									{
										getterExpr ??= $"m_obj.Json.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)})";
									}
								}
								else if (member.Type.IsValueType() && !member.Type.IsNullableOfT())
								{
									if (member.Type.SpecialType == SpecialType.System_Int32)
									{
										getterExpr ??= $"m_obj.Json[{GetTargetPropertyNameRef(typeDef, member)}].ToInt32({defaultValue})";
									}
									else
									{
										getterExpr ??= $"m_obj.Json.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
									}
								}
								else
								{
									getterExpr ??= $"m_obj.Json.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue}!)";
								}

								if (member.Type.IsStringLike(allowNullables: true))
								{
									setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}].Set({KnownTypeSymbols.JsonStringFullName}.Return(value))";
								}
								else if (member.Type.IsBooleanLike(allowNullables: true))
								{
									setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}].Set({KnownTypeSymbols.JsonBooleanFullName}.Return(value))";
								}
								else if (member.Type.IsNumberLike(allowNullables: true))
								{
									setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}].Set({KnownTypeSymbols.JsonNumberFullName}.Return(value))";
								}
								else if (member.Type.IsDateLike(allowNullables: true))
								{
									setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}].Set({KnownTypeSymbols.JsonDateTimeFullName}.Return(value))";
								}
							}
							else if (member.Type.JsonType is not JsonPrimitiveType.None)
							{
								setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}].Set(value?.Json ?? JsonNull.Null)";

								if (member.Type.JsonType is JsonPrimitiveType.Object)
								{
									proxyType = KnownTypeSymbols.ObservableJsonValueFullName;
									getterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}]";
								}
								else if (member.Type.JsonType is JsonPrimitiveType.Array)
								{
									proxyType = KnownTypeSymbols.ObservableJsonValueFullName;
									getterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}]";
								}
								//TODO: JsonString, JsonNumber, ... (are they really used?)
								else
								{
									proxyType = KnownTypeSymbols.JsonValueFullName;
									getterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}].Json";
								}
							}
							else if (member.Type.IsDictionary(out var keyType, out var valueType))
							{
								if (keyType.IsString())
								{
									if (IsLocallyGeneratedType(valueType, out target))
									{
										proxyType = $"{KnownTypeSymbols.JsonObservableProxyDictionaryFullName}<{valueType.FullyQualifiedName}, {this.GetLocalObservableProxyRef(target)}>";
										getterExpr = $"new(m_obj[{GetTargetPropertyNameRef(typeDef, member)}])";
										setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}].Set(value.GetValue())";
									}
								}
							}
							else if (member.Type.IsEnumerable(out var elemType))
							{
								if (IsLocallyGeneratedType(elemType, out target))
								{
									proxyType = $"{KnownTypeSymbols.JsonObservableProxyArrayFullName}<{elemType.FullyQualifiedName}, {this.GetLocalObservableProxyRef(target)}>";
									getterExpr = $"new(m_obj[{GetTargetPropertyNameRef(typeDef, member)}])";
									setterExpr = $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}].Set(value.GetValue())";
								}
							}

							if (getterExpr == null)
							{
								if (member.IsNullableRefType())
								{
									getterExpr = $"m_obj.Json.Get<{member.Type.FullyQualifiedName}?>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
								}
								else if (member.IsRequired)
								{
									getterExpr = $"m_obj.Json.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)})";
								}
								else
								{
									getterExpr = $"m_obj.Json.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue}!)";
								}
							}

							if (setterExpr == null)
							{
								setterExpr ??= $"m_obj[{GetTargetPropertyNameRef(typeDef, member)}].Set(value)";
							}

							sb.AppendLine($"/// <inheritdoc cref=\"{typeDef.Type.FullyQualifiedName}.{member.MemberName}\" />");
							sb.AppendLine($"public {proxyType} {member.MemberName}");
							sb.EnterBlock();
							sb.AppendLine($"get => {getterExpr};");
							sb.AppendLine($"set => {setterExpr};");
							sb.LeaveBlock();
							sb.NewLine();
						}

						sb.AppendLine("#endregion");
						sb.NewLine();

						#endregion

					}
				);

				#endregion
			}

			private void WriteProxyHelpers(CodeBuilder sb, CrystalJsonTypeMetadata typeDef, string typeName)
			{
				sb.AppendLine($"/// <summary>Returns a read-only JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeName}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeName}\"/> as getter-only properties.</returns>");
				sb.AppendLine($"/// <remarks>");
				sb.AppendLine($"/// <para>The read-only view cannot modify the original JSON value but, unless <paramref name=\"value\"/> is itself read-only, any changes to the original will be reflected in the view.</para>");
				sb.AppendLine($"/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.AsReadOnly();");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {sb.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // ERROR: will not compile (there is no setter defined for this member)");
				sb.AppendLine($"/// </code></para>");
				sb.AppendLine($"/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToMutable({KnownTypeSymbols.JsonValueFullName})\">If you need a writable view</seealso>");
				sb.AppendLine($"public {GetLocalReadOnlyProxyRef(typeDef)} AsReadOnly({KnownTypeSymbols.JsonValueFullName} value) => {GetLocalReadOnlyProxyRef(typeDef)}.Create(value, this);");
				sb.NewLine();

				sb.AppendLine($"/// <summary>Converts an instance of type <see cref=\"{typeName}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeName}\"/> as getter-only properties.</returns>");
				sb.AppendLine($"/// <remarks>");
				sb.AppendLine($"/// <para>How to use:<code>");
				sb.AppendLine($"/// var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.AppendLine($"/// // ...");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.AsReadOnly(instance);");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName};");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = /* ... */; // ERROR: will not compile (there is no setter defined for this member)");
				sb.AppendLine($"/// </code></para>");
				sb.AppendLine($"/// </remarks>");
				sb.AppendLine($"public {GetLocalReadOnlyProxyRef(typeDef)} AsReadOnly({typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalReadOnlyProxyRef(typeDef)}.Create(instance);");
				sb.NewLine();

				sb.AppendLine($"/// <summary>Returns a writable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeName}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalMutableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeName}\"/> as writable properties.</returns>");
				sb.AppendLine($"/// <remarks>");
				sb.AppendLine($"/// <para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.AppendLine($"/// <para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.AppendLine($"/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.AsMutable();");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {sb.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // change the value of the {sb.Constant(typeDef.Members[0].Name)} field");
				sb.AppendLine($"/// </code></para>");
				sb.AppendLine($"/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"AsReadOnly({KnownTypeSymbols.JsonValueFullName})\">If you need a read-only view</seealso>");
				sb.AppendLine($"public {GetLocalMutableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.JsonValueFullName} value) => {GetLocalMutableProxyRef(typeDef)}.Create(value, converter: this);");
				sb.NewLine();

				sb.AppendLine($"/// <summary>Converts an instance of type <see cref=\"{typeName}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeName}\"/> as writable properties.</returns>\r\n");
				sb.AppendLine($"/// <remarks>");
				sb.AppendLine($"/// <para>How to use:<code>");
				sb.AppendLine($"/// var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.AppendLine($"/// // ...");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(instance);");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName};");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue;");
				sb.AppendLine($"/// </code></para>");
				sb.AppendLine($"/// </remarks>");
				sb.AppendLine($"public {GetLocalMutableProxyRef(typeDef)} ToMutable({typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalMutableProxyRef(typeDef)}.Create(instance);");
				sb.NewLine();

				sb.AppendLine($"/// <summary>Returns an observable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeName}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalObservableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeName}\"/> as writable properties.</returns>");
				sb.AppendLine($"/// <remarks>");
				sb.AppendLine($"/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// IObservableJsonTransaction tr = /* create a new transaction that will observe the value */;");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToObservable(tr, json);");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {sb.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // changes the value of the {sb.Constant(typeDef.Members[0].Name)} field");
				sb.AppendLine($"/// </code></para>");
				sb.AppendLine($"/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToMutable({KnownTypeSymbols.JsonValueFullName})\">If you need a non-observed mutable view</seealso>");
				sb.AppendLine($"public {GetLocalObservableProxyRef(typeDef)} ToObservable({KnownTypeSymbols.ObservableJsonValueFullName} value) => {GetLocalObservableProxyRef(typeDef)}.Create(value);");
				sb.NewLine();

				sb.AppendLine($"/// <summary>Returns an observable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeName}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalObservableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeName}\"/> as writable properties.</returns>");
				sb.AppendLine($"/// <remarks>");
				sb.AppendLine($"/// <para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.AppendLine($"/// <para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.AppendLine($"/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// IObservableJsonTransaction tr = /* create a new transaction that will observe the value */;");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToObservable(tr, json);");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {sb.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // changes the value of the {sb.Constant(typeDef.Members[0].Name)} field");
				sb.AppendLine($"/// </code></para>");
				sb.AppendLine($"/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToMutable({KnownTypeSymbols.JsonValueFullName})\">If you need a non-observed mutable view</seealso>");
				sb.AppendLine($"public {GetLocalObservableProxyRef(typeDef)} ToObservable({KnownTypeSymbols.IObservableJsonTransaction} tr, {KnownTypeSymbols.JsonValueFullName} value) => {GetLocalObservableProxyRef(typeDef)}.Create(tr, value);");
				sb.NewLine();

				sb.AppendLine($"/// <summary>Converts an instance of type <see cref=\"{typeName}\"/> into an observable type-safe JSON Proxy.</summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalObservableProxyRef(typeDef)}\"/> that wraps <paramref name=\"instance\"/> and exposes all the original members of <see cref=\"{typeName}\"/> as writable properties.</returns>");
				sb.AppendLine($"/// <remarks>");
				sb.AppendLine($"/// <para>How to use:<code>");
				sb.AppendLine($"/// var instance = new {typeName}() {{ {sb.Constant(typeDef.Members[0].Name)} = /* some value */, /* ... */ }};");
				sb.AppendLine($"/// IObservableJsonTransaction tr = /* create a new transaction that will observe the changes */;");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToObservable(tr, instance);");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {sb.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // changes the value of the {sb.Constant(typeDef.Members[0].Name)} field");
				sb.AppendLine($"/// </code></para>");
				sb.AppendLine($"/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToMutable({KnownTypeSymbols.JsonValueFullName})\">If you need a non-observed mutable view</seealso>");
				sb.AppendLine($"public {GetLocalObservableProxyRef(typeDef)} ToObservable({KnownTypeSymbols.IObservableJsonTransaction} tr, {typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalObservableProxyRef(typeDef)}.Create(tr, instance);");
				sb.NewLine();
			}

			private void WriteUnpackMethod(CodeBuilder sb, CrystalJsonTypeMetadata typeDef, string typeFullName)
			{
				sb.AppendLine($"public {typeFullName} Unpack({KnownTypeSymbols.JsonValueFullName} value, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default)");
				sb.EnterBlock();
				sb.AppendLine("var obj = value.AsObject();");
				sb.AppendLine("return new ()");
				sb.EnterBlock();
				foreach (var member in typeDef.Members)
				{
					if (member.IsNullableRefType())
					{
						sb.AppendLine($"{member.MemberName} = obj.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetLocalPropertyNameRef(member)}, {member.DefaultLiteral}),");
					}
					else if (member.IsRequired)
					{
						sb.AppendLine($"{member.MemberName} = obj.Get<{member.Type.FullyQualifiedName}>({GetLocalPropertyNameRef(member)}),");
					}
					else
					{
						sb.AppendLine($"{member.MemberName} = obj.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetLocalPropertyNameRef(member)}, {member.DefaultLiteral}),");
					}
				}
				sb.LeaveBlock(semicolon: true);
				sb.LeaveBlock();
				sb.NewLine();
			}

			private void WritePackMethod(CodeBuilder sb, CrystalJsonTypeMetadata typeDef)
			{
				sb.AppendLine($"public {KnownTypeSymbols.JsonValueFullName} Pack({typeDef.Type.FullyQualifiedNameAnnotated} instance, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default)");
				sb.EnterBlock();

				if (!typeDef.Type.IsValueType())
				{ // ref types can be null, we will return JsonNull.Null in this case
					sb.AppendLine("if (instance is null)");
					sb.EnterBlock();
					sb.AppendLine($"return {KnownTypeSymbols.JsonNullFullName}.Null;");
					sb.LeaveBlock();
					sb.NewLine();
				}

				sb.AppendLine($"var obj = new {KnownTypeSymbols.JsonObjectFullName}({typeDef.Members.Count});");
				sb.NewLine();

				foreach (var member in typeDef.Members)
				{
					sb.Comment($"\"{member.Name}\" => {member.Type.FullName}{(member.IsNullableRefType() ? "?" : "")} {member.MemberName}{(member.IsKey ? ", KEY" : "")}{(member.IsField ? ", field" : ", prop")}{(member.IsRequired ? ", required" : "")}{(member.IsInitOnly ? ", initOnly" : member.IsReadOnly ? ", readOnly" : "")}");

					var getterExpr = $"instance.{member.MemberName}"; //TODO: maybe use unsafe accessors for some fields?
					var packerExpr = GetMemberPackerExpression(member, getterExpr);

					if (member.Type.IsNullableOfT())
					{
						sb.AppendLine($"obj.AddIfNotNull({GetLocalPropertyNameRef(member)}, {packerExpr});");
					}
					else if (member.IsNotNull)
					{
						sb.AppendLine($"obj.Add({GetLocalPropertyNameRef(member)}, {packerExpr});");
					}
					else
					{
						sb.AppendLine($"obj.AddIfNotNull({GetLocalPropertyNameRef(member)}, {packerExpr});");
					}
					sb.NewLine();
				}
				sb.AppendLine($"return settings.IsReadOnly() ? {KnownTypeSymbols.CrystalJsonMarshallFullName}.FreezeTopLevel(obj) : obj;");
				sb.LeaveBlock();
				sb.NewLine();
			}

			private void WriteSerializeMethod(CodeBuilder sb, CrystalJsonTypeMetadata typeDef, string typeFullName)
			{

				sb.AppendLine($"public void Serialize({KnownTypeSymbols.CrystalJsonWriterFullName} writer, {typeDef.Type.FullyQualifiedNameAnnotated} instance)");
				sb.EnterBlock("Serialize()");

				if (!typeDef.Type.IsValueType())
				{ // ref types can be null, we will write "null" in this case
					sb.AppendLine("if (instance is null)");
					sb.EnterBlock();
					sb.AppendLine($"writer.WriteNull();");
					sb.AppendLine("return;");
					sb.LeaveBlock();
				}

				//TODO: handle IJsonSerializer<T> and IJsonSerializable

				// if the type is not sealed, we may have a derived type, we must defer serialization to this type!
				if (!typeDef.Type.IsSealed)
				{
					//TODO: we should have a local method that can dispatch known types!
					sb.AppendLine($"if (instance.GetType() != typeof({typeFullName}))");
					sb.EnterBlock();
					sb.AppendLine($"{KnownTypeSymbols.CrystalJsonVisitorFullName}.VisitValue(instance, typeof({typeFullName}), writer);");
					sb.AppendLine("return;");
					sb.LeaveBlock();
					sb.NewLine();
				}

				sb.AppendLine("var state = writer.BeginObject();");
				foreach (var member in typeDef.Members)
				{
					this.WriteMemberSerializer(sb, member);
				}
				sb.AppendLine("writer.EndObject(state);");
				sb.LeaveBlock("Serialize()");
				sb.NewLine();
			}

			private string GetMemberPackerExpression(CrystalJsonMemberMetadata member, string getterExpr)
			{
				if (IsLocallyGeneratedType(member.Type, out var target))
				{
					return $"/* local-serializer */ {GetLocalSerializerRef(target)}.Pack({getterExpr}, settings, resolver)";
				}

				// unwrap any Nullable<T> (most packing methods handle both!)
				var concreteType = member.Type.NullableOfType ?? member.Type;
				if (concreteType.IsBooleanLike())
				{
					return $"/* fast-boolean */ {KnownTypeSymbols.JsonBooleanFullName}.Return({getterExpr})";
				}
				if (concreteType.IsStringLike())
				{
					return $"/* fast-string */ {KnownTypeSymbols.JsonStringFullName}.Return({getterExpr})";
				}
				if (concreteType.IsNumberLike())
				{
					return $"/* fast-number */ {KnownTypeSymbols.JsonNumberFullName}.Return({getterExpr})";
				}
				if (concreteType.IsDateLike())
				{
					return $"/* fast-date */ {KnownTypeSymbols.JsonDateTimeFullName}.Return({getterExpr})";
				}

				if (member.Type.JsonType is not JsonPrimitiveType.None)
				{
					// it's already a JSON value, but we may need to convert it to readonly!
					return $"/* fast-json */ settings.IsReadOnly() ? ({getterExpr})?.ToReadOnly() : ({getterExpr})";
				}

				if (concreteType.JsonType is not JsonPrimitiveType.None)
				{
					return $"/* direct-json-value */ {getterExpr}";
				}

				if (concreteType.IsJsonPackable)
				{
					return $"/* packable */ {KnownTypeSymbols.JsonValueFullName}.FromValue({getterExpr}, settings, resolver)";
				}

				if (concreteType.IsDictionary(out var keyType, out var valueType))
				{
					if (keyType.IsString())
					{
						if (IsLocallyGeneratedType(valueType, out target))
						{
							return $"/* local-dict */ {GetLocalSerializerRef(target)}.JsonPackObject({getterExpr}, settings, resolver)";
						}
						if (!valueType.IsValueType())
						{
							return $"/* fallback-dict */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackEnumerable({getterExpr}, settings, resolver)";
						}
					}
					//else: int? other well known type?
				}
				else if (concreteType.IsEnumerable(out var elemType))
				{
					// if the elem type is a local type, we will use the generated serializer
					if (IsLocallyGeneratedType(elemType, out target))
					{
						if (concreteType.IsArray())
						{
							return $"/* local-pack-array */ {GetLocalSerializerRef(target)}.JsonPackArray({getterExpr}, settings, resolver)";
						}
						if (concreteType.IsList())
						{
							return $"/* local-pack-list */ {GetLocalSerializerRef(target)}.JsonPackList({getterExpr}, settings, resolver)";
						}
						if (!elemType.IsValueType())
						{
							return $"/* local-pack-enumerable */ {GetLocalSerializerRef(target)}.JsonPackEnumerable({getterExpr}, settings, resolver)";
						}
					}
					else if (elemType.IsPrimitive)
					{ // for primitive types, we should have a fast direct implementation
						if (concreteType.IsArray())
						{
							return $"/* fast-pack-array */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackArray({getterExpr}, settings, resolver)";
						}
						if (concreteType.IsList())
						{
							return $"/* fast-pack-list */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackList({getterExpr}, settings, resolver)";
						}
						if (!concreteType.IsValueType())
						{
							return $"/* fast-pack-enumerable */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackEnumerable({getterExpr}, settings, resolver)";
						}
					}
					else
					{ // otherwise, use runtime serialization
						if (concreteType.IsArray())
						{
							return $"/* fallback-pack-array */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackArray({getterExpr}, settings, resolver)";
						}
						if (concreteType.IsList())
						{
							return $"/* fallback-pack-list */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackList({getterExpr}, settings, resolver)";
						}
						if (!concreteType.IsValueType())
						{
							return $"/* fallback-pack-enumerable */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackEnumerable({getterExpr}, settings, resolver)";
						}
					}
				}

				return $"/* fallback */ {KnownTypeSymbols.JsonValueFullName}.FromValue({getterExpr}, settings, resolver)";
			}

			private static bool IsFastPathSerializable(TypeMetadata type)
			{
				// Note: we assume we always have Nullable<T> variants helpers in the fast path!
				type = type.NullableOfType ?? type;

				switch (type.SpecialType)
				{
					case SpecialType.System_Boolean:
					case SpecialType.System_Char:
					case SpecialType.System_SByte:
					case SpecialType.System_Byte:
					case SpecialType.System_Int16:
					case SpecialType.System_UInt16:
					case SpecialType.System_Int32:
					case SpecialType.System_UInt32:
					case SpecialType.System_Int64:
					case SpecialType.System_UInt64:
					case SpecialType.System_Decimal:
					case SpecialType.System_Single:
					case SpecialType.System_Double:
					case SpecialType.System_String:
					case SpecialType.System_DateTime:
					{
						return true;
					}
				}

				if (type.NameSpace == "System")
				{
					switch (type.Name)
					{
						case nameof(DateTimeOffset):
						case nameof(Guid):
						case "DateOnly":
						case "TimeOnly":
						{
							return true;
						}
					}
				}

				if (type.NameSpace == "NodaTime")
				{
					switch (type.Name)
					{
						case "Instant":
						case "Duration":
						//TODO: add more!
						{
							return true;
						}
					}
				}

				return false;
			}

			/// <summary>Test if a type has some locally generated serialization methods</summary>
			private bool IsLocallyGeneratedType(TypeRef type, out CrystalJsonTypeMetadata metadata)
				=> this.TypeMap.TryGetValue(type, out metadata);

			/// <summary>Test if a type has some locally generated serialization methods</summary>
			private bool IsLocallyGeneratedType(TypeMetadata type, out CrystalJsonTypeMetadata metadata)
				=> this.IsLocallyGeneratedType(type.Ref, out metadata);

			private void WriteMemberSerializer(CodeBuilder sb, CrystalJsonMemberMetadata member)
			{
				sb.NewLine();
				sb.Comment($"{member.Type.Name} {member.MemberName} => \"{member.Name}\"");

				var propertyName = GetPropertyEncodedNameRef(member);

				if (IsFastPathSerializable(member.Type))
				{
					// there is a dedicated method for this type
					sb.AppendLine($"writer.WriteField({propertyName}, instance.{member.MemberName}); // fast-path");
					return;
				}

				if (IsLocallyGeneratedType(member.Type, out var subDef))
				{ // we have a local generated serializer for this!
					sb.AppendLine($"writer.WriteField({propertyName}, instance.{member.MemberName}, {this.GetLocalSerializerRef(subDef)}); // local-serializer");
					return;
				}

				if (member.Type.SpecialType == SpecialType.System_Nullable_T)
				{
					sb.AppendLine("// nullable!");
				}

				//TODO: test if implements IJsonSerializable

				//TODO: test if this is a dictionary type

				//TODO: test if this is an enumerable type

				// fallback to invoking the generic WriteField<T>(...) method
				sb.AppendLine($"writer.WriteField({propertyName}, instance.{member.MemberName}); // fallback");
			}

		}

	}

}
