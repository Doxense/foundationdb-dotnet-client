#region Copyright (c) 2023-2025 SnowBank SAS, (c) 2005-2023 Doxense SAS
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 	* Redistributions of source code must retain the above copyright
// 	  notice, this list of conditions and the following disclaimer.
// 	* Redistributions in binary form must reproduce the above copyright
// 	  notice, this list of conditions and the following disclaimer in the
// 	  documentation and/or other materials provided with the distribution.
// 	* Neither the name of SnowBank nor the
// 	  names of its contributors may be used to endorse or promote products
// 	  derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL SNOWBANK SAS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#endregion

//#define FULL_DEBUG

namespace SnowBank.Serialization.Json.CodeGen
{
	using System;
	using System.Collections.Generic;
	using Microsoft.CodeAnalysis;
	
	public partial class CrystalJsonSourceGenerator
	{

		[SuppressMessage("ReSharper", "InconsistentNaming")]
		internal sealed class Emitter
		{

			#region Attributes Names ...

			private const string DebuggerNonUserCodeAttributeFullName = "System.Diagnostics.DebuggerNonUserCodeAttribute";

			private const string DisallowNullAttributeFullName = "System.Diagnostics.CodeAnalysis.DisallowNullAttribute";

			private const string DoesNotReturnAttributeFullName = "System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute";

			private const string DynamicallyAccessedMembersAttributeFullName = "System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute";

			private const string DynamicallyAccessedMemberTypesFullName = "System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes";

			private const string GeneratedCodeAttributeFullName = "System.CodeDom.Compiler.GeneratedCodeAttribute";

			private const string NotNullIfNotNullAttributeFullName = "System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute";

			#endregion

			private SourceProductionContext Context { get; }

			private CrystalJsonContainerMetadata Metadata { get; }

			private Dictionary<TypeRef, CrystalJsonTypeMetadata> TypeMap { get; }

			private Dictionary<TypeRef, (CrystalJsonTypeMetadata Parent, object? Discriminator)> PolymorphicMap { get; }

			public Emitter(SourceProductionContext ctx, CrystalJsonContainerMetadata metadata)
			{
				this.Context = ctx;
				this.Metadata = metadata;

				var map = new Dictionary<TypeRef, CrystalJsonTypeMetadata>();
				foreach (var type in metadata.IncludedTypes)
				{
					map[type.Type.Ref] = type;
				}
				this.TypeMap = map;

				// build the set of derived types to their "base" type
				var polymorphicMap = new Dictionary<TypeRef, (CrystalJsonTypeMetadata Parent, object? Discriminator)>();
				foreach (var type in map.Values)
				{
					if (type.DerivedTypes.Count == 0) continue;
					foreach (var (_, derivedType, discriminator) in type.DerivedTypes)
					{
						polymorphicMap[derivedType.Ref] = (type, discriminator);
					}
				}

				this.PolymorphicMap = polymorphicMap;
			}

			private static void AddFileHeaders(CSharpCodeBuilder sb)
			{
				sb.Comment("<auto-generated/>");
				sb.NewLine();
				sb.AppendLine("#nullable enable annotations");
				sb.AppendLine("#nullable enable warnings");
				sb.AppendLine("#pragma warning disable CS0612, CS0618");
				sb.NewLine();
			}

			public void GenerateCode()
			{
				this.Context.CancellationToken.ThrowIfCancellationRequested();

				var symbol = this.Metadata.Type;
				var includedTypes = this.Metadata.IncludedTypes;
				
				Kenobi($"Generating container {symbol.Name} with {includedTypes.Count} included types");
				Kenobi($"Name: '{symbol.FullyQualifiedName}'");
				Kenobi($"Types: {includedTypes.Count}");

				// first we generated a "primary" file for the container, that will include any static methods (that are not specific to a type)

				{
					var sb = new CSharpCodeBuilder();
					AddFileHeaders(sb);

					sb.AppendLine($"namespace {symbol.NameSpace}");
					sb.EnterBlock("namespace");

					sb.AppendLine("/// <summary>Generated source code for JSON operations on application types</summary>");
					sb.AppendLine($"[{DynamicallyAccessedMembersAttributeFullName}({DynamicallyAccessedMemberTypesFullName}.All)]");
					sb.AppendLine($"[{GeneratedCodeAttributeFullName}(\"{nameof(CrystalJsonSourceGenerator)}\", \"0.1\")]");
					sb.AppendLine($"[{DebuggerNonUserCodeAttributeFullName}]");
					sb.AppendLine($"public static partial class {symbol.Name}");
					sb.EnterBlock("container");
					sb.NewLine();

					//TODO: static code?

					sb.AppendLine($"public static {KnownTypeSymbols.IJsonConverterInterfaceFullName}<T> GetConverterFor<T>()");
					sb.EnterBlock("TryGetConverter");
					foreach (var type in includedTypes)
					{
						sb.AppendLine($"if (typeof(T) == typeof({type.Type.FullyQualifiedName})) return System.Runtime.CompilerServices.Unsafe.As<{KnownTypeSymbols.IJsonConverterInterfaceFullName}<T>>({GetLocalSerializerRef(type)});");
					}
					sb.AppendLine($"return {KnownTypeSymbols.CrystalJsonFullName}.DefaultResolver.GetDefaultConverter<T>();");
					sb.LeaveBlock("TryGetConverter");
					sb.NewLine();

					sb.LeaveBlock("container");
					sb.NewLine();

					sb.LeaveBlock("namespace");
					sb.NewLine();

					this.Context.AddSource($"{this.Metadata.Type.Name}.g.cs", sb.ToString());
				}

				// then, we generate one file for each of the serialized type
				foreach (var typeDef in includedTypes)
				{
					Kenobi($"Generating code for {typeDef.Type.FullyQualifiedName}");
					var sb = new CSharpCodeBuilder();
					AddFileHeaders(sb);
#if true || FULL_DEBUG
					{
						sb.Comment("Type Definition:");
						sb.Comment(typeDef.Name + ":");
						var buf = new System.Text.StringBuilder();
						typeDef.Explain(buf, "- ");
						sb.Comment(buf.ToString());
						sb.NewLine();
					}
#endif

					sb.AppendLine($"namespace {symbol.NameSpace}");
					sb.EnterBlock("namespace");

					// we don't want to have to specify the namespace everytime
					sb.AppendLine($"using {KnownTypeSymbols.CrystalJsonNamespace};");
					// we also use a lot of helper static methods from this type
					sb.NewLine();

					sb.AppendLine($"public static partial class {symbol.Name}");
					sb.EnterBlock("Container");

					try
					{
						GenerateCodeForType(sb, typeDef);
					}
					catch (Exception ex)
					{
						Kenobi("CRASH: failed to generate " + typeDef.Name + ": " + ex.ToString());

						var generated = sb.ToString();
						// to help with diagnosing the crash, we will include the code generated so far inside #if ... #endif

						sb.Clear();
						sb.NewLine();
						sb.Comment("ERROR: generator failed!");
						sb.Comment(ex.ToString());
						sb.NewLine();
						sb.Comment("Code generated until the crash:");
						sb.AppendLine("#if false");
						sb.NewLine();
						sb.Output.Append(generated.Replace("#region", "_#region").Replace("#endregion", "_#endregion").Replace("#if", "_#if").Replace("#endif", "_#endif").Replace("#else", "_#else").Replace("#elif", "_#elif"));
						sb.Comment(ex.ToString());
						sb.NewLine();
						sb.AppendLine("#endif");
						sb.NewLine();

						this.Context.AddSource($"{this.Metadata.Type.Name}.{typeDef.Name}.g.cs", sb.ToString());

						this.Context.ReportDiagnostic(
							Diagnostic.Create(new(
								"CJSON0003",
								"Failed to emit JSON code",
								"Failed to emit the generate source-code for for type {0} in {1}: [{2}] {3}.",
								"SnowBank.Serialization.Json.CodeGen",
								DiagnosticSeverity.Error,
								isEnabledByDefault: true
							), null, [ typeDef.Name, this.Metadata.Name, ex.GetType().Name, ex.Message ])
						);
					}

					sb.LeaveBlock("Container");
					sb.NewLine();

					sb.LeaveBlock("namespace");
					sb.NewLine();

					this.Context.AddSource($"{this.Metadata.Type.Name}.{typeDef.Name}.g.cs", sb.ToString());
				}
				Kenobi("Done!");
			}

			private string GetSerializerName(TypeMetadata type) => type.Name;
			private string GetLocalSerializerRef(CrystalJsonTypeMetadata metadata) => $"{this.Metadata.Type.Name}.{GetSerializerName(metadata.Type)}.Default";
			private string GetLocalSerializerRef(TypeMetadata metadata) => $"{this.Metadata.Type.Name}.{GetSerializerName(metadata)}.Default";

			private string GetConverterName(CrystalJsonTypeMetadata metadata) => GetSerializerName(metadata.Type) + ".JsonConverter";

			private string GetReadOnlyProxyName(TypeMetadata type) => $"{type.Name}.ReadOnly";
			private string GetLocalReadOnlyProxyRef(CrystalJsonTypeMetadata metadata) => $"{this.Metadata.Name}.{GetReadOnlyProxyName(metadata.Type)}";

			private string GetWritableProxyName(TypeMetadata type) => $"{type.Name}.Writable";
			private string GetLocalWritableProxyRef(CrystalJsonTypeMetadata metadata) => $"{this.Metadata.Name}.{GetWritableProxyName(metadata.Type)}";

			/// <summary>Returns the name of the generated const string with the serialized name of this member, from within the converter itself</summary>
			private string GetLocalPropertyNameRef(CrystalJsonMemberMetadata member) => "PropertyNames." + member.MemberName;

			/// <summary>Returns the name of the generated const string with the serialized name of this member, from another part of the generated code</summary>
			private string GetTargetPropertyNameRef(CrystalJsonTypeMetadata type, CrystalJsonMemberMetadata member) => this.Metadata.Name + "." + type.Name + ".PropertyNames." + member.MemberName;

			/// <summary>Returns the name of the generated static singleton with the definition of this member</summary>
			private string GetPropertyEncodedNameRef(CrystalJsonMemberMetadata member) => "PropertyEncodedNames." + member.MemberName;

			/// <summary>Generates all types required to serialize a specific type</summary>
			private void GenerateCodeForType(CSharpCodeBuilder sb, CrystalJsonTypeMetadata typeDef)
			{
				var typeName = typeDef.Type.Name;
				var typeFullName = typeDef.Type.FullyQualifiedName;

				// we need to get back the type symbol from the compilation (which we do not store in the metadata, since it changes everytime)

				var serializerName = typeName;
				var serializerTypeName = GetConverterName(typeDef);
				var jsonConverterInterfaceName = $"{KnownTypeSymbols.IJsonConverterInterfaceFullName}<{typeFullName}>";

				var readOnlyProxyTypeName = GetReadOnlyProxyName(typeDef.Type);
				var writableProxyTypeName = GetWritableProxyName(typeDef.Type);

				var readOnlyProxyInterfaceName = $"{KnownTypeSymbols.IJsonReadOnlyProxyFullName}<{typeFullName}, {readOnlyProxyTypeName}, {writableProxyTypeName}>";
				var writableProxyInterfaceName = $"{KnownTypeSymbols.IJsonWritableProxyFullName}<{typeFullName}, {writableProxyTypeName}>";

#if FULL_DEBUG
				sb.Comment($"Generating for type {typeDef.Type.FullyQualifiedName}");
				foreach (var member in typeDef.Members)
				{
					sb.Comment($"- {member.Name}: {member.ToString()}");
				}
				sb.NewLine();
#endif

				sb.AppendLine($"/// <summary>Set of JSON converters and other various helpers for type <see cref=\"{typeFullName}\">{typeName}</see></summary>");
				sb.AppendLine("public static class " + typeName);
				sb.EnterBlock();
				sb.NewLine();

				sb.AppendLine($"/// <summary>JSON converter for type <see cref=\"{typeFullName}\">{typeName}</see></summary>");
				sb.AppendLine($"public static {serializerTypeName} Default => m_cachedSerializer ??= new();");
				sb.NewLine();
				sb.AppendLine($"private static {serializerTypeName}? m_cachedSerializer;");
				sb.NewLine();

				sb.AppendLine("#region Proxy Helpers...");
				sb.NewLine();

				WriteStaticProxyHelpers(sb, typeDef, typeFullName);

				sb.AppendLine("#endregion");
				sb.NewLine();

				#region Metadata...

				sb.AppendLine("#region Metadata...");
				sb.NewLine();

				sb.AppendLine("/// <summary>Names of all serialized members for this type</summary>");
				sb.AppendLine("public static class PropertyNames");
				sb.EnterBlock("properties");
				sb.NewLine();
				foreach (var member in typeDef.Members)
				{
					sb.AppendLine($"/// <summary>Serialized name of the <see cref=\"{typeFullName}.{member.MemberName}\"/> {(member.IsField ? "field" : "property")} of the <see cref=\"{typeFullName}\"/> {(member.Type.IsValueType() ? "struct" : member.Type.IsRecord ? "record" : "class")}</summary>");
					sb.AppendLine($"public const string {member.MemberName} = {CSharpCodeBuilder.Constant(member.Name)};");
					sb.NewLine();
				}

				sb.AppendLine($"public static string[] GetAllNames() => new [] {{ {string.Join(", ", typeDef.Members.Select(this.GetLocalPropertyNameRef))} }};"); //TODO: PERF!
				sb.NewLine();

				sb.LeaveBlock("properties");
				sb.NewLine();

				sb.AppendLine("/// <summary>Cached encoded names for all serialized members for this type</summary>");
				sb.AppendLine("public static class PropertyEncodedNames");
				sb.EnterBlock("properties");
				sb.NewLine();
				foreach (var member in typeDef.Members)
				{
					sb.AppendLine($"/// <summary>Encoded name of the <see cref=\"{typeFullName}.{member.MemberName}\"/> {(member.IsField ? "field" : "property")} of the <see cref=\"{typeFullName}\"/> {(member.Type.IsValueType() ? "struct" : member.Type.IsRecord ? "record" : "class")}</summary>");
					sb.AppendLine($"public static readonly {KnownTypeSymbols.JsonEncodedPropertyNameFullName} {member.MemberName} = new({GetLocalPropertyNameRef(member)});");
					sb.NewLine();
				}
				sb.LeaveBlock("properties");
				sb.NewLine();

				sb.AppendLine("#endregion");
				sb.NewLine();

				#endregion

				#region JsonConverter class...

				sb.AppendLine($"public sealed class JsonConverter : {KnownTypeSymbols.IJsonConverterInterfaceFullName}<{typeFullName}, {readOnlyProxyTypeName}, {writableProxyTypeName}>"); //TODO: implements!
				sb.EnterBlock("JsonConverter");

				#region Helpers...

				sb.AppendLine("#region Conversion Helpers...");
				sb.NewLine();

				WriteProxyHelpers(sb, typeDef, typeFullName);

				sb.AppendLine("#endregion");
				sb.NewLine();

				#endregion

				#region Serialize...

				sb.AppendLine($"#region IJsonSerializer<{typeName}>...");
				sb.NewLine();

				WriteSerializeMethod(sb, typeDef, typeFullName);

				sb.AppendLine("#endregion");
				sb.NewLine();

				#endregion

				#region Pack...

				sb.AppendLine($"#region IJsonPacker<{typeName}>...");
				sb.NewLine();

				WritePackMethod(sb, typeDef);

				sb.AppendLine("#endregion");
				sb.NewLine();

				#endregion

				#region UnPack...

				sb.AppendLine($"#region IJsonDeserializer<{typeName}>...");
				sb.NewLine();

				WriteUnpackMethod(sb, typeDef, typeFullName);

				sb.AppendLine("#endregion");
				sb.NewLine();

				#endregion

				sb.LeaveBlock("JsonConverter");
				sb.NewLine();

				#endregion

				#region Read-Only Proxy...

				// IJsonReadOnlyProxy<T>
				sb.AppendLine($"/// <summary>Wraps a <see cref=\"{KnownTypeSymbols.JsonObjectFullName}\"/> into a read-only type-safe view that emulates the type <see cref=\"{typeFullName}\"/></summary>");
				sb.AppendLine($"/// <seealso cref=\"{KnownTypeSymbols.IJsonReadOnlyProxyFullName}{{T}}\"/>");
				sb.Struct(
					"public readonly",
					"ReadOnly",
					[ readOnlyProxyInterfaceName ],
					[],
					() =>
					{
						// m_value
						sb.AppendLine("/// <summary>Observable JSON Value wrapped by this instance</summary>");
						sb.AppendLine($"private readonly {KnownTypeSymbols.ObservableJsonValueFullName} m_value;");
						sb.NewLine();

						// ctor()
						sb.AppendLine($"public ReadOnly({KnownTypeSymbols.ObservableJsonValueFullName} value)");
						sb.EnterBlock();
						sb.AppendLine("m_value = value;");
						sb.LeaveBlock();
						sb.NewLine();

						#region Methods...

						sb.AppendLine("#region Public Helpers...");
						sb.NewLine();

						// static Create()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {readOnlyProxyTypeName} Create({KnownTypeSymbols.ObservableJsonValueFullName} value, {jsonConverterInterfaceName}? converter = null)");
						sb.AppendLine("\t=> new(value);");
						sb.NewLine();

						// static Create()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {readOnlyProxyTypeName} Create({KnownTypeSymbols.JsonValueFullName} value, {jsonConverterInterfaceName}? converter = null)");
						sb.AppendLine($"\t=> new({KnownTypeSymbols.ObservableJsonValueFullName}.Untracked(value));");
						sb.NewLine();

						// static Create()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {readOnlyProxyTypeName} Create({KnownTypeSymbols.IObservableJsonContextFullName} ctx, {KnownTypeSymbols.JsonValueFullName} value, {jsonConverterInterfaceName}? converter = null)");
						sb.AppendLine($"\t=> new({KnownTypeSymbols.ObservableJsonValueFullName}.Tracked(ctx, value));");
						sb.NewLine();

						// static Create()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {readOnlyProxyTypeName} Create({typeDef.Type.FullyQualifiedNameAnnotated} value, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = null, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = null)");
						sb.AppendLine($"\t=> new({KnownTypeSymbols.ObservableJsonValueFullName}.Untracked({GetLocalSerializerRef(typeDef)}.Pack(value, settings.AsReadOnly(), resolver)));");
						sb.NewLine();

						// static Create()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {readOnlyProxyTypeName} Create({KnownTypeSymbols.IObservableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedNameAnnotated} value, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = null, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = null)");
						sb.AppendLine($"\t=> new({KnownTypeSymbols.ObservableJsonValueFullName}.Tracked(ctx, {GetLocalSerializerRef(typeDef)}.Pack(value, settings.AsReadOnly(), resolver)));");
						sb.NewLine();

						// static Converter
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {jsonConverterInterfaceName} Converter => {GetLocalSerializerRef(typeDef)};");
						sb.NewLine();

						// TValue ToValue()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {typeDef.Type.FullyQualifiedName} ToValue() => {GetLocalSerializerRef(typeDef)}.Unpack(m_value.ToJson());"); //TODO: resolver?
						sb.NewLine();

						// GetContext()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.IObservableJsonContextFullName}? GetContext() => m_value.GetContext();");
						sb.NewLine();

						// bool IsNullOrMissing()
						sb.AppendLine("/// <summary>Tests if this object is either null or missing</summary>");
						sb.AppendLine("/// <returns><c>true</c> if the wrapped JSON value is null or empty; otherwise, <c>false</c>.</returns>");
						sb.AppendLine("public bool IsNullOrMissing() => m_value.IsNullOrMissing();");
						sb.NewLine();

						// bool Exists()
						sb.AppendLine("/// <summary>Tests if this object is present</summary>");
						sb.AppendLine("/// <returns><c>false</c> if the wrapped JSON value is null or empty; otherwise, <c>true</c>.</returns>");
						sb.AppendLine("public bool Exists() => m_value.Exists();");
						sb.NewLine();

						// bool IsObject()
						sb.AppendLine("/// <summary>Tests if the wrapped value is a valid JSON Object.</summary>");
						sb.AppendLine("/// <returns><c>true</c> if the wrapped JSON value is a non-null Object; otherwise, <c>false</c></returns>");
						sb.AppendLine("public bool IsObject() => m_value.IsOfType(JsonType.Object);");
						sb.NewLine();

						// bool IsObjectOrMissing()
						sb.AppendLine("/// <summary>Tests if the wrapped value is a valid JSON Object.</summary>");
						sb.AppendLine("/// <returns><c>true</c> if the wrapped JSON value is a non-null Object; otherwise, <c>false</c></returns>");
						sb.AppendLine("public bool IsObjectOrMissing() => m_value.IsOfTypeOrNull(JsonType.Object);");
						sb.NewLine();

						// Get()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} Get() => m_value;");
						sb.NewLine();

						// ToJson()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.JsonValueFullName} ToJson() => m_value.ToJson();");
						sb.NewLine();

						// ToMutable()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {writableProxyTypeName} ToMutable() => new({KnownTypeSymbols.MutableJsonValueFullName}.Untracked(m_value.GetJsonUnsafe().Copy()));");
						sb.NewLine();

						// this[string]
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} this[string key] => m_value.Get(key);");
						sb.NewLine();

						// Get(string)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} Get(string key) => m_value.Get(key);");
						sb.NewLine();

						// Get<T>(string)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine("public T Get<T>(string key) where T : notnull => m_value.Get<T>(key);");
						sb.NewLine();

						// Get<T>(string, T)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"[return: {NotNullIfNotNullAttributeFullName}(nameof(defaultValue))]");
						sb.AppendLine("public T? Get<T>(string key, T defaultValue) => m_value.Get<T>(key, defaultValue);");
						sb.NewLine();

						// this[ReadOnlyMemory<char>]
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} this[ReadOnlyMemory<char> key] => m_value.Get(key);");
						sb.NewLine();

						// Get(ReadOnlyMemory<char>)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} Get(ReadOnlyMemory<char> key) => m_value.Get(key);");
						sb.NewLine();

						// Get<T>(ReadOnlyMemory<char>)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine("public T Get<T>(ReadOnlyMemory<char> key) where T : notnull => m_value.Get<T>(key);");
						sb.NewLine();

						// Get<T>(ReadOnlyMemory<char>, T)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"[return: {NotNullIfNotNullAttributeFullName}(nameof(defaultValue))]");
						sb.AppendLine("public T? Get<T>(ReadOnlyMemory<char> key, T defaultValue) => m_value.Get<T>(key, defaultValue);");
						sb.NewLine();

						// Get(JsonPath)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} Get({KnownTypeSymbols.JsonPathFullName} path) => m_value.Get(path);");
						sb.NewLine();

						// Get<T>(JsonPath)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public T Get<T>({KnownTypeSymbols.JsonPathFullName} path) where T : notnull => m_value.Get<T>(path);");
						sb.NewLine();

						// Get<T>(JsonPath, T)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"[return: {NotNullIfNotNullAttributeFullName}(nameof(defaultValue))]");
						sb.AppendLine($"public T? Get<T>({KnownTypeSymbols.JsonPathFullName} path, T defaultValue) => m_value.Get<T>(path, defaultValue);");
						sb.NewLine();

						// Get(int)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} Get(int index) => m_value.Get(index);");
						sb.NewLine();

						// Get(Index)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {KnownTypeSymbols.ObservableJsonValueFullName} Get(Index index) => m_value.Get(index);");
						sb.NewLine();

						// TReadOnly With(Action<TMutable>)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {readOnlyProxyTypeName} With(Action<{writableProxyTypeName}> modifier)");
						sb.EnterBlock();
						sb.AppendLine("var copy = m_value.GetJsonUnsafe().Copy();");
						sb.AppendLine($"modifier(new({KnownTypeSymbols.MutableJsonValueFullName}.Untracked(copy)));");
						sb.AppendLine("return new(m_value.Visit(copy.Freeze()));");
						sb.LeaveBlock();
						sb.NewLine();

						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine("public override bool Equals(object? other) => other switch");
						sb.EnterBlock();
						sb.AppendLine($"{readOnlyProxyTypeName} value => m_value.Equals(value.m_value),");
						sb.AppendLine($"{KnownTypeSymbols.ObservableJsonValueFullName} value => m_value.Equals(value),");
						sb.AppendLine($"{KnownTypeSymbols.JsonValueFullName} value => m_value.Equals(value),");
						sb.AppendLine("null => m_value.IsNullOrMissing(),");
						sb.AppendLine("_ => false,");
						sb.LeaveBlock(semicolon: true);
						sb.NewLine();

						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine("public override int GetHashCode() => m_value.ToJson().GetHashCode();");
						sb.NewLine();

						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public bool Equals({readOnlyProxyTypeName} value) => m_value.Equals(value.m_value);");
						sb.NewLine();

						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public bool Equals({KnownTypeSymbols.ObservableJsonValueFullName}? value) => m_value.Equals(value);");
						sb.NewLine();

						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public bool Equals({KnownTypeSymbols.JsonValueFullName}? value) => m_value.Equals(value);");
						sb.NewLine();

						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public override string ToString() => \"({typeName}) \" + m_value.ToString();");
						sb.NewLine();

						// IJsonSerializable
						sb.AppendLine($"void {KnownTypeSymbols.IJsonSerializableFullName}.JsonSerialize({KnownTypeSymbols.CrystalJsonWriterFullName} writer) => m_value.ToJson().JsonSerialize(writer);");
						sb.NewLine();

						// IJsonPackable
						sb.AppendLine($"{KnownTypeSymbols.JsonValueFullName} {KnownTypeSymbols.IJsonPackableFullName}.JsonPack({KnownTypeSymbols.CrystalJsonSettingsFullName} settings, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName} resolver) => m_value.ToJson();");
						sb.NewLine();

						sb.AppendLine("#endregion");
						sb.NewLine();

						#endregion

						#region Members

						sb.AppendLine("#region Type Safe Members...");
						sb.NewLine();

						foreach (var member in typeDef.Members)
						{
							//HACKHACK: TODO: BUGBUG: generate the proper literal for the default of the type ("default", "null", "0", "false", ...)

							string? getterExpr = null;
							string proxyType = member.Type.FullyQualifiedNameAnnotated;

							if (IsLocallyGeneratedType(member.Type, out var target))
							{
								getterExpr = $"new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
								proxyType = GetLocalReadOnlyProxyRef(target);
							}
							else if (member.Type.IsStringLike() || member.Type.IsBooleanLike() || member.Type.IsNumberLike() || member.Type.IsDateLike())
							{
								//use default getter
								getterExpr = null;
							}
							else if (member.Type.JsonType is not JsonPrimitiveType.None)
							{
								getterExpr = member.Type.JsonType switch
								{
									JsonPrimitiveType.Object => $"/* direct-json-object */ m_value[{this.GetTargetPropertyNameRef(typeDef, member)}].ToJson().{(member.IsNullableRefType() ? "AsObjectOrDefault" : member.IsRequired ? "AsObject" : "AsObjectOrEmpty")}()",
									JsonPrimitiveType.Array => $"/* direct-json-array */ m_value[{this.GetTargetPropertyNameRef(typeDef, member)}].ToJson().{(member.IsNullableRefType() ? "AsArrayOrDefault" : member.IsRequired ? "AsArray" : "AsArrayOrEmpty")}()",
									//TODO: JsonString, JsonNumber, ... (are they really used?)
									_ => $"/* direct-json-value */ m_value[{this.GetTargetPropertyNameRef(typeDef, member)}].ToJson()"
								};
							}
							else if (member.Type.IsJsonSerializable)
							{
								getterExpr = null; //TODO?
							}
							else if (member.Type.IsDictionary(out var keyType, out var valueType))
							{
								if (keyType.IsString())
								{
									getterExpr = $"new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
									proxyType = IsLocallyGeneratedType(valueType, out target)
										? $"{KnownTypeSymbols.JsonReadOnlyProxyDictionaryFullName}<{valueType.FullyQualifiedName}, {GetLocalReadOnlyProxyRef(target)}>"
										: $"{KnownTypeSymbols.JsonReadOnlyProxyDictionaryFullName}<{valueType.FullyQualifiedName}>";
								}
							}
							else if (member.Type.IsEnumerable(out var elemType))
							{
								getterExpr = $"new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
								proxyType = IsLocallyGeneratedType(elemType, out target)
									? $"{KnownTypeSymbols.JsonReadOnlyProxyArrayFullName}<{elemType.FullyQualifiedName}, {GetLocalReadOnlyProxyRef(target)}>"
									: $"{KnownTypeSymbols.JsonReadOnlyProxyArrayFullName}<{elemType.FullyQualifiedName}>";
							}

							if (getterExpr == null)
							{
								if (member.IsNullableRefType())
								{
									getterExpr = $"/* ref-nullable */ m_value.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetTargetPropertyNameRef(typeDef, member)}, {member.DefaultLiteral})";
								}
								else if (member.IsRequired)
								{
									getterExpr = $"/* required */ m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)})";
								}
								else if (member.Type.IsValueType() && !member.Type.IsNullableOfT())
								{ // TODO: BUGBUG: it is the same as the next statement?
									getterExpr = $"/* vt-not-null */ m_value.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetTargetPropertyNameRef(typeDef, member)}, {member.DefaultLiteral})";
								}
								else
								{
									getterExpr = $"/* else */ m_value.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetTargetPropertyNameRef(typeDef, member)}, {member.DefaultLiteral})";
								}
							}

							sb.AppendLine($"/// <inheritdoc cref=\"{typeFullName}.{member.MemberName}\" />");
							sb.AppendLine($"public {proxyType} {member.MemberName} => {getterExpr};");
							sb.NewLine();

							// for required member, we also generate a HasXYZ() method that will allow the caller to check if the field is valid (before calling the property that would throw if this is not the case)
							if (member.IsRequired)
							{
								sb.AppendLine($"/// <summary>Tests if the object has a valid value for the <see cref=\"{member.MemberName}\"/> property.</summary>");
								sb.AppendLine($"public bool Has{member.MemberName}() => m_value.ContainsKey({GetTargetPropertyNameRef(typeDef, member)});");
								sb.NewLine();
							}
						}

						sb.AppendLine("#endregion");
						sb.NewLine();

						#endregion
					}
				);

				#endregion

				#region Writable Proxy...

				//note: we cannot generate a readonly struct, otherwise the following would not be allowed
				//  obj.Foo = 123; // this can work
				//	obj.Bar.Bar = 123; // this fails to compile because "obj.Bar" is not a valid 'this' for the Baz setter

				// IJsonWritableProxy<T>
				sb.AppendLine($"/// <summary>Wraps a <see cref=\"{KnownTypeSymbols.JsonObjectFullName}\"/> into a writable type-safe view that emulates the type <see cref=\"{typeFullName}\"/></summary>");
				sb.AppendLine($"/// <seealso cref=\"{KnownTypeSymbols.IJsonWritableProxyFullName}{{T}}\"/>");
				sb.Record(
					"public sealed",
					"Writable",
					[
						KnownTypeSymbols.JsonWritableProxyObjectBaseFullName,
						writableProxyInterfaceName
					],
					[],
					() =>
					{
						// ctor()
						sb.AppendLine($"public Writable({KnownTypeSymbols.MutableJsonValueFullName} value) : base(value)");
						sb.EnterBlock();
						sb.LeaveBlock();
						sb.NewLine();

						#region Methods...

						sb.AppendLine("#region Public Methods...");
						sb.NewLine();

						// static Create()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {writableProxyTypeName} Create({KnownTypeSymbols.MutableJsonValueFullName} value, {jsonConverterInterfaceName}? converter = null) => new(value);");
						sb.NewLine();

						// static Create()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {writableProxyTypeName} Create({KnownTypeSymbols.JsonValueFullName} value) => new({KnownTypeSymbols.MutableJsonValueFullName}.Untracked(value));");
						sb.NewLine();

						// static Create()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {writableProxyTypeName} Create({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {KnownTypeSymbols.JsonValueFullName} value) => new({KnownTypeSymbols.MutableJsonValueFullName}.Tracked(ctx, value));");
						sb.NewLine();

						// static Create()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {writableProxyTypeName} Create({typeDef.Type.FullyQualifiedNameAnnotated} value, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = null, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = null) => new({KnownTypeSymbols.MutableJsonValueFullName}.Untracked({GetLocalSerializerRef(typeDef)}.Pack(value, settings.AsMutable(), resolver)));");
						sb.NewLine();

						// static Create()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {writableProxyTypeName} Create({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedNameAnnotated} value, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = null, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = null) => new({KnownTypeSymbols.MutableJsonValueFullName}.Tracked(ctx, {GetLocalSerializerRef(typeDef)}.Pack(value, settings.AsMutable(), resolver)));");
						sb.NewLine();

						// static Converter
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public static {jsonConverterInterfaceName} Converter => {GetLocalSerializerRef(typeDef)};");
						sb.NewLine();

						// TMutable FromValue(TValue)
						sb.AppendLine($"/// <summary>Pack an instance of <see cref=\"{typeDef.Type.FullyQualifiedName}\"/> into a mutable JSON proxy</summary>");
						sb.AppendLine($"public static {writableProxyTypeName} FromValue({typeDef.Type.FullyQualifiedName} value)");
						sb.EnterBlock();
						if (!typeDef.Type.IsValueType())
						{
							sb.AppendLine("ArgumentNullException.ThrowIfNull(value);");
						}
						sb.AppendLine($"return new({KnownTypeSymbols.MutableJsonValueFullName}.Untracked({GetLocalSerializerRef(typeDef)}.Pack(value, {KnownTypeSymbols.CrystalJsonSettingsFullName}.Json)));");
						sb.LeaveBlock();
						sb.NewLine();

						// TMutable FromValue(TValue)
						sb.AppendLine($"/// <summary>Pack an instance of <see cref=\"{typeDef.Type.FullyQualifiedName}\"/> into a mutable JSON proxy</summary>");
						sb.AppendLine($"public static {writableProxyTypeName} FromValue({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedName} value)");
						sb.EnterBlock();
						if (!typeDef.Type.IsValueType())
						{
							sb.AppendLine("ArgumentNullException.ThrowIfNull(value);");
						}
						sb.AppendLine($"return new({KnownTypeSymbols.MutableJsonValueFullName}.Tracked(ctx, {GetLocalSerializerRef(typeDef)}.Pack(value, {KnownTypeSymbols.CrystalJsonSettingsFullName}.Json)));");
						sb.LeaveBlock();
						sb.NewLine();

						// ToValue()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {typeDef.Type.FullyQualifiedName} ToValue() => {GetLocalSerializerRef(typeDef)}.Unpack(m_value.ToJson());"); //TODO: resolver?
						sb.NewLine();

						// TReadOnly ToReadOnly()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public {readOnlyProxyTypeName} ToReadOnly() => new({KnownTypeSymbols.ObservableJsonValueFullName}.Untracked(m_value.ToJson().ToReadOnly()));");
						sb.NewLine();

						// Set(TReadOnly)
						sb.AppendLine($"public void Set({readOnlyProxyTypeName} value) => m_value.Set(value.ToJson());");
						sb.NewLine();

						// Set(TWritable)
						sb.AppendLine($"public void Set({writableProxyTypeName} value) => m_value.Set(value.ToJson());");
						sb.NewLine();

						// Set(T)
						sb.AppendLine($"public void Set({typeDef.Type.FullyQualifiedName} instance) => m_value.Set({GetLocalSerializerRef(typeDef)}.Pack(instance, {KnownTypeSymbols.CrystalJsonSettingsFullName}.Json));");
						sb.NewLine();

						// GetHashCode()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"[{DoesNotReturnAttributeFullName}]");
						sb.AppendLine("public override int GetHashCode() => throw new NotSupportedException();");
						sb.NewLine();

						// Equals(TWritable)
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public bool Equals({writableProxyTypeName}? value) => m_value.Equals(value?.m_value);");
						sb.NewLine();

						// ToString()
						sb.AppendLine("/// <inheritdoc />");
						sb.AppendLine($"public override string ToString() => \"({typeName}) \" + m_value.ToString();");
						sb.NewLine();

						sb.AppendLine("#endregion");
						sb.NewLine();

						#endregion

						#region Members

						sb.AppendLine("#region Public Members...");
						sb.NewLine();
						foreach (var member in typeDef.Members)
						{
							var defaultValue = member.DefaultLiteral;

							string proxyType = member.Type.FullyQualifiedNameAnnotated;
							string? setterExpr = null;
							string? getterExpr = null;
							string? attributeExpr = null;

							if (IsLocallyGeneratedType(member.Type, out var target))
							{
								proxyType = GetLocalWritableProxyRef(target);
								getterExpr = $"/* proxy */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
								setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value.ToJson())";
							}
							else if (member.Type.IsStringLike() || member.Type.IsBooleanLike() || member.Type.IsNumberLike() || member.Type.IsDateLike())
							{
								if (member.Type.IsString())
								{
									if (member.IsRequired)
									{
										attributeExpr = $"[{DisallowNullAttributeFullName}]";
										if (!proxyType.EndsWith("?")) proxyType += "?";
									}
									getterExpr ??= $"/* fast-string */ m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToStringOrDefault({defaultValue})";
								}
								else if (member.IsNullableRefType())
								{
									getterExpr ??= $"/* ref-nullable */ m_value.Get<{member.Type.FullyQualifiedName}?>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
								}
								else if (member.IsRequired)
								{
									if (!member.IsNotNull)
									{
										attributeExpr = $"[{DisallowNullAttributeFullName}]";
										if (!proxyType.EndsWith("?")) proxyType += "?";
									}
									getterExpr ??= member.Type.SpecialType switch
									{
										SpecialType.System_Char => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToChar({defaultValue})",
										SpecialType.System_Boolean => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToBoolean({defaultValue})",
										SpecialType.System_Int32 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt32({defaultValue})",
										SpecialType.System_UInt32 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToUInt32({defaultValue})",
										SpecialType.System_Int64 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt64({defaultValue})",
										SpecialType.System_UInt64 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToUInt64({defaultValue})",
										SpecialType.System_Single => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToSingle({defaultValue})",
										SpecialType.System_Double => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDouble({defaultValue})",
										SpecialType.System_Decimal => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDecimal({defaultValue})",
										SpecialType.System_DateTime => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDateTime({defaultValue})",
										_ => $"m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})"
									};
									getterExpr = "/* required */ " + getterExpr;
								}
								else if (member.Type.IsValueType() && !member.Type.IsNullableOfT())
								{
									getterExpr ??= member.Type.SpecialType switch
									{
										SpecialType.System_Boolean => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToBoolean({defaultValue})",
										SpecialType.System_Char => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToChar({defaultValue})",
										SpecialType.System_Int32 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt32({defaultValue})",
										SpecialType.System_UInt32 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToUInt32({defaultValue})",
										SpecialType.System_Int64 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt64({defaultValue})",
										SpecialType.System_UInt64 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToUInt64({defaultValue})",
										SpecialType.System_Single => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToSingle({defaultValue})",
										SpecialType.System_Double => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDouble({defaultValue})",
										SpecialType.System_Decimal => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDecimal({defaultValue})",
										SpecialType.System_DateTime => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDateTime({defaultValue})",
										_ => $"m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})"
									};
									getterExpr = "/* value-type */ " + getterExpr;
								}
								else if (member.Type.IsNullableOfT())
								{
									getterExpr ??= member.Type.SpecialType switch
									{
										SpecialType.System_Boolean => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToBooleanOrDefault({defaultValue})",
										SpecialType.System_Char => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToCharOrDefault({defaultValue})",
										SpecialType.System_Int32 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt32OrDefault({defaultValue})",
										SpecialType.System_UInt32 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToUInt32OrDefault({defaultValue})",
										SpecialType.System_Int64 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToInt64OrDefault({defaultValue})",
										SpecialType.System_UInt64 => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToUInt64OrDefault({defaultValue})",
										SpecialType.System_Single => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToSingleOrDefault({defaultValue})",
										SpecialType.System_Double => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDoubleOrDefault({defaultValue})",
										SpecialType.System_Decimal => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDecimalOrDefault({defaultValue})",
										SpecialType.System_DateTime => $"m_value.GetValue({GetTargetPropertyNameRef(typeDef, member)}).ToDateTimeOrDefault({defaultValue})",
										_ => $"m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})"
									};
									getterExpr = "/* vt-nullable */ " + getterExpr;
								}
								else
								{
									getterExpr ??= $"/* else */ m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
								}

								if (member.Type.IsStringLike(allowNullables: true))
								{
									setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
								else if (member.Type.IsBooleanLike(allowNullables: true))
								{
									setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
								else if (member.Type.IsNumberLike(allowNullables: true))
								{
									setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
								else if (member.Type.IsDateLike(allowNullables: true))
								{
									setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
							}
							else if (member.Type.JsonType is not JsonPrimitiveType.None)
							{
								setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value?.ToJson() ?? JsonNull.Null)";
								proxyType = KnownTypeSymbols.MutableJsonValueFullName;
								getterExpr = $"/* json */ m_value[{GetTargetPropertyNameRef(typeDef, member)}]";
							}
							else if (member.Type.IsDictionary(out var keyType, out var valueType))
							{
								if (keyType.IsString())
								{
									if (IsLocallyGeneratedType(valueType, out target))
									{
										proxyType = $"{KnownTypeSymbols.JsonWritableProxyDictionaryFullName}<{valueType.FullyQualifiedName}, {this.GetLocalWritableProxyRef(target)}>";
										getterExpr = $"/* dict-proxy */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
										setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value.ToJson())";
									}
									else if (valueType.IsStringLike() || valueType.IsBooleanLike() || valueType.IsNumberLike() || valueType.IsDateLike())
									{
										proxyType = $"{KnownTypeSymbols.JsonWritableProxyDictionaryFullName}<{valueType.FullyQualifiedNameAnnotated}>";
										getterExpr = $"/* dict */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
										setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value.ToJson())";
									}
									//TODO: other types?
								}
							}
							else if (member.Type.IsEnumerable(out var elemType))
							{
								if (IsLocallyGeneratedType(elemType, out target))
								{
									proxyType = $"{KnownTypeSymbols.JsonWritableProxyArrayFullName}<{elemType.FullyQualifiedName}, {this.GetLocalWritableProxyRef(target)}>";
									getterExpr = $"/* array-proxy */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
									setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value.ToJson())";
								}
								else if (elemType.IsStringLike() || elemType.IsBooleanLike() || elemType.IsNumberLike() || elemType.IsDateLike())
								{
									proxyType = $"{KnownTypeSymbols.JsonWritableProxyArrayFullName}<{elemType.FullyQualifiedName}>";
									getterExpr = $"/* array */ new(m_value[{GetTargetPropertyNameRef(typeDef, member)}])";
									setterExpr = $"m_value.Set({GetTargetPropertyNameRef(typeDef, member)}, value.ToJson())";
								}
								//TODO: other types?
							}

							if (getterExpr == null)
							{
								if (member.IsNullableRefType())
								{
									getterExpr = $"/* fallback-ref-nullable */ m_value.Get<{member.Type.FullyQualifiedName}?>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
								}
								else if (member.IsRequired)
								{
									getterExpr = $"/* fallback-required */ m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)})";
								}
								else
								{
									getterExpr = $"/* fallback-else */ m_value.Get<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, {defaultValue})";
								}
							}

							if (setterExpr == null)
							{
								if (member.IsNullableRefType())
								{
									setterExpr ??= $"m_value.Set<{member.Type.FullyQualifiedName}?>({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
								else
								{
									setterExpr ??= $"m_value.Set<{member.Type.FullyQualifiedName}>({GetTargetPropertyNameRef(typeDef, member)}, value)";
								}
							}

							sb.AppendLine($"/// <inheritdoc cref=\"{typeDef.Type.FullyQualifiedName}.{member.MemberName}\" />");
							if (attributeExpr != null) sb.AppendLine(attributeExpr);
							sb.AppendLine($"public {proxyType} {member.MemberName}");
							sb.EnterBlock();
							sb.AppendLine($"get => {getterExpr};");
							sb.AppendLine($"set => {setterExpr};");
							sb.LeaveBlock();
							sb.NewLine();
						}

						sb.AppendLine("#endregion");
						sb.NewLine();

						#endregion

					}
				);

				#endregion

				sb.LeaveBlock();
				sb.NewLine();

			}

			private void WriteStaticProxyHelpers(CSharpCodeBuilder sb, CrystalJsonTypeMetadata typeDef, string typeFullName)
			{

				// Serialize(...)
				sb.AppendLine($"public static void Serialize({KnownTypeSymbols.CrystalJsonWriterFullName} writer, {typeDef.Type.FullyQualifiedName}{(typeDef.Type.IsValueType() ? "" : "?")} instance) => Default.Serialize(writer, instance);");
				sb.NewLine();

				// ToJson(...)
				sb.AppendLine($"public static string ToJson({typeDef.Type.FullyQualifiedNameAnnotated} instance, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default) => Default.ToJson(instance, settings, resolver);");
				sb.NewLine();

				// Deserialize(...)
				sb.AppendLine($"public static {typeDef.Type.FullyQualifiedName} Deserialize(string jsonText, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default) => Default.Deserialize(jsonText, settings, resolver);");
				sb.NewLine();

				// Pack(...)
				sb.AppendLine($"/// <summary>Converts an instance of this type into the equivalent <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/></summary>");
				sb.AppendLine($"public static {KnownTypeSymbols.JsonValueFullName} Pack({typeDef.Type.FullyQualifiedNameAnnotated} instance, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default) => Default.Pack(instance, settings, resolver);");
				sb.NewLine();

				// Unpack(...)
				sb.AppendLine($"/// <summary>Deserializes a JSON value into an instance of type <see cref=\"{typeFullName}\" /></summary>");
				sb.AppendLine($"public static {typeDef.Type.FullyQualifiedNameAnnotated} Unpack({KnownTypeSymbols.JsonValueFullName} value, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default) => Default.Unpack(value, resolver);");
				sb.NewLine();

				// ToReadOnly(JsonValue)
				sb.AppendLine($"/// <summary>Returns a read-only JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeFullName}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeFullName}\"/> as getter-only properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>The read-only view cannot modify the original JSON value but, unless <paramref name=\"value\"/> is itself read-only, any changes to the original will be reflected in the view.</para>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly();");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // ERROR: will not compile (there is no setter defined for this member)");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToMutable({KnownTypeSymbols.JsonValueFullName})\">If you need a writable view</seealso>");
				sb.AppendLine($"public static {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({KnownTypeSymbols.JsonValueFullName} value) => {GetLocalReadOnlyProxyRef(typeDef)}.Create({KnownTypeSymbols.ObservableJsonValueFullName}.Untracked(value), Default);");
				sb.NewLine();

				// ToReadOnly(IObservableJsonContext, JsonValue)
				sb.AppendLine($"/// <summary>Returns a read-only JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeFullName}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeFullName}\"/> as getter-only properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>The read-only view cannot modify the original JSON value but, unless <paramref name=\"value\"/> is itself read-only, any changes to the original will be reflected in the view.</para>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly();");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // ERROR: will not compile (there is no setter defined for this member)");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToMutable({KnownTypeSymbols.JsonValueFullName})\">If you need a writable view</seealso>");
				sb.AppendLine($"public static {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({KnownTypeSymbols.IObservableJsonContextFullName} ctx, {KnownTypeSymbols.JsonValueFullName} value) => {GetLocalReadOnlyProxyRef(typeDef)}.Create({KnownTypeSymbols.ObservableJsonValueFullName}.Tracked(ctx, value), Default);");
				sb.NewLine();

				// ToReadOnly(TValue)
				sb.AppendLine($"/// <summary>Converts an instance of type <see cref=\"{typeFullName}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeFullName}\"/> as getter-only properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.AppendLine("/// // ...");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly(instance);");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName};");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = /* ... */; // ERROR: will not compile (there is no setter defined for this member)");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"public static {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalReadOnlyProxyRef(typeDef)}.Create(instance);");
				sb.NewLine();

				// ToReadOnly(IObservableJsonContext, TValue)
				sb.AppendLine($"/// <summary>Converts an instance of type <see cref=\"{typeFullName}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeFullName}\"/> as getter-only properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.AppendLine("/// // ...");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly(instance);");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName};");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = /* ... */; // ERROR: will not compile (there is no setter defined for this member)");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"public static {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({KnownTypeSymbols.IObservableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalReadOnlyProxyRef(typeDef)}.Create(ctx, instance);");
				sb.NewLine();

				// ToMutable(MutableJsonValue)
				sb.AppendLine($"/// <summary>Returns a writable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeFullName}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalWritableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeFullName}\"/> as writable properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.AppendLine($"/// <para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.AsMutable();");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // change the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToReadOnly({KnownTypeSymbols.JsonValueFullName})\">If you need a read-only view</seealso>");
				sb.AppendLine($"public static {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.MutableJsonValueFullName} value) => {GetLocalWritableProxyRef(typeDef)}.Create(value, converter: Default);");
				sb.NewLine();

				// ToMutable(JsonValue)
				sb.AppendLine($"/// <summary>Returns a writable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeFullName}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalWritableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeFullName}\"/> as writable properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.AppendLine($"/// <para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.AsMutable();");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // change the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToReadOnly({KnownTypeSymbols.JsonValueFullName})\">If you need a read-only view</seealso>");
				sb.AppendLine($"public static {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.JsonValueFullName} value) => {GetLocalWritableProxyRef(typeDef)}.Create({KnownTypeSymbols.MutableJsonValueFullName}.Untracked(value), converter: Default);");
				sb.NewLine();

				// ToMutable(IMutableJsonContext, JsonValue)
				sb.AppendLine($"/// <summary>Returns a writable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeFullName}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalWritableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeFullName}\"/> as writable properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.AppendLine($"/// <para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.AsMutable();");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // change the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToReadOnly({KnownTypeSymbols.JsonValueFullName})\">If you need a read-only view</seealso>");
				sb.AppendLine($"public static {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {KnownTypeSymbols.JsonValueFullName} value) => {GetLocalWritableProxyRef(typeDef)}.Create({KnownTypeSymbols.MutableJsonValueFullName}.Tracked(ctx, value), converter: Default);");
				sb.NewLine();

				// ToMutable(TValue)
				sb.AppendLine($"/// <summary>Converts an instance of type <see cref=\"{typeFullName}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeFullName}\"/> as writable properties.</returns>\r\n");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.AppendLine("/// // ...");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(instance);");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName};");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue;");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"public static {GetLocalWritableProxyRef(typeDef)} ToMutable({typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalWritableProxyRef(typeDef)}.Create(instance);");
				sb.NewLine();

				// ToMutable(IMutableJsonContext, TValue)
				sb.AppendLine($"/// <summary>Converts an instance of type <see cref=\"{typeFullName}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeFullName}\"/> as writable properties.</returns>\r\n");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.AppendLine("/// // ...");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(instance);");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName};");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue;");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"public static {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalWritableProxyRef(typeDef)}.Create(ctx, instance);");
				sb.NewLine();

			}

			private void WriteProxyHelpers(CSharpCodeBuilder sb, CrystalJsonTypeMetadata typeDef, string typeCref)
			{

				// ToReadOnly(JsonValue)
				sb.AppendLine($"/// <summary>Returns a read-only JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as getter-only properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>The read-only view cannot modify the original JSON value but, unless <paramref name=\"value\"/> is itself read-only, any changes to the original will be reflected in the view.</para>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly();");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // ERROR: will not compile (there is no setter defined for this member)");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToMutable({KnownTypeSymbols.JsonValueFullName})\">If you need a writable view</seealso>");
				sb.AppendLine($"public {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({KnownTypeSymbols.JsonValueFullName} value) => {GetLocalReadOnlyProxyRef(typeDef)}.Create({KnownTypeSymbols.ObservableJsonValueFullName}.Untracked(value), Default);");
				sb.NewLine();

				// ToReadOnly(IObservableJsonContext, JsonValue)
				sb.AppendLine($"/// <summary>Returns a read-only JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as getter-only properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>The read-only view cannot modify the original JSON value but, unless <paramref name=\"value\"/> is itself read-only, any changes to the original will be reflected in the view.</para>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly();");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // ERROR: will not compile (there is no setter defined for this member)");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToMutable({KnownTypeSymbols.JsonValueFullName})\">If you need a writable view</seealso>");
				sb.AppendLine($"public {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({KnownTypeSymbols.IObservableJsonContextFullName} ctx, {KnownTypeSymbols.JsonValueFullName} value) => {GetLocalReadOnlyProxyRef(typeDef)}.Create({KnownTypeSymbols.ObservableJsonValueFullName}.Tracked(ctx, value), this);");
				sb.NewLine();

				// ToReadOnly(TValue)
				sb.AppendLine($"/// <summary>Converts an instance of type <see cref=\"{typeCref}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeCref}\"/> as getter-only properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.AppendLine("/// // ...");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly(instance);");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName};");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = /* ... */; // ERROR: will not compile (there is no setter defined for this member)");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"public {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalReadOnlyProxyRef(typeDef)}.Create(instance);");
				sb.NewLine();

				// ToReadOnly(IObservableJsonContext, TValue)
				sb.AppendLine($"/// <summary>Converts an instance of type <see cref=\"{typeCref}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeCref}\"/> as getter-only properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.AppendLine("/// // ...");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToReadOnly(instance);");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName};");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = /* ... */; // ERROR: will not compile (there is no setter defined for this member)");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"public {GetLocalReadOnlyProxyRef(typeDef)} ToReadOnly({KnownTypeSymbols.IObservableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalReadOnlyProxyRef(typeDef)}.Create(ctx, instance);");
				sb.NewLine();

				// ToMutable(MutableJsonValue)
				sb.AppendLine($"/// <summary>Returns a writable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalWritableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.AppendLine($"/// <para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.AsMutable();");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // change the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToReadOnly({KnownTypeSymbols.JsonValueFullName})\">If you need a read-only view</seealso>");
				sb.AppendLine($"public {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.MutableJsonValueFullName} value) => {GetLocalWritableProxyRef(typeDef)}.Create(value, converter: this);");
				sb.NewLine();

				// ToMutable(JsonValue)
				sb.AppendLine($"/// <summary>Returns a writable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalWritableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.AppendLine($"/// <para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.AsMutable();");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // change the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToReadOnly({KnownTypeSymbols.JsonValueFullName})\">If you need a read-only view</seealso>");
				sb.AppendLine($"public {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.JsonValueFullName} value) => {GetLocalWritableProxyRef(typeDef)}.Create({KnownTypeSymbols.MutableJsonValueFullName}.Untracked(value), converter: this);");
				sb.NewLine();

				// ToMutable(IMutableJsonContext, JsonValue)
				sb.AppendLine($"/// <summary>Returns a writable JSON Proxy that wraps a <see cref=\"{KnownTypeSymbols.JsonValueFullName}\"/> into a type-safe emulation of type <see cref=\"{typeCref}\"/></summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalWritableProxyRef(typeDef)}\"/> that wraps <paramref name=\"value\"/> and exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>If <paramref name=\"value\"/> is read-only, a mutable copy will be created and used instead.</para>");
				sb.AppendLine($"/// <para>If <paramref name=\"value\"/> is mutable, then it will be modified in-place. You can call <see cref=\"{KnownTypeSymbols.JsonValueFullName}.ToMutable\"/> if you need to make a copy in all cases.</para>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// JsonValue json = {KnownTypeSymbols.JsonValueFullName}.Parse(/* JSON text */);");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.AsMutable();");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName}; // returns the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field exposed as <see cref=\"{typeDef.Members[0].Type.FullyQualifiedName}\"/>");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue; // change the value of the {CSharpCodeBuilder.Constant(typeDef.Members[0].Name)} field");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"/// <seealso cref=\"ToReadOnly({KnownTypeSymbols.JsonValueFullName})\">If you need a read-only view</seealso>");
				sb.AppendLine($"public {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {KnownTypeSymbols.JsonValueFullName} value) => {GetLocalWritableProxyRef(typeDef)}.Create({KnownTypeSymbols.MutableJsonValueFullName}.Tracked(ctx, value), converter: this);");
				sb.NewLine();

				// ToMutable(TValue)
				sb.AppendLine($"/// <summary>Converts an instance of type <see cref=\"{typeCref}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>\r\n");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.AppendLine("/// // ...");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(instance);");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName};");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue;");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"public {GetLocalWritableProxyRef(typeDef)} ToMutable({typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalWritableProxyRef(typeDef)}.Create(instance);");
				sb.NewLine();

				// ToMutable(IMutableJsonContext, TValue)
				sb.AppendLine($"/// <summary>Converts an instance of type <see cref=\"{typeCref}\"/> into a read-only type-safe JSON Proxy.</summary>");
				sb.AppendLine($"/// <returns>An instance of <see cref=\"{GetLocalReadOnlyProxyRef(typeDef)}\"/> that exposes all the original members of <see cref=\"{typeCref}\"/> as writable properties.</returns>\r\n");
				sb.AppendLine("/// <remarks>");
				sb.AppendLine("/// <para>How to use:<code>");
				sb.AppendLine($"/// var instance = new {typeDef.Name}() {{ {typeDef.Members[0].MemberName} = ..., ... }};");
				sb.AppendLine("/// // ...");
				sb.AppendLine($"/// var proxy = {GetSerializerName(typeDef.Type)}.ToMutable(instance);");
				sb.AppendLine($"/// var value = proxy.{typeDef.Members[0].MemberName};");
				sb.AppendLine($"/// proxy.{typeDef.Members[0].MemberName} = newValue;");
				sb.AppendLine("/// </code></para>");
				sb.AppendLine("/// </remarks>");
				sb.AppendLine($"public {GetLocalWritableProxyRef(typeDef)} ToMutable({KnownTypeSymbols.IMutableJsonContextFullName} ctx, {typeDef.Type.FullyQualifiedNameAnnotated} instance) => {GetLocalWritableProxyRef(typeDef)}.Create(ctx, instance);");
				sb.NewLine();

			}

			private void WriteUnpackMethod(CSharpCodeBuilder sb, CrystalJsonTypeMetadata typeDef, string typeFullName)
			{
				sb.AppendLine($"/// <summary>Deserializes a JSON value into an instance of type <see cref=\"{typeFullName}\" /></summary>");
				sb.AppendLine($"public {typeFullName} Unpack({KnownTypeSymbols.JsonValueFullName} value, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default)");
				sb.EnterBlock();

				if (typeDef.IsPolymorphic)
				{ // this is a polymorphic type, we have to dispatch to the corresponding derived type converter!

					// get the type discriminator
					sb.AppendLine($"var discriminator = value[{CSharpCodeBuilder.Constant(typeDef.TypeDiscriminatorPropertyName ?? "$type")}];");
					foreach (var (_, derivedType, discriminator) in typeDef.DerivedTypes)
					{
						if (derivedType.IsAbstract)
						{ // don't include intermediary abstract types, we will only process the concrete types (the ones that we can actually create a runtime)
							continue;
						}
						switch (discriminator)
						{
							case null:
							{
								//REVIEW: how do we handle this case?
								break;
							}
							case string s:
							{
								sb.AppendLine($"if (discriminator.ValueEquals({CSharpCodeBuilder.Constant(s)})) return {GetLocalSerializerRef(derivedType)}.Unpack(value, resolver);");
								break;
							}
							case int n:
							{
								sb.AppendLine($"if (discriminator.ValueEquals({CSharpCodeBuilder.Constant(n)})) return {GetLocalSerializerRef(derivedType)}.Unpack(value, resolver);");
								break;
							}
							default:
							{
								sb.AppendLine($"#error Invalid discriminator value type for derived type {derivedType.Name} of parent type {typeDef.Name}");
								break;
							}
						}
					}

					sb.AppendLine($"throw {KnownTypeSymbols.JsonBindingExceptionFullName}.CannotDeserializeCustomTypeWithUnknownTypeDiscriminator(value, typeof({typeFullName}), discriminator);");
					sb.LeaveBlock();
					sb.NewLine();
					return;
				}

				bool hasPolymorphicDefinition = this.PolymorphicMap.TryGetValue(typeDef.Type.Ref, out var polymorphicMetadata);
				if (typeDef.Type.IsAbstract)
				{ // do we have a parent ?
					if (hasPolymorphicDefinition)
					{ // defer to the parent type which should have all the derived types under this one
						//REVIEW: TODO: we _could_ optimize by having a smaller switch with only de types under us?
						sb.AppendLine($"return ({typeFullName}) {GetLocalSerializerRef(polymorphicMetadata.Parent)}.Unpack(value, resolver);");
						sb.LeaveBlock();
						sb.NewLine();
						return;
					}
				}

				sb.AppendLine("var obj = value.AsObject();");
				sb.AppendLine("return new ()");
				sb.EnterBlock();
				foreach (var member in typeDef.Members)
				{
					if (member.IsNullableRefType())
					{
						sb.AppendLine($"{member.MemberName} = /* ref-nullable */ obj.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetLocalPropertyNameRef(member)}, {member.DefaultLiteral}),");
					}
					else if (member.IsRequired)
					{
						sb.AppendLine($"{member.MemberName} = /* required */ obj.Get<{member.Type.FullyQualifiedName}>({GetLocalPropertyNameRef(member)}),");
					}
					else
					{
						sb.AppendLine($"{member.MemberName} = /* else */ obj.Get<{member.Type.FullyQualifiedNameAnnotated}>({GetLocalPropertyNameRef(member)}, {member.DefaultLiteral}!),");
					}
				}
				sb.LeaveBlock(semicolon: true);
				sb.LeaveBlock();
				sb.NewLine();
			}

			private void WritePackMethod(CSharpCodeBuilder sb, CrystalJsonTypeMetadata typeDef)
			{
				sb.AppendLine("/// <inheritdoc />");
				sb.AppendLine($"public {KnownTypeSymbols.JsonValueFullName} Pack({typeDef.Type.FullyQualifiedNameAnnotated} instance, {KnownTypeSymbols.CrystalJsonSettingsFullName}? settings = default, {KnownTypeSymbols.ICrystalJsonTypeResolverFullName}? resolver = default)");
				sb.EnterBlock("Pack");

				if (!typeDef.Type.IsValueType())
				{ // ref types can be null, we will return JsonNull.Null in this case
					sb.AppendLine("if (instance is null)");
					sb.EnterBlock();
					sb.AppendLine($"return {KnownTypeSymbols.JsonNullFullName}.Null;");
					sb.LeaveBlock();
					sb.NewLine();
				}

				// if the type is polymorphic, we have to dispatch to the corresponding serializer
				if (typeDef.IsPolymorphic)
				{
					sb.AppendLine("switch(instance)");
					sb.EnterBlock();
					foreach (var (_, derivedType, _) in typeDef.DerivedTypes)
					{
						if (derivedType.IsAbstract) continue; // skip abstract types
						//BUGBUG: TODO: we may need to sort the types from most specific to less specific, ex: "case Greyhound" then "case Dog", otherwise "case Dog" would match all Greyhound instances if evaluated first!
						//note: if we compute the "depth" of each type (from the top most abstract class or interface), we could simply sort them from highest to lowest!
						sb.AppendLine($"case {derivedType.FullyQualifiedName} x: return {GetLocalSerializerRef(derivedType)}.Pack(x, settings, resolver);");
					}
					sb.AppendLine($"default: throw {KnownTypeSymbols.JsonSerializationExceptionFullName}.CannotPackDerivedTypeWithUnknownTypeDiscriminator(instance.GetType(), typeof({typeDef.Type.FullyQualifiedName}));");
					sb.LeaveBlock();

					sb.LeaveBlock("Pack");
					sb.NewLine();
					return;
				}

				bool hasPolymorphicDefinition = this.PolymorphicMap.TryGetValue(typeDef.Type.Ref, out var polymorphicMetadata);

				if (typeDef.Type.IsAbstract)
				{ // do we have a parent ?
					if (hasPolymorphicDefinition)
					{ // defer to the parent type which should have all the derived types under this one
						//REVIEW: TODO: we _could_ optimize by having a smaller switch with only de types under us?
						sb.AppendLine($"return {GetLocalSerializerRef(polymorphicMetadata.Parent)}.Pack(instance, settings, resolver);");
						sb.LeaveBlock("Pack");
						sb.NewLine();
						return;
					}
				}

				// if the type is not sealed, we may have a derived type, we must defer serialization to this type!
				if (!typeDef.Type.IsSealed)
				{
					//BUGBUG: TODO: detect if we have a generated serialize for this derived type?
					sb.AppendLine($"if (instance.GetType() != typeof({typeDef.Type.FullyQualifiedName}))");
					sb.EnterBlock();
					sb.AppendLine($"throw {KnownTypeSymbols.JsonSerializationExceptionFullName}.CannotPackDerivedTypeWithUnknownTypeDiscriminator(instance.GetType(), typeof({typeDef.Type.FullyQualifiedName}));");
					sb.LeaveBlock("Pack");
					sb.NewLine();
				}

				sb.AppendLine($"var obj = new {KnownTypeSymbols.JsonObjectFullName}({typeDef.Members.Count});");
				sb.NewLine();

				if (hasPolymorphicDefinition)
				{
					sb.Comment("Add the discriminator property for this derived type");
					var typeDiscriminatorPropertyName = polymorphicMetadata.Parent.TypeDiscriminatorPropertyName ?? "$type";
					if (polymorphicMetadata.Discriminator is string s)
					{
						sb.AppendLine($"obj[{CSharpCodeBuilder.Constant(typeDiscriminatorPropertyName)}] = {CSharpCodeBuilder.Constant(s)};"); //TODO: create a static readonly for the JsonString!
					}
					else if (polymorphicMetadata.Discriminator is int n)
					{
						sb.AppendLine($"obj[{typeDiscriminatorPropertyName}] = {CSharpCodeBuilder.Constant(n)};"); //TODO: create a static readonly for the JsonNumber!
					}
					else if (polymorphicMetadata.Discriminator is null)
					{
						sb.AppendLine($"#error You must specify a valid type discriminator for derived type {typeDef.Name} of parent type {polymorphicMetadata.Parent.Name}");
					}
					else
					{
						sb.AppendLine($"#error Invalid discriminator value type for derived type {typeDef.Name} of parent type {polymorphicMetadata.Parent.Name}");
					}
					sb.NewLine();
				}

				foreach (var member in typeDef.Members)
				{
					sb.Comment($"\"{member.Name}\" => {member.Type.FullName}{(member.IsNullableRefType() ? "?" : "")} {member.MemberName}{(member.IsKey ? ", KEY" : "")}{(member.IsField ? ", field" : ", prop")}{(member.IsRequired ? ", required" : "")}{(member.IsInitOnly ? ", initOnly" : member.IsReadOnly ? ", readOnly" : "")}");

					var getterExpr = $"instance.{member.MemberName}"; //TODO: maybe use unsafe accessors for some fields?
					var packerExpr = GetMemberPackerExpression(member, getterExpr);

					if (member.Type.IsNullableOfT())
					{
						sb.AppendLine($"obj.AddIfNotNull({GetLocalPropertyNameRef(member)}, {packerExpr});");
					}
					else if (member.IsNotNull)
					{
						sb.AppendLine($"obj.Add({GetLocalPropertyNameRef(member)}, {packerExpr});");
					}
					else
					{
						sb.AppendLine($"obj.AddIfNotNull({GetLocalPropertyNameRef(member)}, {packerExpr});");
					}
					sb.NewLine();
				}
				sb.AppendLine($"return settings.IsReadOnly() ? {KnownTypeSymbols.CrystalJsonMarshallFullName}.FreezeTopLevel(obj) : obj;");
				sb.LeaveBlock("Pack");
				sb.NewLine();
			}

			private void WriteSerializeMethod(CSharpCodeBuilder sb, CrystalJsonTypeMetadata typeDef, string typeFullName)
			{

				sb.AppendLine($"public void Serialize({KnownTypeSymbols.CrystalJsonWriterFullName} writer, {typeDef.Type.FullyQualifiedName}{(typeDef.Type.IsValueType() ? "" : "?")} instance)");
				sb.EnterBlock("Serialize()");

				if (!typeDef.Type.IsValueType())
				{ // ref types can be null, we will write "null" in this case
					sb.AppendLine("if (instance is null)");
					sb.EnterBlock();
					sb.AppendLine("writer.WriteNull();");
					sb.AppendLine("return;");
					sb.LeaveBlock();
				}

				//TODO: handle IJsonSerializer<T> and IJsonSerializable

				// if the type is polymorphic, we have to dispatch to the corresponding serializer
				if (typeDef.IsPolymorphic)
				{
					sb.AppendLine("switch(instance)");
					sb.EnterBlock();
					foreach (var (_, derivedType, _) in typeDef.DerivedTypes)
					{
						if (derivedType.IsAbstract) continue;
						sb.AppendLine($"case {derivedType.FullyQualifiedName} x: {GetLocalSerializerRef(derivedType)}.Serialize(writer, x); break;");
					}
					sb.AppendLine($"default: throw {KnownTypeSymbols.JsonSerializationExceptionFullName}.CannotSerializeDerivedTypeWithoutTypeDiscriminator(instance.GetType(), typeof({typeFullName}));");
					sb.LeaveBlock();

					sb.LeaveBlock("Serialize()");
					sb.NewLine();
					return;
				}

				bool hasPolymorphicDefinition = this.PolymorphicMap.TryGetValue(typeDef.Type.Ref, out var polymorphicMetadata);

				if (typeDef.Type.IsAbstract)
				{ // do we have a parent ?
					if (hasPolymorphicDefinition)
					{ // defer to the parent type which should have all the derived types under this one
						//REVIEW: TODO: we _could_ optimize by having a smaller switch with only de types under us?
						sb.AppendLine($"{GetLocalSerializerRef(polymorphicMetadata.Parent)}.Serialize(writer, instance);");
						sb.LeaveBlock("Serialize()");
						sb.NewLine();
						return;
					}
				}

				// if the type is not sealed, we may have a derived type, we must defer serialization to this type!
				if (!typeDef.Type.IsSealed)
				{
					//TODO: we should have a local method that can dispatch known types!
					sb.AppendLine($"if (instance.GetType() != typeof({typeFullName}))");
					sb.EnterBlock();
					sb.AppendLine("throw new NotSupportedException(\"Cannot serialize a polymorphic type. You must add at least one [JsonDerivedType] to the base class or interface.\");");
					//sb.AppendLine($"{KnownTypeSymbols.CrystalJsonVisitorFullName}.VisitValue(instance, typeof({typeFullName}), writer);");
					//sb.AppendLine("return;");
					sb.LeaveBlock();
					sb.NewLine();
				}

				sb.AppendLine("var state = writer.BeginObject();");

				if (hasPolymorphicDefinition)
				{
					sb.Comment("Add the discriminator property for this derived type");
					var typeDiscriminatorPropertyName = polymorphicMetadata.Parent.TypeDiscriminatorPropertyName ?? "$type";
					if (polymorphicMetadata.Discriminator is string s)
					{
						sb.AppendLine($"writer.WriteField({CSharpCodeBuilder.Constant(typeDiscriminatorPropertyName)}, {CSharpCodeBuilder.Constant(s)});");
					}
					else if (polymorphicMetadata.Discriminator is int n)
					{
						sb.AppendLine($"writer.WriteField({typeDiscriminatorPropertyName}, {CSharpCodeBuilder.Constant(n)});");
					}
					else
					{
						sb.AppendLine("#error Invalid discriminator value type");
					}
				}

				foreach (var member in typeDef.Members)
				{
					this.WriteMemberSerializer(sb, member);
				}
				sb.AppendLine("writer.EndObject(state);");
				sb.LeaveBlock("Serialize()");
				sb.NewLine();
			}

			private string GetMemberPackerExpression(CrystalJsonMemberMetadata member, string getterExpr)
			{
				if (IsLocallyGeneratedType(member.Type, out var target))
				{
					return $"/* local-serializer */ {GetLocalSerializerRef(target)}.Pack({getterExpr}, settings, resolver)";
				}

				// unwrap any Nullable<T> (most packing methods handle both!)
				var concreteType = member.Type.NullableOfType ?? member.Type;
				if (concreteType.IsBooleanLike())
				{
					return $"/* fast-boolean */ {KnownTypeSymbols.JsonBooleanFullName}.Return({getterExpr})";
				}
				if (concreteType.IsStringLike())
				{
					return $"/* fast-string */ {KnownTypeSymbols.JsonStringFullName}.Return({getterExpr})";
				}
				if (concreteType.IsNumberLike())
				{
					return $"/* fast-number */ {KnownTypeSymbols.JsonNumberFullName}.Return({getterExpr})";
				}
				if (concreteType.IsDateLike())
				{
					return $"/* fast-date */ {KnownTypeSymbols.JsonDateTimeFullName}.Return({getterExpr})";
				}

				if (member.Type.JsonType is not JsonPrimitiveType.None)
				{
					// it's already a JSON value, but we may need to convert it to readonly!
					return $"/* fast-json */ settings.IsReadOnly() ? ({getterExpr})?.ToReadOnly() : ({getterExpr})";
				}

				if (concreteType.JsonType is not JsonPrimitiveType.None)
				{
					return $"/* direct-json-value */ {getterExpr}";
				}

				if (concreteType.IsJsonPackable)
				{
					return $"/* packable */ {KnownTypeSymbols.JsonValueFullName}.FromValue({getterExpr}, settings, resolver)";
				}

				if (concreteType.IsDictionary(out var keyType, out var valueType))
				{
					if (keyType.IsString())
					{
						if (IsLocallyGeneratedType(valueType, out target))
						{
							return $"/* local-dict */ {GetLocalSerializerRef(target)}.JsonPackObject({getterExpr}, settings, resolver)";
						}
						if (!valueType.IsValueType())
						{
							return $"/* fallback-dict */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackEnumerable({getterExpr}, settings, resolver)";
						}
					}
					//else: int? other well known type?
				}
				else if (concreteType.IsEnumerable(out var elemType))
				{
					// if the elem type is a local type, we will use the generated serializer
					if (IsLocallyGeneratedType(elemType, out target))
					{
						if (concreteType.IsArray())
						{
							return $"/* local-pack-array */ {GetLocalSerializerRef(target)}.JsonPackArray({getterExpr}, settings, resolver)";
						}
						if (concreteType.IsList())
						{
							return $"/* local-pack-list */ {GetLocalSerializerRef(target)}.JsonPackList({getterExpr}, settings, resolver)";
						}
						if (!elemType.IsValueType())
						{
							return $"/* local-pack-enumerable */ {GetLocalSerializerRef(target)}.JsonPackEnumerable({getterExpr}, settings, resolver)";
						}
					}
					else if (elemType.IsPrimitive)
					{ // for primitive types, we should have a fast direct implementation
						if (concreteType.IsArray())
						{
							return $"/* fast-pack-array */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackArray({getterExpr}, settings, resolver)";
						}
						if (concreteType.IsList())
						{
							return $"/* fast-pack-list */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackList({getterExpr}, settings, resolver)";
						}
						if (!concreteType.IsValueType())
						{
							return $"/* fast-pack-enumerable */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackEnumerable({getterExpr}, settings, resolver)";
						}
					}
					else
					{ // otherwise, use runtime serialization
						if (concreteType.IsArray())
						{
							return $"/* fallback-pack-array */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackArray({getterExpr}, settings, resolver)";
						}
						if (concreteType.IsList())
						{
							return $"/* fallback-pack-list */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackList({getterExpr}, settings, resolver)";
						}
						if (!concreteType.IsValueType())
						{
							return $"/* fallback-pack-enumerable */ {KnownTypeSymbols.JsonSerializerExtensionsFullName}.JsonPackEnumerable({getterExpr}, settings, resolver)";
						}
					}
				}

				return $"/* fallback */ {KnownTypeSymbols.JsonValueFullName}.FromValue({getterExpr}, settings, resolver)";
			}

			private static bool IsFastPathSerializable(TypeMetadata type)
			{
				// Note: we assume we always have Nullable<T> variants helpers in the fast path!
				type = type.NullableOfType ?? type;

				switch (type.SpecialType)
				{
					case SpecialType.System_Boolean:
					case SpecialType.System_Char:
					case SpecialType.System_SByte:
					case SpecialType.System_Byte:
					case SpecialType.System_Int16:
					case SpecialType.System_UInt16:
					case SpecialType.System_Int32:
					case SpecialType.System_UInt32:
					case SpecialType.System_Int64:
					case SpecialType.System_UInt64:
					case SpecialType.System_Decimal:
					case SpecialType.System_Single:
					case SpecialType.System_Double:
					case SpecialType.System_String:
					case SpecialType.System_DateTime:
					{
						return true;
					}
				}

				if (type.NameSpace == "System")
				{
					switch (type.Name)
					{
						case nameof(DateTimeOffset):
						case nameof(Guid):
						case "DateOnly":
						case "TimeOnly":
						case "Int128":
						case "UInt128":
						case "Half":
						{
							return true;
						}
					}
				}

				if (type.NameSpace == "NodaTime")
				{
					switch (type.Name)
					{
						case "Instant":
						case "Duration":
						//TODO: add more!
						{
							return true;
						}
					}
				}

				return false;
			}

			/// <summary>Test if a type has some locally generated serialization methods</summary>
			private bool IsLocallyGeneratedType(TypeRef type, out CrystalJsonTypeMetadata metadata)
				=> this.TypeMap.TryGetValue(type, out metadata);

			/// <summary>Test if a type has some locally generated serialization methods</summary>
			private bool IsLocallyGeneratedType(TypeMetadata type, out CrystalJsonTypeMetadata metadata)
				=> this.IsLocallyGeneratedType(type.Ref, out metadata);

			private void WriteMemberSerializer(CSharpCodeBuilder sb, CrystalJsonMemberMetadata member)
			{
				sb.NewLine();
				sb.Comment($"{member.Type.Name} {member.MemberName} => \"{member.Name}\"");

				var propertyName = GetPropertyEncodedNameRef(member);

				if (IsFastPathSerializable(member.Type))
				{
					// there is a dedicated method for this type
					sb.AppendLine($"writer.WriteField({propertyName}, instance.{member.MemberName}); // fast-path");
					return;
				}

				if (IsLocallyGeneratedType(member.Type, out var subDef))
				{ // we have a local generated serializer for this!
					sb.AppendLine($"writer.WriteField({propertyName}, instance.{member.MemberName}, {this.GetLocalSerializerRef(subDef)}); // local-serializer");
					return;
				}

				if (member.Type.SpecialType == SpecialType.System_Nullable_T)
				{
					sb.AppendLine("// nullable!");
				}

				//TODO: test if implements IJsonSerializable

				//TODO: test if this is a dictionary type

				//TODO: test if this is an enumerable type

				// fallback to invoking the generic WriteField<T>(...) method
				sb.AppendLine($"writer.WriteField({propertyName}, instance.{member.MemberName}); // fallback");
			}

		}

	}

}
