#region Copyright (c) 2023-2025 SnowBank SAS
//
// All rights are reserved. Reproduction or transmission in whole or in part, in
// any form or by any means, electronic, mechanical or otherwise, is prohibited
// without the prior written consent of the copyright owner.
//
#endregion

namespace SnowBank.Text
{
	using System.Buffers;
	using System.Buffers.Binary;
	using System.Text;

	/// <summary>Helper type for using the <b>Base-1024</b> encoding</summary>
	/// <remarks>
	/// <para>The Base-1024 encoding represents a span of bytes into a Unicode string that packs 10 input bits into each character, and that will preserve the ordering (when using ordinal sorting rules)</para>
	/// <para>String literals generated by this encoding will use a range of code points from <c>48</c> (<c>\u0030</c>, or the Digit Zero '<c>0</c>') to <c>1071</c> (<c>\u042f</c> or the Cyrillic Capital Letter Ya '<c>Я</c>').</para>
	/// <para>
	/// When converting values (integers, uuids, ...) with this encoding, please ensure that you are using <b>big-endian</b> encoding,
	/// as well as <b>identically sized</b> intermediate byte representation!
	/// Comparing differently-size buffers may not preserve the initial ordering.
	/// </para>
	/// <para>For example: <c>(int) 0x1234</c> and <c>(long) 0x1234</c> will be represented as <c>00001234</c> and <c>0000000000001234</c> that encodes to <c>"00ŤȰ!"</c> and <c>"00000}°"</c>.</para>
	/// <para>If unsure, always use the largest possible byte size for the intermediate representation.</para>
	/// </remarks>
	[PublicAPI]
	public static class Base1024Encoding
	{

		/// <summary>Offset from the 0-byte to the corresponding character</summary>
		private const int CHAR_OFFSET = 48; // '0'

		/// <summary>Computes the number of characters required to encode a given number of bytes into Base-1024</summary>
		/// <param name="byteCount">Size in bytes of the input</param>
		/// <returns>Size in characters of the encoded output</returns>
		/// <remarks>Encoding requires, on average, 4 characters per 5 input bytes.</remarks>
		[Pure]
		public static int GetCharCount(int byteCount)
		{
			int completeChunks = byteCount / 5;
			int extraBytes = byteCount % 5;
			int minimumChars = checked(completeChunks * 4 + (((extraBytes * 8) + 9) / 10) + (extraBytes == 4 ? 1 : 0));
			return minimumChars;
		}

		/// <summary>Encodes a <see cref="int"/> into a Base-1024 string literal</summary>
		/// <param name="value">Value to encode</param>
		/// <returns>String literal that preserves the ordering the of input value</returns>
		/// <remarks>
		/// <para>Strings generated by this method can be compared to other strings generated from inputs of 4 bytes using big-endian encoding. Comparisons with differently sized inputs will produce an invalid ordering!</para>
		/// </remarks>
		[Pure]
		public static string EncodeInt32Value(int value)
		{
			Span<byte> tmp = stackalloc byte[4];
			BinaryPrimitives.WriteInt32BigEndian(tmp, value);
			return Encode(tmp);
		}

		/// <summary>Encodes a <see cref="uint"/> into a Base-1024 string literal</summary>
		/// <param name="value">Value to encode</param>
		/// <returns>Encoded string literal that preserves the ordering of the input value</returns>
		/// <remarks>
		/// <para>Strings generated by this method can be compared to other strings generated from inputs of 4 bytes using big-endian encoding. Comparisons with differently sized inputs will produce an invalid ordering!</para>
		/// </remarks>
		[Pure]
		public static string EncodeUInt32Value(uint value)
		{
			Span<byte> tmp = stackalloc byte[4];
			BinaryPrimitives.WriteUInt32BigEndian(tmp, value);
			return Encode(tmp);
		}

		/// <summary>Encodes a <see cref="long"/> into a Base-1024 string literal</summary>
		/// <param name="value">Value to encode</param>
		/// <returns>Encoded string literal that preserves the ordering of the input value</returns>
		/// <remarks>
		/// <para>Strings generated by this method can be compared to other strings generated from inputs of 8 bytes using big-endian encoding. Comparisons with differently sized inputs will produce an invalid ordering!</para>
		/// </remarks>
		[Pure]
		public static string EncodeInt64Value(long value)
		{
			Span<byte> tmp = stackalloc byte[8];
			BinaryPrimitives.WriteInt64BigEndian(tmp, value);
			return Encode(tmp);
		}

		/// <summary>Encodes a <see cref="ulong"/> into a Base-1024 string literal</summary>
		/// <param name="value">Value to encode</param>
		/// <returns>Encoded string literal that preserves the ordering of the input value</returns>
		/// <remarks>
		/// <para>Strings generated by this method can be compared to other strings generated from inputs of 8 bytes using big-endian encoding. Comparisons with differently sized inputs will produce an invalid ordering!</para>
		/// </remarks>
		[Pure]
		public static string EncodeUInt64Value(ulong value)
		{
			Span<byte> tmp = stackalloc byte[8];
			BinaryPrimitives.WriteUInt64BigEndian(tmp, value);
			return Encode(tmp);
		}

		/// <summary>Encodes a <see cref="Guid"/> into a Base-1024 string literal</summary>
		/// <param name="value">Value to encode</param>
		/// <returns>Encoded string literal that preserves the ordering of the input value</returns>
		/// <remarks>
		/// <para>Strings generated by this method can be compared to other strings generated from inputs of 16 bytes using big-endian encoding. Comparisons with differently sized inputs will produce an invalid ordering!</para>
		/// </remarks>
		[Pure]
		public static string EncodeGuidValue(Guid value) => EncodeUuid128Value((Uuid128)value);

		/// <summary>Encodes a <see cref="Uuid128"/> into a Base-1024 string literal</summary>
		/// <param name="value">Value to encode</param>
		/// <returns>Encoded string literal that preserves the ordering of the input value</returns>
		/// <remarks>
		/// <para>Strings generated by this method can be compared to other strings generated from inputs of 16 bytes using big-endian encoding. Comparisons with differently sized inputs will produce an invalid ordering!</para>
		/// </remarks>
		[Pure]
		public static string EncodeUuid128Value(Uuid128 value)
		{
			Span<byte> tmp = stackalloc byte[16];
			value.WriteTo(tmp);
			return Encode(tmp);
		}

		/// <summary>Encodes a <see cref="Uuid128"/> into a Base-1024 string literal</summary>
		/// <param name="value">Value to encode</param>
		/// <returns>Encoded string literal that preserves the ordering of the input value</returns>
		/// <remarks>
		/// <para>The input string will be encoded into UTF-8 bytes first, and then these bytes will be encoded by calling <seealso cref="Encode(System.ReadOnlySpan{byte})"/></para>
		/// <para>Strings generated by this method can be compared to other strings if they also represented ASCII or UTF-8 encoded "text"</para>
		/// </remarks>
		public static string EncodeUtf8StringValue(string value) => EncodeUtf8StringValue(value.AsSpan());

		/// <summary>Encodes a <see cref="Uuid128"/> into a Base-1024 string literal</summary>
		/// <param name="value">Value to encode</param>
		/// <returns>Encoded string literal that preserves the ordering of the input value</returns>
		/// <remarks>
		/// <para>The input string will be encoded into UTF-8 bytes first, and then these bytes will be encoded by calling <seealso cref="Encode(System.ReadOnlySpan{byte})"/></para>
		/// <para>Strings generated by this method can be compared to other strings if they also represented ASCII or UTF-8 encoded "text"</para>
		/// </remarks>
		public static string EncodeUtf8StringValue(ReadOnlySpan<char> value)
		{
			int capacity = Encoding.UTF8.GetByteCount(value);
			byte[]? buffer = null;
			Span<byte> tmp = capacity <= 256 ? stackalloc byte[capacity] : (buffer = ArrayPool<byte>.Shared.Rent(capacity));

			if (System.Text.Unicode.Utf8.FromUtf16(value, tmp, out _, out int bytesWritten) != OperationStatus.Done)
			{ // should never happen
				throw new InvalidOperationException();
			}

			var result = Encode(tmp[..bytesWritten]);

			if (buffer != null)
			{
				ArrayPool<byte>.Shared.Return(buffer);
			}

			return result;
		}

		/// <summary>Encodes an array of bytes into a Base-1024 string literal</summary>
		/// <param name="source">Bytes to encode</param>
		/// <returns>Encoded string literal that preserves the ordering of the input value</returns>
		public static string Encode(byte[] source) => Encode(source.AsSpan());

		/// <summary>Encodes a <see cref="Slice"/> into a Base-1024 string literal</summary>
		/// <param name="source">Bytes to encode</param>
		/// <returns>Encoded string literal that preserves the ordering of the input value</returns>
		public static string Encode(Slice source) => Encode(source.Span);

		/// <summary>Encodes a span of bytes into a Base-1024 string literal</summary>
		/// <param name="source">Bytes to encode</param>
		/// <returns>Encoded string literal that preserves the ordering of the input value</returns>
		public static string Encode(ReadOnlySpan<byte> source)
		{
			// compute the required capacity, and allocate a buffer
			int capacity = GetCharCount(source.Length);

			// => use the stack for small buffers, otherwise allocate from a pool
			char[]? buffer = null;
			Span<char> output = capacity <= 128 ? stackalloc char[capacity] : (buffer = ArrayPool<char>.Shared.Rent(capacity));

			if (!TryEncodeTo(source, output, out var charsWritten) || charsWritten > capacity)
			{ // should not happen, unless the capacity computation is broken!
#if DEBUG
				if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break();
#endif
				throw new InvalidOperationException();
			}

			var result = output[..charsWritten].ToString();

			if (buffer is not null)
			{ // return rented buffer to the pool!
				ArrayPool<char>.Shared.Return(buffer);
			}

			return result;
		}

		/// <summary>Encodes a span of bytes into a Base-1024 string literal into a destination buffer</summary>
		/// <param name="source">Bytes to encode</param>
		/// <param name="destination">Destination buffer, which should be large enough</param>
		/// <param name="charsWritten">If successful, receives the number of bytes written to <paramref name="destination"/></param>
		/// <returns><c>false</c> if <paramref name="destination"/> was not large enough; otherwise, <c>true</c>.</returns>
		/// <remarks>The caller can determine the minimum buffer capacity by calling <seealso cref="GetByteCount"/>.</remarks>
		public static bool TryEncodeTo(Slice source, Span<char> destination, out int charsWritten)
			=> TryEncodeTo(source.Span, destination, out charsWritten);

		public static bool TryEncodeTo(ReadOnlySpan<byte> source, Span<char> destination, out int charsWritten)
		{
			charsWritten = 0;

			// Incomplete chunks will use padding
			// > 1 extra byte
			//   - 0: 00000000__
			// > 2 extra bytes
			//   - 0: 0000000011
			//   - 1:           111111____
			// > 3 extra bytes
			//   - 0: 0000000011
			//   - 1:           1111112222
			//   - 2:                     2222______
			// > 4 extra bytes
			//   - 0: 0000000011
			//   - 1:           1111112222
			//   - 2:                     2222333333
			//   - 3:                               33________
			// Chunks of 5 inputs bytes will be encoded into 4 output bytes
			// > 5 bytes
			//   - 0: 0000000011
			//   - 1:           1111112222
			//   - 2:                     2222333333
			//   - 3:                               3344444444

			int minimumChars = GetCharCount(source.Length);
			if (destination.Length < minimumChars)
			{
				return false;
			}

			while (source.Length >= 5)
			{
				// first chunk
				destination[0] =  (char) ((((source[0] & 0xFF) << 2) | (source[1] >> 6)) + CHAR_OFFSET);
				destination[1]  = (char) ((((source[1] & 0x3F) << 4) | (source[2] >> 4)) + CHAR_OFFSET);
				destination[2]  = (char) ((((source[2] & 0x0F) << 6) | (source[3] >> 2)) + CHAR_OFFSET);
				destination[3]  = (char) ((((source[3] & 0x03) << 8) | (source[4] >> 0)) + CHAR_OFFSET);

				source = source[5..];
				destination = destination[4..];
				charsWritten += 4;
			}

			switch (source.Length)
			{
				case 1:
				{
					Contract.Debug.Assert(destination.Length >= 1);
					destination[0]  = (char) ((((source[0] & 0xFF) << 2)) + CHAR_OFFSET);
					charsWritten += 1;
					break;
				}
				case 2:
				{
					Contract.Debug.Assert(destination.Length >= 2);
					destination[0] =  (char) ((((source[0] & 0xFF) << 2) | (source[1] >> 6)) + CHAR_OFFSET);
					destination[1]  = (char) ((((source[1] & 0x3F) << 4)) + CHAR_OFFSET);
					charsWritten += 2;
					break;
				}
				case 3:
				{
					Contract.Debug.Assert(destination.Length >= 3);
					destination[0] =  (char) ((((source[0] & 0xFF) << 2) | (source[1] >> 6)) + CHAR_OFFSET);
					destination[1]  = (char) ((((source[1] & 0x3F) << 4) | (source[2] >> 4)) + CHAR_OFFSET);
					destination[2]  = (char) ((((source[2] & 0x0F) << 6)) + CHAR_OFFSET);
					charsWritten += 3;
					break;
				}
				case 4:
				{
					Contract.Debug.Assert(destination.Length >= 4);
					destination[0] =  (char) ((((source[0] & 0xFF) << 2) | (source[1] >> 6)) + CHAR_OFFSET);
					destination[1]  = (char) ((((source[1] & 0x3F) << 4) | (source[2] >> 4)) + CHAR_OFFSET);
					destination[2]  = (char) ((((source[2] & 0x0F) << 6) | (source[3] >> 2)) + CHAR_OFFSET);
					destination[3]  = (char) ((((source[3] & 0x03) << 8)) + CHAR_OFFSET);
					destination[4] = '!'; // add the special marker to mark the last chunk as 'incomplete'
					charsWritten += 5;
					break;
				}
			}

			Contract.Debug.Ensures(charsWritten == minimumChars);

			return true;
		}

		/// <summary>Computes the minimum capacity (in bytes) to decode a given Base-1024 string literal</summary>
		/// <param name="source">String literal that needs to be decoded</param>
		/// <returns>Minimum buffer size (in bytes) required to decode the entire string.</returns>
		/// <remarks>Decoding requires, on average, 5 bytes per 4 input characters.</remarks>
		public static int GetByteCount(ReadOnlySpan<char> source)
		{
			bool hasEndMarker = source[^1] == '!';
			int len = source.Length;
			if (hasEndMarker)
			{
				--len;
			}
			if (len <= 0)
			{
				return 0;
			}

			// each chunk of 4 characters is decoded as 5 output bytes, except if this is the last chunk and 'hasEndMarker' is true, in which case only 4 output bytes will be emitted.
			int completeChunks = len / 4;
			int extraBytes = len % 4;
			if (hasEndMarker && extraBytes == 0)
			{
				--completeChunks;
				extraBytes = 4;
			}

			return checked(completeChunks * 5 + extraBytes);
		}

		public static int DecodeInt32Value(ReadOnlySpan<char> source)
			=> Decode<int>(source, (buffer) => BinaryPrimitives.ReadInt32BigEndian(buffer));

		public static uint DecodeUInt32Value(ReadOnlySpan<char> source)
			=> Decode<uint>(source, (buffer) => BinaryPrimitives.ReadUInt32BigEndian(buffer));

		public static long DecodeInt64Value(ReadOnlySpan<char> source)
			=> Decode<long>(source, (buffer) => BinaryPrimitives.ReadInt64BigEndian(buffer));

		public static ulong DecodeUInt64Value(ReadOnlySpan<char> source)
			=> Decode<ulong>(source, (buffer) => BinaryPrimitives.ReadUInt64BigEndian(buffer));

		public static Guid DecodeGuidValue(ReadOnlySpan<char> source)
			=> Decode<Guid>(source, (buffer) => Uuid128.Read(buffer));

		public static Uuid128 DecodeUuid128Value(ReadOnlySpan<char> source)
			=> Decode<Uuid128>(source, (buffer) => (Uuid128) Uuid128.Read(buffer));

		public static Uuid96 DecodeUuid96Value(ReadOnlySpan<char> source)
			=> Decode<Uuid96>(source, (buffer) => Uuid96.Read(buffer));

		public static Uuid80 DecodeUuid80Value(ReadOnlySpan<char> source)
			=> Decode<Uuid80>(source, (buffer) => Uuid80.Read(buffer));

		public static Uuid64 DecodeUuid64Value(ReadOnlySpan<char> source)
			=> Decode<Uuid64>(source, (buffer) => Uuid64.Read(buffer));

#if !NET9_0_OR_GREATER

		public delegate TResult SpanDecoder<TResult>(ReadOnlySpan<byte> buffer);

#endif

		public static TResult Decode<TResult>(
			ReadOnlySpan<char> source,
#if NET9_0_OR_GREATER
			Func<ReadOnlySpan<byte>, TResult> decoder
#else
			SpanDecoder<TResult> decoder
#endif
		)
		{
			// compute the required capacity, and allocate a buffer
			int capacity = GetByteCount(source);

			byte[]? buffer = null;
			var tmp = capacity <= 256 ? stackalloc byte[capacity] : ArrayPool<byte>.Shared.Rent(capacity);

			if (!TryDecodeTo(source, tmp, out int bytesWritten))
			{
				throw new FormatException("Failed to decode Base-1024 string literal");
			}

			var result = decoder(tmp[..bytesWritten]);

			if (buffer is not null)
			{
				ArrayPool<byte>.Shared.Return(buffer);
			}

			return result;
		}

		public static Slice Decode(string source) => Decode(source.AsSpan());

		public static Slice Decode(ReadOnlySpan<char> source)
		{
			// compute the required capacity, and allocate a buffer
			int capacity = GetByteCount(source);

			// => use the stack for small buffers, otherwise allocate from a pool
			var buffer = new byte[capacity];

			if (!TryDecodeTo(source, buffer, out var bytesWritten) || bytesWritten > capacity)
			{ // should not happen, unless the capacity computation is broken!
#if DEBUG
				if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break();
#endif
				throw new InvalidOperationException();
			}

			return buffer.AsSlice(0, bytesWritten);
		}

		public static bool TryDecodeTo(ReadOnlySpan<char> source, Span<byte> output, out int bytesWritten)
		{
			bytesWritten = 0;

			// If the last character is '!', then it means the last chunk has only 3 bytes
			// => the '!' should be then be discarded in the rest of the computation

			bool hasEndMarker = source[^1] == '!';
			if (hasEndMarker)
			{
				source = source[..^1];
			}

			// each chunk of 4 characters is decoded as 5 output bytes, except if this is the last chunk and 'hasEndMarker' is true, in which case only 4 output bytes will be emitted.
			int completeChunks = source.Length / 4;
			int extraBytes = source.Length % 4;
			if (hasEndMarker && extraBytes == 0)
			{
				--completeChunks;
				extraBytes = 4;
			}

			int minimumOutputSize = checked(completeChunks * 5 + extraBytes);
			if (output.Length < minimumOutputSize)
			{ // output buffer is too small!
				return false;
			}

			// Incomplete chunks have internal padding ('x' are discarded output bytes, '_' are padding bits that must be 0)
			// > 1 character
			//   - 0: 00000000
			//   - x:         __
			// > 2 characters
			//   - 0: 00000000
			//   - 1:         00111111
			//   - x:                 ____
			// > 3 characters
			//   - 0: 00000000
			//   - 1:         00111111
			//   - 2:                 11112222
			//   - x:                         ______
			// Chunks of 4 inputs characters will be decoded into 4 output bytes
			// > last chunk AND last character equal to '!'
			//   - 0: 00000000
			//   - 1:         00111111
			//   - 2:                 11112222
			//   - 3:                         22222233
			//   - x:                                 ________
			// > otherwise
			//   - 0: 00000000
			//   - 1:         00111111
			//   - 2:                 11112222
			//   - 3:                         22222233
			//   - 4:                                 33333333

			while (source.Length > 4)
			{ // full chunk

				int s0 = (source[0] - CHAR_OFFSET);
				int s1 = (source[1] - CHAR_OFFSET);
				int s2 = (source[2] - CHAR_OFFSET);
				int s3 = (source[3] - CHAR_OFFSET);

				output[0]  = (byte)                       (s0 >> 2);
				output[1]  = (byte) (((s0 & 0x03) << 6) | (s1 >> 4));
				output[2]  = (byte) (((s1 & 0x0F) << 4) | (s2 >> 6));
				output[3]  = (byte) (((s2 & 0x3F) << 2) | (s3 >> 8));
				output[4]  = (byte)   (s3 & 0xFF);

				source = source[4..];
				output = output[5..];
				bytesWritten += 5;
			}

			switch (source.Length)
			{
				case 1:
				{
					int s0 = (source[0] - CHAR_OFFSET);
					output[0]  = (byte) (s0 >> 2);
					if ((s0 & 0x03) != 0) goto invalid_padding;
					bytesWritten += 1;
					break;
				}
				case 2:
				{
					int s0 = (source[0] - CHAR_OFFSET);
					int s1 = (source[1] - CHAR_OFFSET);
					output[0]  = (byte)                       (s0 >> 2);
					output[1]  = (byte) (((s0 & 0x03) << 6) | (s1 >> 4));
					if ((s1 & 0x0F) != 0) goto invalid_padding;
					bytesWritten += 2;
					break;
				}
				case 3:
				{
					int s0 = (source[0] - CHAR_OFFSET);
					int s1 = (source[1] - CHAR_OFFSET);
					int s2 = (source[2] - CHAR_OFFSET);
					output[0]  = (byte)                       (s0 >> 2);
					output[1]  = (byte) (((s0 & 0x03) << 6) | (s1 >> 4));
					output[2]  = (byte) (((s1 & 0x0F) << 4) | (s2 >> 6));
					if ((s2 & 0x3F) != 0) goto invalid_padding;
					bytesWritten += 3;
					break;
				}
				case 4 when(hasEndMarker):
				{
					int s0 = (source[0] - CHAR_OFFSET);
					int s1 = (source[1] - CHAR_OFFSET);
					int s2 = (source[2] - CHAR_OFFSET);
					int s3 = (source[3] - CHAR_OFFSET);
					output[0]  = (byte)                       (s0 >> 2);
					output[1]  = (byte) (((s0 & 0x03) << 6) | (s1 >> 4));
					output[2]  = (byte) (((s1 & 0x0F) << 4) | (s2 >> 6));
					output[3]  = (byte) (((s2 & 0x3F) << 2) | (s3 >> 8));
					if ((s3 & 0xFF) != 0) goto invalid_padding;
					bytesWritten += 4;
					break;
				}
				case 4:
				{ // fullchunk
					int s0 = (source[0] - CHAR_OFFSET);
					int s1 = (source[1] - CHAR_OFFSET);
					int s2 = (source[2] - CHAR_OFFSET);
					int s3 = (source[3] - CHAR_OFFSET);
					output[0]  = (byte)                       (s0 >> 2);
					output[1]  = (byte) (((s0 & 0x03) << 6) | (s1 >> 4));
					output[2]  = (byte) (((s1 & 0x0F) << 4) | (s2 >> 6));
					output[3]  = (byte) (((s2 & 0x3F) << 2) | (s3 >> 8));
					output[4]  = (byte)   (s3 & 0xFF);
					bytesWritten += 5;
					break;
				}
			}

			return true;

		invalid_padding:
			bytesWritten = 0;
			return false;
		}

	}

}
