#region Copyright (c) 2023-2024 SnowBank SAS, (c) 2005-2023 Doxense SAS
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 	* Redistributions of source code must retain the above copyright
// 	  notice, this list of conditions and the following disclaimer.
// 	* Redistributions in binary form must reproduce the above copyright
// 	  notice, this list of conditions and the following disclaimer in the
// 	  documentation and/or other materials provided with the distribution.
// 	* Neither the name of SnowBank nor the
// 	  names of its contributors may be used to endorse or promote products
// 	  derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL SNOWBANK SAS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#endregion

namespace FoundationDB.Client
{
	using System;
	using System.Diagnostics;
	using System.Diagnostics.CodeAnalysis;
	using System.Net;

	/// <summary>Represents a FoundationDB network endpoint as an IP address, port number and TLS mode.</summary>
	[DebuggerDisplay("{ToString(),nq}")]
	public sealed class FdbEndPoint : IPEndPoint, IEquatable<FdbEndPoint>
	{

		public static readonly FdbEndPoint Invalid = new(IPAddress.None, 0, false);

		public FdbEndPoint(IPAddress address, int port, bool tls)
			: base(address, port)
		{
			this.Tls = tls;
		}

		/// <summary>Gets or sets the TLS mode of the endpoint.</summary>
		/// <remarks>True if the endpoint uses TLS</remarks>
		public bool Tls { get; }

		/// <summary>Tests if this is a valid endpoint</summary>
		public bool IsValid() => !IPAddress.None.Equals(this.Address) && this.Port > 0;

		public override SocketAddress Serialize()
		{
			// we add a byte (0 = raw, 1 = tls) to the SocketAddress generated by the base

			var tmp = base.Serialize();
			int count = tmp.Size;

			var sockAddr = new SocketAddress(this.AddressFamily, count + 1);

			for (int i = 0; i < count; i++)
			{
				sockAddr[i] = tmp[i];
			}
			sockAddr[count] = this.Tls ? (byte) 1 : (byte) 0;

			return sockAddr;
		}

		public override EndPoint Create(SocketAddress socketAddress)
		{
			//note: this methods constructs a NEW endpoint, and does not change the current instance (why???)

			// Current implementation of IPEndPoint does really check the exact size of the buffer, and should not use the extra byte we added...
			// > Fix this if this is no longer the case in future .NET implementations (or Mono?)
			var tmp = (IPEndPoint) base.Create(socketAddress);

			bool tls = false;
			int count = socketAddress.Size;
			if ((socketAddress.Family == System.Net.Sockets.AddressFamily.InterNetwork && count == 17) || (socketAddress.Family == System.Net.Sockets.AddressFamily.InterNetworkV6 && count == 29))
			{
				tls = socketAddress[count - 1] != 0;
			}

			return new FdbEndPoint(tmp.Address, tmp.Port, tls);
		}

		public override string ToString() => this.Tls ? base.ToString() + ":tls" : base.ToString();

		public override bool Equals(object? other) => other is FdbEndPoint fep && Equals(fep);

		public bool Equals(FdbEndPoint? other) => other != null && other.Tls == this.Tls && base.Equals(other);

		public override int GetHashCode()
		{
			int h = base.GetHashCode();
			return this.Tls ? ~h : h;
		}

		public void Deconstruct(out IPAddress address, out int port)
		{
			address = this.Address;
			port = this.Port;
		}

		public void Deconstruct(out IPAddress address, out int port, out bool tls)
		{
			address = this.Address;
			port = this.Port;
			tls = this.Tls;
		}

		public static bool TryParse(ReadOnlySpan<char> address, [MaybeNullWhen(false)] out FdbEndPoint endpoint)
		{
			if (!Fdb.System.TryParseAddress(address, out var ip, out var port, out var tls))
			{
				endpoint = null;
				return false;
			}

			endpoint = new(ip, port, tls);
			return true;
		}

	}

}
