#region Copyright (c) 2023-2024 SnowBank SAS, (c) 2005-2023 Doxense SAS
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 	* Redistributions of source code must retain the above copyright
// 	  notice, this list of conditions and the following disclaimer.
// 	* Redistributions in binary form must reproduce the above copyright
// 	  notice, this list of conditions and the following disclaimer in the
// 	  documentation and/or other materials provided with the distribution.
// 	* Neither the name of SnowBank nor the
// 	  names of its contributors may be used to endorse or promote products
// 	  derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL SNOWBANK SAS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#endregion

namespace Doxense.Threading.Operations
{
	using System.Runtime.ExceptionServices;
	using Doxense.Messaging.Events;
	using Doxense.Reactive.Disposables;
	using Doxense.Serialization;
	using Microsoft.Extensions.DependencyInjection;
	using Microsoft.Extensions.DependencyInjection.Extensions;
	using Microsoft.Extensions.Logging;
	using OpenTelemetry.Trace;

	/// <summary>Represents the execution context for an asynchronous operation that can be observed from the outside</summary>
	[PublicAPI]
	public interface IOperationContext
	{

		/// <summary>Globally unique identifier for this operation</summary>
		string Id { get; }

		/// <summary>Operation type (for diagnostic purpose)</summary>
		string Type { get; }

		/// <summary>If not null, used to distinguish multiple concurrent operations of the type <see cref="Type"/></summary>
		string? Key { get; }

		/// <summary>If not null, parent operation that started this operation</summary>
		IOperationContext? Parent { get; }

		/// <summary>Scheduler used to orchestrate the execution of this operation</summary>
		IOperationScheduler Scheduler { get; }

		/// <summary>Cancellation token used to abort this operation</summary>
		CancellationToken Cancellation { get; }

		/// <summary>Current state of the operation</summary>
		OperationState State { get; }

		/// <summary>Return the result of the operation, if it completed successfully</summary>
		/// <param name="result">Result of the operation</param>
		/// <param name="type">Type of the result</param>
		/// <returns>Returns <c>true</c> if the operation completed successfully; otherwise, <c>false</c>.</returns>
		bool TryGetResult(out object? result, [MaybeNullWhen(false)] out Type type);

		/// <summary>If not null, error generated by the operation</summary>
		OperationError? Error { get; }

		void Log(LogLevel level, Exception? exception, string message, object?[]? args = null);

		/// <summary>Dispatch an event that happened during the processing of this operation</summary>
		/// <param name="evt"></param>
		void Dispatch(IEvent evt);

		/// <summary>Execute a sub-step, using the same context as this operation</summary>
		/// <param name="id">Id of the sub-step (for computers)</param>
		/// <param name="label">Label of the sub-step (for humans)</param>
		/// <returns>Token that must be disposed at the end of the sub-step</returns>
		/// <remarks>
		/// <para>Sub-steps should be used to wrap the various parts of an operation, that are not large enough to be <see cref="ExecuteSubOperation{TResult}">split into sub-operations.</see>.</para>
		/// <para>They will be exposed to observers who are following the execution.</para>
		/// </remarks>
		IDisposable ExecuteStep(string id, string? label = null);

		/// <summary>Execute a sub-operation, in its own context.</summary>
		/// <typeparam name="TSubResult">Type of the result returned by the sub-operation</typeparam>
		/// <param name="operation">Context of the sub-operation, created as a child of this operation</param>
		/// <param name="handler">Function that will be run to execute the sub-operation</param>
		/// <returns>Result of the sub-operation.</returns>
		Task<OperationResult<TSubResult>> ExecuteSubOperation<TSubResult>(IOperationContext<TSubResult> operation, Func<IOperationContext<TSubResult>, Task<OperationResult<TSubResult>>> handler);
		
		Activity? Activity { get; }
		
	}

	[PublicAPI]
	public interface IOperationContext<TResult> : IOperationContext
	{
		OperationResult<TResult> Failed(OperationError error);

		OperationResult<TResult> Success(TResult result);

		bool TryGetResult([MaybeNullWhen(false)] out TResult result);

	}

	[PublicAPI]
	public enum OperationState
	{
		Invalid = 0,
		Pending,
		Processing,
		Completed,
	}

	/// <summary>Represents the result of the execution of an operation</summary>
	[DebuggerDisplay("Id={Context.Id}, State={Context.State}")]
	[PublicAPI]
	public readonly struct OperationResult<TResult>
	{

		public OperationResult(IOperationContext context)
		{
			this.Context = context;
		}

		public readonly IOperationContext Context;

		public bool HasFailed => this.Context.Error != null;

		public TResult EnsureSuccess()
		{
			if (this.Context.State != OperationState.Completed)
			{
				throw new InvalidOperationException("Operation is not completed yet.");
			}

			if (this.Context.Error != null)
			{
				Context.Error.Exception?.Throw();
				//TODO: map the error to something more specific?
				throw new InvalidOperationException($"Operation failed: [{this.Context.Error.Code}] {this.Context.Error.Message}"); }

			if (!this.Context.TryGetResult(out object? value, out Type? type))
			{
				throw new InvalidOperationException("Operation completed successfully, but does not have a return value.");
			}

			if (!typeof(TResult).IsAssignableFrom(type))
			{
				throw new InvalidOperationException($"Operation completed successfully, but the result type does not match: expected {typeof(TResult).GetFriendlyName()} but was {type.GetFriendlyName()}.");
			}

			if (default(TResult) is null)
			{ // class
				return (TResult) value!;
			}
			else
			{ // valuetype
				return value == null ? default! : (TResult) value;
			}
		}

		public bool Check([MaybeNullWhen(false)] out TResult result, [MaybeNullWhen(true)] out OperationError error)
		{
			if (this.Context.State != OperationState.Completed)
			{
				result = default;
				error = new OperationError { Code = "not_completed", Message = "Operation is not completed yet." };
				return false;
			}

			if (this.Context.Error != null)
			{
				result = default;
				error = this.Context.Error;
				return false;
			}

			if (!this.Context.TryGetResult(out object? value, out Type? type))
			{
				result = default;
				error = new OperationError
				{
					Code = "invalid_result",
					Message = "Operation completed successfully, but does not have a return value."
				};
				return false;
			}

			if (value is not null && !typeof(TResult).IsAssignableFrom(type))
			{
				result = default;
				error = new OperationError
				{
					Code = "invalid_result",
					Message = "Operation completed successfully, but the result type does not match.",
					Details = new { ExpectedType = typeof(TResult).GetFriendlyName(), ActualType = type.GetFriendlyName() }
				};
				return false;
			}

			if (default(TResult) is null)
			{ // class
				result = (TResult) value!;
			}
			else
			{ // valuetype
				result = value == null ? default! : (TResult) value;
			}
			error = null;
			return true;
		}

		public static implicit operator OperationResult<TResult>(OperationFailed failed)
		{
			return new OperationResult<TResult>(failed.Context);
		}

	}

	[PublicAPI]
	public readonly struct OperationFailed
	{

		public readonly IOperationContext Context;

		public OperationFailed(IOperationContext context)
		{
			this.Context = context;
		}

		public OperationError Error => this.Context.Error!;

	}

	[PublicAPI]
	public sealed record OperationError
	{
		public required string Code { get; init; }

		public required string Message { get; init; }

		public ExceptionDispatchInfo? Exception { get; init; }

		public object? Details { get; init; }
	}

	[PublicAPI]
	public sealed class OperationErrorException : Exception
	{

		public OperationErrorException(OperationError error, Exception? inner = null)
			: base(error.Message, inner)
		{
			this.Error = error;
		}

		public OperationErrorException(string code, string message, object? details = null, Exception? exception = null)
		{
			this.Error = new OperationError { Code = code, Message = message, Details = details, Exception = exception != null ? ExceptionDispatchInfo.Capture(exception) : null };
		}

		public OperationErrorException(string code, string message, object? details = null, ExceptionDispatchInfo? exception = null)
		{
			this.Error = new OperationError { Code = code, Message = message, Details = details, Exception = exception };
		}

		public OperationError Error { get; }

	}

	[PublicAPI]
	public interface IStoryBook
	{
		string Type { get; }

		string Recipee { get; }
	}

	[PublicAPI]
	public interface IOperationWorkflow;

	[PublicAPI]
	public interface IOperationWorkflow<in TRequest, TResult> : IOperationWorkflow
	{
		Task<OperationResult<TResult>> ExecuteAsync(TRequest request);
	}

	[PublicAPI]
	public interface IOperationWorkflow<TWorkflow, in TRequest, TResult> : IOperationWorkflow<TRequest, TResult>
		where TWorkflow: IOperationWorkflow<TWorkflow, TRequest, TResult>
	{
		
		//static abstract TWorkflow CreateInstance(IServiceProvider services, string name, IOperationScheduler scheduler, TRequest req, CancellationToken ct);

		//static abstract TWorkflow CreateInstance(IServiceProvider services, IOperationContext<TRequest, TResult> ctx);

	}

	[PublicAPI]
	public abstract class OperationWorkflowBase<TWorkflow, TParameter, TResult> : IOperationWorkflow<TWorkflow, TParameter, TResult>
		where TWorkflow: OperationWorkflowBase<TWorkflow, TParameter, TResult>
	{

		protected IOperationContext<TResult> Context { get; }

		protected OperationWorkflowBase(IOperationContext<TResult> context)
		{
			this.Context = context;
		}

		public Task<OperationResult<TResult>> ExecuteAsync(TParameter request)
		{
			return this.Context.Scheduler.ExecuteOperation<TResult>(this.Context, _ => this.ExecuteInternalAsync(request));
		}

		protected abstract Task<OperationResult<TResult>> ExecuteInternalAsync(TParameter request);

		protected CancellationToken Cancellation => this.Context.Cancellation;

		protected void LogDebug(string message) => this.Context.LogDebug(message);

		protected void LogInformation(string message) => this.Context.LogInformation(message);

		protected void LogWarning(string message) => this.Context.LogWarning(message);

		protected void LogError(string message) => this.Context.LogError(message);

		protected void LogError(Exception e, string message) => this.Context.LogError(e, message);

		protected OperationResult<TResult> Success(TResult result) => this.Context.Success(result);

		protected OperationResult<TResult> Failed(OperationError error) => this.Context.Failed(error);

		protected OperationResult<TResult> Throw(Exception exception) => this.Context.Throw(exception);

		public static TWorkflow CreateInstance(IServiceProvider services, string name, IOperationScheduler scheduler, CancellationToken ct)
		{
			var ctx = scheduler.Create<TResult>(name, null, null, ct);
			return CreateInstance(services, ctx);
		}

		public static TWorkflow CreateInstance(IServiceProvider services, IOperationContext ctx)
		{
			return ActivatorUtilities.CreateInstance<TWorkflow>(services, ctx);
		}

	}

	[PublicAPI]
	public static class OperationContextExtensions
	{

		/// <summary>Register the <see cref="IOperationScheduler"/> and <see cref="IEventBus"/> services</summary>
		public static IServiceCollection AddBackgroundOperations(this IServiceCollection services)
		{
#if DEBUG
			if (services.Any(x => x.ServiceType == typeof(IOperationScheduler)))
			{
				throw new InvalidOperationException("Background operations are already registered!");
			}
#endif
			services.TryAddSingleton<IOperationScheduler, OperationScheduler>();
			services.TryAddSingleton<IEventBus, EventBus>();
			return services;
		}

		public static Task<OperationResult<TResult>> Run<TResult>(this IOperationScheduler scheduler, string type, string? key, Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> handler, CancellationToken ct)
		{
			Contract.NotNull(scheduler);
			Contract.NotNull(type);
			Contract.NotNull(handler);
			return scheduler.ExecuteOperation(scheduler.Create<TResult>(type, key, null, ct), handler);
		}

		public static Task<OperationResult<TResult>> Run<TResult, T0>(this IOperationScheduler scheduler, string type, string? key, Func<IOperationContext<TResult>, T0, Task<OperationResult<TResult>>> handler, T0 arg0, CancellationToken ct)
		{
			Contract.NotNull(scheduler);
			Contract.NotNull(type);
			Contract.NotNull(handler);
			return scheduler.ExecuteOperation(scheduler.Create<TResult>(type, key, null, ct), (ctx) => handler(ctx, arg0));
		}

		public static Task<OperationResult<TResult>> Run<TResult, T0, T1>(this IOperationScheduler scheduler, string type, string? key, Func<IOperationContext<TResult>, T0, T1, Task<OperationResult<TResult>>> handler, T0 arg0, T1 arg1, CancellationToken ct)
		{
			Contract.NotNull(scheduler);
			Contract.NotNull(type);
			Contract.NotNull(handler);
			return scheduler.ExecuteOperation(scheduler.Create<TResult>(type, key, null, ct), (ctx) => handler(ctx, arg0, arg1));
		}

		public static Task<OperationResult<TResult>> Run<TResult, T0, T1, T2>(this IOperationScheduler scheduler, string type, string? key, Func<IOperationContext<TResult>, T0, T1, T2, Task<OperationResult<TResult>>> handler, T0 arg0, T1 arg1, T2 arg2, CancellationToken ct)
		{
			Contract.NotNull(scheduler);
			Contract.NotNull(type);
			Contract.NotNull(handler);
			return scheduler.ExecuteOperation(scheduler.Create<TResult>(type, key, null, ct), (ctx) => handler(ctx, arg0, arg1, arg2));
		}

		public static Task<OperationResult<TResult>> Run<TResult>(this IOperationContext parent, string type, string? key, Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> handler)
		{
			if (key == null)
			{
				key = parent.Key != null ? parent.Key + ":" + type : null;
			}
			else
			{
				key = parent.Key != null ? parent.Key + ":" + key : key;
			}

			var subContext = parent.Scheduler.Create<TResult>(type, key, parent, parent.Cancellation);
			return parent.Scheduler.ExecuteOperation(subContext, handler);
		}

		public static void ThrowIfCancellationRequested(this IOperationContext context)
		{
			context.Cancellation.ThrowIfCancellationRequested();
		}

		#region OperationResult factories...

		public static OperationResult<TResult> Failed<TResult>(this IOperationContext<TResult> context, string code, string message, object? details = null)
		{
			Contract.Debug.Requires(context != null && code != null);
			return context.Failed(new OperationError
			{
				Code = code,
				Message = message,
				Details = details,
			});
		}

		public static OperationResult<TResult> Cancelled<TResult>(this IOperationContext<TResult> context)
		{
			Contract.Debug.Requires(context != null && context.Cancellation.IsCancellationRequested);
			return context.Failed(new OperationError
			{
				Code = "operation_cancelled",
				Message = "Operation has been cancelled.",
				Exception = ExceptionDispatchInfo.Capture(new OperationCanceledException(context.Cancellation))
			});
		}

		public static OperationResult<TResult> MissingParameters<TResult>(this IOperationContext<TResult> context, string paramName)
		{
			return context.Failed(new OperationError
			{
				Code = "invalid_parameter",
				Message = $"Required parameter '{paramName}' is missing.",
				Details = new { ParamName = paramName, Reason = "required" }
			});
		}

		public static OperationResult<TResult> InvalidParameter<TResult>(this IOperationContext<TResult> context, string paramName)
		{
			return context.Failed(new OperationError
			{
				Code = "invalid_parameter",
				Message = $"Parameter '{paramName}' is invalid.",
				Details = new { ParamName = paramName, Reason = "invalid" }
			});
		}

		public static OperationResult<TResult> Throw<TResult>(this IOperationContext<TResult> context, Exception error, string? code = null, string? message = null, object? details = null)
		{
			Contract.Debug.Requires(context != null && error != null);

			if (error is OperationErrorException opEx)
			{
				var err = opEx.Error;
				return context.Failed(new OperationError()
				{
					Code = code ?? err.Code,
					Message = message ?? err.Message,
					Details = details ?? err.Details,
					Exception = err.Exception,
				});
			}

			return context.Failed(new OperationError
			{
				Code = code ?? error.GetType().Name,
				Message = message ?? error.Message,
				Details = details,
				Exception = ExceptionDispatchInfo.Capture(error),
			});
		}

		public static OperationResult<TResult> AccountLinkError<TResult>(this IOperationContext<TResult> context, string providerId, string? message = null)
		{
			return context.Failed(new OperationError
			{
				Code = "account_link",
				Message = message ?? "Could not interact with remote provider because user account is not linked",
				Details = new { ProviderId = providerId},
			});
		}

		public static OperationResult<TResult> RemoteStoreError<TResult>(this IOperationContext<TResult> context, string providerId, string? message = null)
		{
			return context.Failed(new OperationError
			{
				Code = "remote_error",
				Message = message ?? $"An error occurred while trying to call remote store '{providerId}'",
				Details = new { ProviderId = providerId},
			});
		}

		public static OperationResult<TResult> PathNotFoundError<TResult>(this IOperationContext<TResult> context, string providerId, string path, object? details = null)
		{
			return context.Failed(new OperationError
			{
				Code = "path_not_found",
				Message = $"[Provider '{providerId}'] Could not find path '{path}'",
				Details = details ?? new { ProviderId = providerId, Path = path},
			});
		}

		//TODO: ...

		#endregion

		#region Logs...

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogDebug(this IOperationContext context, string message) => context.Log(LogLevel.Debug, null, message);
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogDebug(this IOperationContext context, string format, params object[]? args) => context.Log(LogLevel.Debug, null, format, args);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogInformation(this IOperationContext context, string message) => context.Log(LogLevel.Information, null, message);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogInformation(this IOperationContext context, string format, params object[]? args) => context.Log(LogLevel.Information, null, format, args);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogWarning(this IOperationContext context, string message) => context.Log(LogLevel.Warning, null, message);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogWarning(this IOperationContext context, string format, params object[]? args) => context.Log(LogLevel.Warning, null, format, args);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogError(this IOperationContext context, string message) => context.Log(LogLevel.Error, null, message);
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogError(this IOperationContext context, string format, params object[] args) => context.Log(LogLevel.Error, null, format, args);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogError(this IOperationContext context, Exception exception, string message) => context.Log(LogLevel.Error, exception, message);

		#endregion

	}

	[DebuggerDisplay("Type={Type}, Key={Key}, Id={Id}, State={State}")]
	[PublicAPI]
	public class OperationContext<TResult> : IOperationContext<TResult>
	{

		public OperationContext(OperationScheduler scheduler, string id, OperationState state, string type, string? key, IOperationContext? parent, CancellationTokenSource cts)
		{
			Contract.NotNull(scheduler);

			this.Scheduler = scheduler;
			this.Id = id;
			this.State = state;
			this.Type = type;
			this.Key = key;
			this.Parent = parent;
			this.Lifetime = cts;
		}

		public string Id { get; }

		public OperationState State { get; private set; }

		public string Type { get; }

		public string? Key { get; }

		protected CancellationTokenSource Lifetime { get; }

		public CancellationToken Cancellation => this.Lifetime.Token;

		public IOperationContext? Parent { get; }

		public bool HasResult { get; private set; }

		public TResult? Result { get; private set; }

		public OperationError? Error { get; private set; }

		public OperationScheduler Scheduler { get; }

		IOperationScheduler IOperationContext.Scheduler => this.Scheduler;

		internal async Task Run(Func<IOperationContext, Task> handler)
		{
			if (this.Cancellation.IsCancellationRequested)
			{
				if (this.Error == null)
				{
					this.Cancelled();
				}
				return;
			}

			lock (this)
			{
				if (this.State != OperationState.Pending)
				{
					if (this.Error == null)
					{
						Failed(new OperationError { Code = "aborted", Message = "Operation has been aborted.", });
					}
					return;
				}
				this.State = OperationState.Processing;
			}

			try
			{
				await handler(this).ConfigureAwait(false);
			}
			catch (Exception e)
			{
				this.LogError(e, "Operation execution failed.");
				if (this.Error == null)
				{
					Failed(e is OperationErrorException opEx ? opEx.Error : new OperationError
					{
						Code = "execution_failed",
						Message = e.Message,
						Exception = ExceptionDispatchInfo.Capture(e),
						Details = null, //TODO:
					});
				}
			}
			finally
			{
				this.State = OperationState.Completed;
			}

		}

		bool IOperationContext.TryGetResult(out object? result, [MaybeNullWhen(false)] out Type type)
		{
			if (!this.HasResult || this.State != OperationState.Completed)
			{
				result = null;
				type = null;
				return false;
			}

			result = this.Result;
			type = result?.GetType() ?? typeof(object);
			return true;
		}

		public bool TryGetResult([MaybeNullWhen(false)] out TResult result)
		{
			if (!this.HasResult || this.State != OperationState.Completed)
			{
				result = default;
				return false;
			}

			result = this.Result!;
			return true;
		}

		public OperationResult<TResult> Success(TResult result)
		{
			lock (this)
			{
				//REVIEW: should we allow calling Success() after Failed() has been called ?
				if (this.HasResult) throw new InvalidOperationException(this.Error == null ? ("Cannot call " + nameof(Success) + "() multiple times on the same context") : ("Cannot call " + nameof(Success) + "() on a context that has already been failed"));
				this.HasResult = true;
				this.Result = result;
				this.Error = null;
				this.State = OperationState.Completed;
			}
			return new OperationResult<TResult>(this);
		}

		public OperationResult<TResult> Failed(OperationError error)
		{
			Contract.NotNull(error);
			lock (this)
			{
				//REVIEW: should we allow calling Failed() after Success() has been called ?
				if (this.HasResult) throw new InvalidOperationException(this.Error != null ? ("Cannot call " + nameof(Failed) + "() multiple times on the same context") : ("Cannot call " + nameof(Failed) + "() on a context that has already been completed"));
				this.HasResult = false;
				this.Result = default!;
				this.Error = error;
				this.State = OperationState.Completed;

				var activity = this.Activity;
				if (activity != null)
				{
					activity.SetStatus(ActivityStatusCode.Error, error.Code);
					activity.SetTag("operation.error.code", error.Code);
					var ex = error.Exception?.SourceException;
					if (ex != null) activity.AddException(ex);
				}

			}
			return new OperationFailed(this);
		}

		public void Dispatch(IEvent evt)
		{
			this.Scheduler.Dispatch(this, evt);
		}

		public void Log(LogLevel level, Exception? exception, string message, object?[]? args = null)
		{
			this.Scheduler.Log(this, level, exception, message, args);
		}

		public IDisposable ExecuteStep(string id, string? label = null)
		{
			Contract.NotNull(id);
			//BUGBUG: TODO: !
			return Disposable.Empty();
		}

		public Task<OperationResult<TSubResult>> ExecuteSubOperation<TSubResult>(
			IOperationContext<TSubResult> operation,
			Func<IOperationContext<TSubResult>, Task<OperationResult<TSubResult>>> handler)
		{
			Contract.NotNull(operation);
			Contract.NotNull(handler);

			return this.Scheduler.ExecuteOperation(operation, handler);
		}

		public Activity? Activity { get; private set; }

		internal void SetActivity(Activity? activity)
		{
			this.Activity = activity;
			if (activity?.IsAllDataRequested == true)
			{
				activity.SetTag("operation.id", this.Id);
				activity.SetTag("operation.type", this.Type);
				activity.SetTag("operation.key", this.Key);
				activity.SetTag("operation.parent", this.Parent?.Id);
				//TODO: more?
			}
		}

	}

	[PublicAPI]
	public interface IOperationOverlord
	{

		bool TryGetOperationById(string id, [MaybeNullWhen(false)] out IOperationContext context);

		//bool TryGetOperationByKey(string key, out IOperationContext? context);

		IOperationContext[] ListOperations();

	}

	[PublicAPI]
	public interface IOperationScheduler
	{
		/// <summary>Create a new context for running an operation</summary>
		/// <typeparam name="TResult">Type of result returned by the operation</typeparam>
		/// <param name="type">Operation type (for diagnostic purpose)</param>
		/// <param name="key">If not null, used to distinguish multiple concurrent operations of the type <paramref name="type"/></param>
		/// <param name="parent">If not null, parent operation that started this operation</param>
		/// <param name="ct">Token used to abort the execution of the operation</param>
		/// <returns>Context initialized and ready to run</returns>
		IOperationContext<TResult> Create<TResult>(string type, string? key, IOperationContext? parent = null, CancellationToken ct = default);

		/// <summary>Execute an operation under the control of this scheduler</summary>
		/// <typeparam name="TResult">Type of result returned by the operation</typeparam>
		/// <param name="context">Context of the operation</param>
		/// <param name="handler">Handler that will run the operation</param>
		/// <returns>Result of the operation.</returns>
		/// <remarks>
		/// <para>Any exception thrown by <paramref name="handler"/> will be intercepted and wrapped into a failed <see cref="OperationResult{TResult}"/>.</para>
		/// <para>The end result of the operation can be checked using the <see cref="OperationResult{TResult}.Check"/> method.</para>
		/// </remarks>
		Task<OperationResult<TResult>> ExecuteOperation<TResult>(IOperationContext<TResult> context, Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> handler);

		/// <summary>Log a message that will be visible to the observers of an operation</summary>
		/// <param name="context">Context of the operation that is producing this log</param>
		/// <param name="level">Log level</param>
		/// <param name="exception">Optional exception that is linked to this log message</param>
		/// <param name="message">Log message</param>
		/// <param name="args">Optional arguments used to format the log message</param>
		void Log(IOperationContext context, LogLevel level, Exception? exception, string message, params object[]? args);

		void Dispatch(IOperationContext context, IEvent evt);

	}

	public class OperationScheduler : IOperationScheduler, IOperationOverlord
	{

		private static readonly ActivitySource ActivitySource = new("Doxense.Threading.Operations");

		private ILogger<OperationScheduler> Logger { get; }

		private IEventBus EventBus { get; }

		private CancellationTokenSource Lifetime { get; }

		//private ConcurrentDictionary<string, IOperationContext> OperationsById { get; } = new ConcurrentDictionary<string, IOperationContext>();

		//private ConcurrentDictionary<string, IOperationContext> OperationsByKey { get; } = new ConcurrentDictionary<string, IOperationContext>();

		public OperationScheduler(IEventBus eventBus, ILogger<OperationScheduler> logger)
		{
			this.EventBus = eventBus;
			this.Logger = logger;
			this.Lifetime = new CancellationTokenSource();
		}

		public string NewId()
		{
			//TODO: external generator?
			return Uuid128.NewUuid().ToString();
		}

		public bool TryGetOperationById(string id, [MaybeNullWhen(false)] out IOperationContext context)
		{
			//BUGBUG: TODO !
			context = null;
			return false;
		}

		public IOperationContext[] ListOperations()
		{
			//BUGBUG: TODO !
			return [ ];
		}

		public IOperationContext<TResult> Create<TResult>(string type, string? key, IOperationContext? parent = null, CancellationToken ct = default)
		{
			var cts = CancellationTokenSource.CreateLinkedTokenSource(this.Lifetime.Token, ct);
			return new OperationContext<TResult>(this, NewId(), OperationState.Pending, type, key, parent, cts);
		}

		private OperationResult<TResult> HandleCancellation<TResult>(IOperationContext<TResult> context)
		{
			Contract.Debug.Requires(context.Cancellation.IsCancellationRequested);
			return context.Error != null ? new OperationFailed(context) : context.Cancelled();
		}

		public async Task<OperationResult<TResult>> ExecuteOperation<TResult>(IOperationContext<TResult> context, Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> handler)
		{
			Contract.NotNull(context);
			Contract.NotNull(handler);

			using var activity = ActivitySource.StartActivity(context.Type + " execute");

			if (activity != null && context is OperationContext<TResult> ctx)
			{
				ctx.SetActivity(activity);
			}

			if (context.Cancellation.IsCancellationRequested)
			{
				return HandleCancellation(context);
			}

			try
			{
				return await handler(context).ConfigureAwait(false);
			}
			catch (OperationErrorException e)
			{
				return context.Failed(e.Error);
			}
			catch (Exception e)
			{
				return context.Failed(new OperationError
				{
					Code = "internal_error",
					Message = e.Message,
					Exception = ExceptionDispatchInfo.Capture(e),
					Details = null,
				});
			}
		}

		public void Log(IOperationContext context, LogLevel level, Exception? exception, string message, params object?[]? args)
		{
			if (exception == null)
			{
				this.Logger.Log(level, $"{context.Id}: {message}", args ?? [ ]);
			}
			else
			{
				this.Logger.Log(level, exception, $"{context.Id}: {message}", args ?? [ ]);
			}
		}

		public void Dispatch(IOperationContext context, IEvent evt)
		{
			this.EventBus.Dispatch(evt);
		}

	}

	[PublicAPI]
	[AttributeUsage(AttributeTargets.Method)]
	public sealed class OperationActionAttribute : Attribute
	{

		public string? Type { get; }

		public OperationActionAttribute() { }

		public OperationActionAttribute(string type) { this.Type = type; }

	}

	[PublicAPI]
	[AttributeUsage(AttributeTargets.Class)]
	public sealed class OperationInvokerAttribute<TService> : Attribute
	{

		public string Type { get; set; }

		public OperationInvokerAttribute(string type)
		{
			this.Type = type;
		}

	}

	[PublicAPI]
	public interface IOperationInvoker<out TService>
	{
		IOperationScheduler GetScheduler();

		TService GetInstance();
	}

	[PublicAPI]
	public sealed class OperationCallSite<TResult, T0>
	{
		public IOperationScheduler Scheduler { get; }

		public string Type { get; }

		public Func<IOperationContext<TResult>, T0, Task<OperationResult<TResult>>> Handler { get; }

		public OperationCallSite(IOperationScheduler scheduler, string type, Func<IOperationContext<TResult>, T0, Task<OperationResult<TResult>>> handler)
		{
			this.Scheduler = scheduler;
			this.Type = type;
			this.Handler = handler;
		}

		private Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> MakeCallback(T0 arg0)
			=> (ctx) => this.Handler(ctx, arg0);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(string? key, T0 arg0, CancellationToken ct)
			=> this.Scheduler.Run<TResult>(this.Type, key, MakeCallback(arg0), ct);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(IOperationContext parent, string? key, T0 arg0)
			=> parent.Run<TResult>(this.Type, key, MakeCallback(arg0));

	}

	[PublicAPI]
	public sealed class OperationCallSite<TResult, T0, T1>
	{

		public IOperationScheduler Scheduler { get; }

		public string Type { get; }

		public Func<IOperationContext<TResult>, T0, T1, Task<OperationResult<TResult>>> Handler { get; }

		public OperationCallSite(IOperationScheduler scheduler, string type, Func<IOperationContext<TResult>, T0, T1, Task<OperationResult<TResult>>> handler)
		{
			this.Scheduler = scheduler;
			this.Type = type;
			this.Handler = handler;
		}

		private Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> MakeCallback(T0 arg0, T1 arg1)
			=> (ctx) => this.Handler(ctx, arg0, arg1);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(string? key, T0 arg0, T1 arg1, CancellationToken ct)
			=> this.Scheduler.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1), ct);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(IOperationContext parent, string? key, T0 arg0, T1 arg1)
			=> parent.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1));

	}

	[PublicAPI]
	public sealed class OperationCallSite<TResult, T0, T1, T2>
	{

		public IOperationScheduler Scheduler { get; }

		public string Type { get; }

		public Func<IOperationContext<TResult>, T0, T1, T2, Task<OperationResult<TResult>>> Handler { get; }

		public OperationCallSite(IOperationScheduler scheduler, string type, Func<IOperationContext<TResult>, T0, T1, T2, Task<OperationResult<TResult>>> handler)
		{
			this.Scheduler = scheduler;
			this.Type = type;
			this.Handler = handler;
		}

		private Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> MakeCallback(T0 arg0, T1 arg1, T2 arg2)
			=> (ctx) => this.Handler(ctx, arg0, arg1, arg2);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(string? key, T0 arg0, T1 arg1, T2 arg2, CancellationToken ct)
			=> this.Scheduler.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2), ct);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(IOperationContext parent, string? key, T0 arg0, T1 arg1, T2 arg2)
			=> parent.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2));

	}

	[PublicAPI]
	public sealed class OperationCallSite<TResult, T0, T1, T2, T3>
	{

		public IOperationScheduler Scheduler { get; }

		public string Type { get; }

		public Func<IOperationContext<TResult>, T0, T1, T2, T3, Task<OperationResult<TResult>>> Handler { get; }

		public OperationCallSite(IOperationScheduler scheduler, string type, Func<IOperationContext<TResult>, T0, T1, T2, T3, Task<OperationResult<TResult>>> handler)
		{
			this.Scheduler = scheduler;
			this.Type = type;
			this.Handler = handler;
		}

		private Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> MakeCallback(T0 arg0, T1 arg1, T2 arg2, T3 arg3)
			=> (ctx) => this.Handler(ctx, arg0, arg1, arg2, arg3);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(string? key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, CancellationToken ct)
			=> this.Scheduler.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2, arg3), ct);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(IOperationContext parent, string? key, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
			=> parent.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2, arg3));

	}

	[PublicAPI]
	public sealed class OperationCallSite<TResult, T0, T1, T2, T3, T4>
	{

		public IOperationScheduler Scheduler { get; }

		public string Type { get; }

		public Func<IOperationContext<TResult>, T0, T1, T2, T3, T4, Task<OperationResult<TResult>>> Handler { get; }

		public OperationCallSite(IOperationScheduler scheduler, string type, Func<IOperationContext<TResult>, T0, T1, T2, T3, T4, Task<OperationResult<TResult>>> handler)
		{
			this.Scheduler = scheduler;
			this.Type = type;
			this.Handler = handler;
		}

		private Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> MakeCallback(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
			=> (ctx) => this.Handler(ctx, arg0, arg1, arg2, arg3, arg4);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(string? key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CancellationToken ct)
			=> this.Scheduler.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2, arg3, arg4), ct);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(IOperationContext parent, string? key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
			=> parent.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2, arg3, arg4));

	}

	[PublicAPI]
	public sealed class OperationCallSite<TResult, T0, T1, T2, T3, T4, T5>
	{

		public IOperationScheduler Scheduler { get; }

		public string Type { get; }

		public Func<IOperationContext<TResult>, T0, T1, T2, T3, T4, T5, Task<OperationResult<TResult>>> Handler { get; }

		public OperationCallSite(IOperationScheduler scheduler, string type, Func<IOperationContext<TResult>, T0, T1, T2, T3, T4, T5, Task<OperationResult<TResult>>> handler)
		{
			this.Scheduler = scheduler;
			this.Type = type;
			this.Handler = handler;
		}

		private Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> MakeCallback(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
			=> (ctx) => this.Handler(ctx, arg0, arg1, arg2, arg3, arg4, arg5);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(string? key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, CancellationToken ct)
			=> this.Scheduler.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2, arg3, arg4, arg5), ct);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(IOperationContext parent, string? key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
			=> parent.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2, arg3, arg4, arg5));

	}

	[PublicAPI]
	public static class OperationInvokerExtensions
	{

		#region <T0>

		public static Task<OperationResult<TResult>> Invoke<TResult, T0>(this OperationCallSite<TResult, T0> operation, T0 arg0, CancellationToken ct)
			=> operation.Execute(null, arg0, ct);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0>(this OperationCallSite<TResult, T0> operation, string key, T0 arg0, CancellationToken ct)
			=> operation.Execute(key, arg0, ct);

		public static Task<OperationResult<TResult>> Invoke<TResult, T0>(this OperationCallSite<TResult, T0> operation, IOperationContext parent, T0 arg0)
			=> operation.Execute(parent, null, arg0);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0>(this OperationCallSite<TResult, T0> operation, string key, IOperationContext parent, T0 arg0)
			=> operation.Execute(parent, key, arg0);

		#endregion

		#region <T0, T1>

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1>(this OperationCallSite<TResult, T0, T1> operation, T0 arg0, T1 arg1, CancellationToken ct)
			=> operation.Execute(null, arg0, arg1, ct);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1>(this OperationCallSite<TResult, T0, T1> operation, string key, T0 arg0, T1 arg1, CancellationToken ct)
			=> operation.Execute(key, arg0, arg1, ct);

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1>(this OperationCallSite<TResult, T0, T1> operation, IOperationContext parent, T0 arg0, T1 arg1)
			=> operation.Execute(parent, null, arg0, arg1);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1>(this OperationCallSite<TResult, T0, T1> operation, string key, IOperationContext parent, T0 arg0, T1 arg1)
			=> operation.Execute(parent, key, arg0, arg1);

		#endregion

		#region <T0, T1, T2>

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1, T2>(this OperationCallSite<TResult, T0, T1, T2> operation, T0 arg0, T1 arg1, T2 arg2, CancellationToken ct)
			=> operation.Execute(null, arg0, arg1, arg2, ct);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1, T2>(this OperationCallSite<TResult, T0, T1, T2> operation, string key, T0 arg0, T1 arg1, T2 arg2, CancellationToken ct)
			=> operation.Execute(key, arg0, arg1, arg2, ct);

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1, T2>(this OperationCallSite<TResult, T0, T1, T2> operation, IOperationContext parent, T0 arg0, T1 arg1, T2 arg2)
			=> operation.Execute(parent, null, arg0, arg1, arg2);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1, T2>(this OperationCallSite<TResult, T0, T1, T2> operation, string key, IOperationContext parent, T0 arg0, T1 arg1, T2 arg2)
			=> operation.Execute(parent, key, arg0, arg1, arg2);

		#endregion

		#region <T0, T1, T2, T3>

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1, T2, T3>(this OperationCallSite<TResult, T0, T1, T2, T3> operation, T0 arg0, T1 arg1, T2 arg2, T3 arg3, CancellationToken ct)
			=> operation.Execute(null, arg0, arg1, arg2, arg3, ct);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1, T2, T3>(this OperationCallSite<TResult, T0, T1, T2, T3> operation, string key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, CancellationToken ct)
			=> operation.Execute(key, arg0, arg1, arg2, arg3, ct);

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1, T2, T3>(this OperationCallSite<TResult, T0, T1, T2, T3> operation, IOperationContext parent, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
			=> operation.Execute(parent, null, arg0, arg1, arg2, arg3);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1, T2, T3>(this OperationCallSite<TResult, T0, T1, T2, T3> operation, string key, IOperationContext parent, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
			=> operation.Execute(parent, key, arg0, arg1, arg2, arg3);

		#endregion

		#region <T0, T1, T2, T3, T4>

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1, T2, T3, T4>(this OperationCallSite<TResult, T0, T1, T2, T3, T4> operation, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CancellationToken ct)
			=> operation.Execute(null, arg0, arg1, arg2, arg3, arg4, ct);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1, T2, T3, T4>(this OperationCallSite<TResult, T0, T1, T2, T3, T4> operation, string key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CancellationToken ct)
			=> operation.Execute(key, arg0, arg1, arg2, arg3, arg4, ct);

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1, T2, T3, T4>(this OperationCallSite<TResult, T0, T1, T2, T3, T4> operation, IOperationContext parent, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
			=> operation.Execute(parent, null, arg0, arg1, arg2, arg3, arg4);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1, T2, T3, T4>(this OperationCallSite<TResult, T0, T1, T2, T3, T4> operation, string key, IOperationContext parent, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
			=> operation.Execute(parent, key, arg0, arg1, arg2, arg3, arg4);

		#endregion

	}

}
