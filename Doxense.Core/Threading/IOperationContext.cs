#region Copyright (c) 2023-2025 SnowBank SAS, (c) 2005-2023 Doxense SAS
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 	* Redistributions of source code must retain the above copyright
// 	  notice, this list of conditions and the following disclaimer.
// 	* Redistributions in binary form must reproduce the above copyright
// 	  notice, this list of conditions and the following disclaimer in the
// 	  documentation and/or other materials provided with the distribution.
// 	* Neither the name of SnowBank nor the
// 	  names of its contributors may be used to endorse or promote products
// 	  derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL SNOWBANK SAS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#endregion

namespace SnowBank.Threading.Operations
{
	using System.Runtime.ExceptionServices;
	using SnowBank.Messaging.Events;
	using SnowBank.Reactive.Disposables;
	using Microsoft.Extensions.DependencyInjection;
	using Microsoft.Extensions.DependencyInjection.Extensions;
	using Microsoft.Extensions.Logging;
	using SnowBank.Runtime;
	using System.Diagnostics.CodeAnalysis;

	/// <summary>Represents the execution context for an asynchronous operation that can be observed from the outside</summary>
	[PublicAPI]
	public interface IOperationContext
	{

		/// <summary>Globally unique identifier for this operation</summary>
		string Id { get; }

		/// <summary>Operation type (for diagnostic purpose)</summary>
		string Type { get; }

		/// <summary>If not null, used to distinguish multiple concurrent operations of the type <see cref="Type"/></summary>
		string? Key { get; }

		/// <summary>If not null, parent operation that started this operation</summary>
		IOperationContext? Parent { get; }

		/// <summary>Scheduler used to orchestrate the execution of this operation</summary>
		IOperationScheduler Scheduler { get; }

		/// <summary>Cancellation token used to abort this operation</summary>
		CancellationToken Cancellation { get; }

		/// <summary>Current state of the operation</summary>
		OperationState State { get; }

		/// <summary>Return the result of the operation, if it completed successfully</summary>
		/// <param name="result">Result of the operation</param>
		/// <param name="type">Type of the result</param>
		/// <returns>Returns <c>true</c> if the operation completed successfully; otherwise, <c>false</c>.</returns>
		bool TryGetResult(out object? result, [MaybeNullWhen(false)] out Type type);

		/// <summary>If not null, error generated by the operation</summary>
		OperationError? Error { get; }

		void Log(LogLevel level, Exception? exception, string message, object?[]? args = null);

		/// <summary>Dispatch an event that happened during the processing of this operation</summary>
		/// <param name="evt"></param>
		void Dispatch(IEvent evt);

		/// <summary>Execute a sub-step, using the same context as this operation</summary>
		/// <param name="id">Id of the sub-step (for computers)</param>
		/// <param name="label">Label of the sub-step (for humans)</param>
		/// <returns>Token that must be disposed at the end of the sub-step</returns>
		/// <remarks>
		/// <para>Sub-steps should be used to wrap the various parts of an operation, that are not large enough to be <see cref="ExecuteSubOperation{TResult}">split into sub-operations</see>.</para>
		/// <para>They will be exposed to observers who are following the execution.</para>
		/// </remarks>
		IDisposable ExecuteStep(string id, string? label = null);

		/// <summary>Execute a sub-operation, in its own context.</summary>
		/// <typeparam name="TSubResult">Type of the result returned by the sub-operation</typeparam>
		/// <param name="operation">Context of the sub-operation, created as a child of this operation</param>
		/// <param name="handler">Function that will be run to execute the sub-operation</param>
		/// <returns>Result of the sub-operation.</returns>
		Task<OperationResult<TSubResult>> ExecuteSubOperation<TSubResult>(IOperationContext<TSubResult> operation, Func<IOperationContext<TSubResult>, Task<OperationResult<TSubResult>>> handler);
		
		Activity? Activity { get; }
		
	}

	/// <summary>Represents the context of an Operation</summary>
	/// <typeparam name="TResult">Type of the result returned by the operation attached to this context</typeparam>
	[PublicAPI]
	public interface IOperationContext<TResult> : IOperationContext
	{

		/// <summary>Marks this context as failed</summary>
		/// <param name="error">Description of the error</param>
		/// <returns>Failed operation result</returns>
		OperationResult<TResult> Failed(OperationError error);

		/// <summary>Marks this context as successful</summary>
		/// <param name="result">Result of the operation</param>
		/// <returns>Successful operation result</returns>
		OperationResult<TResult> Success(TResult result);

		/// <summary>Returns the result attached to this context, if it ran successfully</summary>
		/// <param name="result">Receives the result of the operation, if it was a success</param>
		/// <returns><c>true</c> if the context was marked as a success; otherwise, <c>false</c></returns>
		bool TryGetResult([MaybeNullWhen(false)] out TResult result);

	}

	[PublicAPI]
	public enum OperationState
	{
		Invalid = 0,
		Pending,
		Processing,
		Completed,
	}

	/// <summary>Represents the result of the execution of an operation</summary>
	[DebuggerDisplay("Id={Context.Id}, State={Context.State}")]
	[PublicAPI]
	public readonly struct OperationResult<TResult>
	{

		public OperationResult(IOperationContext context)
		{
			this.Context = context;
		}

		/// <summary>Context of the operation that produced this result</summary>
		public readonly IOperationContext Context;

		/// <summary>Tests if the result represents a failure condition</summary>
		public bool HasFailed => this.Context.Error != null;

		/// <summary>Returns the result of the operation, or throws if the operation failed</summary>
		/// <returns>Result of the operation (if it was successful)</returns>
		/// <exception cref="InvalidOperationException">If the operation did not run to completion (success or failure)</exception>
		//REVIEW: rename to "GetResult()" to match tasks?
		public TResult EnsureSuccess()
		{
			if (this.Context.State != OperationState.Completed)
			{
				throw new InvalidOperationException("Operation is not completed yet.");
			}

			if (this.Context.Error != null)
			{
				this.Context.Error.Exception?.Throw();
				//TODO: map the error to something more specific?
				throw new InvalidOperationException($"Operation failed: [{this.Context.Error.Code}] {this.Context.Error.Message}"); }

			if (!this.Context.TryGetResult(out object? value, out Type? type))
			{
				throw new InvalidOperationException("Operation completed successfully, but does not have a return value.");
			}

			if (!typeof(TResult).IsAssignableFrom(type))
			{
				throw new InvalidOperationException($"Operation completed successfully, but the result type does not match: expected {typeof(TResult).GetFriendlyName()} but was {type.GetFriendlyName()}.");
			}

			if (default(TResult) is null)
			{ // class
				return (TResult) value!;
			}
			else
			{ // valuetype
				return value == null ? default! : (TResult) value;
			}
		}

		/// <summary>Checks whether the operation was a success or a failure, and return either the result or the error</summary>
		/// <param name="result">If the operation succeeded, receives the result; otherwise, <c>null</c></param>
		/// <param name="error">If the operation failed, receives the error; otherwise, <c>null</c></param>
		/// <returns><c>true</c> if the operation completed successfully; otherwise, <c>false</c>.</returns>
		public bool Check([MaybeNullWhen(false)] out TResult result, [MaybeNullWhen(true)] out OperationError error)
		{
			if (this.Context.State != OperationState.Completed)
			{
				result = default;
				error = new OperationError { Code = "not_completed", Message = "Operation is not completed yet." };
				return false;
			}

			if (this.Context.Error != null)
			{
				result = default;
				error = this.Context.Error;
				return false;
			}

			if (!this.Context.TryGetResult(out object? value, out Type? type))
			{
				result = default;
				error = new OperationError
				{
					Code = "invalid_result",
					Message = "Operation completed successfully, but does not have a return value."
				};
				return false;
			}

			if (value is not null && !typeof(TResult).IsAssignableFrom(type))
			{
				result = default;
				error = new OperationError
				{
					Code = "invalid_result",
					Message = "Operation completed successfully, but the result type does not match.",
					Details = new { ExpectedType = typeof(TResult).GetFriendlyName(), ActualType = type.GetFriendlyName() }
				};
				return false;
			}

			if (default(TResult) is null)
			{ // class
				result = (TResult) value!;
			}
			else
			{ // valuetype
				result = value == null ? default! : (TResult) value;
			}
			error = null;
			return true;
		}

		/// <summary>Returns a result that represents a failed operation.</summary>
		/// <param name="failed">Description of the failure</param>
		public static implicit operator OperationResult<TResult>(OperationFailed failed)
		{
			return new OperationResult<TResult>(failed.Context);
		}

	}

	/// <summary>Represents the result of a failed Operation.</summary>
	[PublicAPI]
	public readonly struct OperationFailed
	{

		//note: the error message is encapsulated in the context
		// => this type is only there to help with auto-casting errors to the expected operation result type:
		//
		// public async Task<IOperationResult<Foo>> DoSomething(IOperationContext ctx, ....)
		// {
		//     // ...
		//     if (/* some error condition*/)
		//     {
		//         // this returns an "OperationFailed" that will be implicitly cast to the expected IOperationResult<Foo>
		//         return ctx.Failed("some_error", "Something is not right", /*....*/);
		//     }
		//     // ...
		//     return ctx.Success(new Foo { /* ... */ });
		// }

		/// <summary>Context of the failed operation</summary>
		public readonly IOperationContext Context;

		public OperationFailed(IOperationContext context)
		{
			this.Context = context;
		}

		/// <summary>Error produced by the failed operation.</summary>
		public OperationError Error => this.Context.Error!;

	}

	/// <summary>Result of a failed Operation.</summary>
	[PublicAPI]
	public sealed record OperationError
	{
		/// <summary>Code that represent the specific error condition (for robots)</summary>
		public required string Code { get; init; }

		/// <summary>Text that describes the error condition (for humans)</summary>
		public required string Message { get; init; }

		/// <summary>Exception that triggered the failure (optional)</summary>
		public ExceptionDispatchInfo? Exception { get; init; }

		/// <summary>Additional details that can help diagnose the error</summary>
		/// <remarks>This object <b>MUST</b> support serialization to JSON or other formats.</remarks>
		public object? Details { get; init; }

	}

	/// <summary>Exception that can be used to bubble up an <see cref="OperationError"/> from deep inside the execution of an Operatin.</summary>
	[PublicAPI]
	public sealed class OperationErrorException : Exception
	{

		public OperationErrorException(OperationError error, Exception? inner = null)
			: base(error.Message, inner)
		{
			this.Error = error;
		}

		public OperationErrorException(string code, string message, object? details = null, Exception? exception = null)
		{
			this.Error = new OperationError { Code = code, Message = message, Details = details, Exception = exception != null ? ExceptionDispatchInfo.Capture(exception) : null };
		}

		public OperationErrorException(string code, string message, object? details = null, ExceptionDispatchInfo? exception = null)
		{
			this.Error = new OperationError { Code = code, Message = message, Details = details, Exception = exception };
		}

		/// <summary>Error that should be returned by the top-level code that runs the operation.</summary>
		public OperationError Error { get; }

	}

	[PublicAPI]
	public interface IStoryBook
	{

		string Type { get; }

		string Recipee { get; }

	}

	/// <summary>Base interface for a Workflow</summary>
	/// <remarks>
	/// This non-generic version of <see cref="IOperationWorkflow{TArguments, TResult}"/> is required
	/// when multiple workflows with different signatures must be stored in the same list of dictionary.
	/// </remarks>
	[PublicAPI]
	public interface IOperationWorkflow;

	/// <summary>Base interface of a Workflow that processes a <typeparamref name="TArguments"/> and returns a <typeparamref name="TResult"/></summary>
	/// <typeparam name="TArguments">Type of the arguments that this workflow will process</typeparam>
	/// <typeparam name="TResult">Type of the result that this workflow returns upon successful execution of the request</typeparam>
	[PublicAPI]
	public interface IOperationWorkflow<in TArguments, TResult> : IOperationWorkflow
	{

		/// <summary>Runs the workflow on a set of arguments</summary>
		/// <param name="arguments">Arguments for this execution</param>
		/// <returns>Result of the execution</returns>
		Task<OperationResult<TResult>> ExecuteAsync(TArguments arguments);

	}

	/// <summary>Base interface of a Workflow that processes a <typeparamref name="TArguments"/> and returns a <typeparamref name="TResult"/></summary>
	/// <typeparam name="TWorkflow">Type of the class that implements this interface (CRTP)</typeparam>
	/// <typeparam name="TArguments">Type of the arguments that this workflow will process</typeparam>
	/// <typeparam name="TResult">Type of the result that this workflow returns upon successful execution of the request</typeparam>
	[PublicAPI]
	public interface IOperationWorkflow<TWorkflow, in TArguments, TResult> : IOperationWorkflow<TArguments, TResult>
		where TWorkflow: IOperationWorkflow<TWorkflow, TArguments, TResult>
	{
		
		//static abstract TWorkflow CreateInstance(IServiceProvider services, string name, IOperationScheduler scheduler, TArguments req, CancellationToken ct);

		//static abstract TWorkflow CreateInstance(IServiceProvider services, IOperationContext<TArguments, TResult> ctx);

	}

	/// <summary>Generic implementation for Workflows</summary>
	/// <typeparam name="TWorkflow">Type of the concrete class that derives from this base type.</typeparam>
	/// <typeparam name="TArguments">Type of the arguments that this workflow will process</typeparam>
	/// <typeparam name="TResult">Type of the result that this workflow returns upon successful execution of the request</typeparam>
	[PublicAPI]
	public abstract class OperationWorkflowBase<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TWorkflow, TArguments, TResult> : IOperationWorkflow<TWorkflow, TArguments, TResult>
		where TWorkflow: OperationWorkflowBase<TWorkflow, TArguments, TResult>
	{

		/// <summary>Context of the currently running operation</summary>
		protected IOperationContext<TResult> Context { get; }

		/// <summary>Base constructor</summary>
		/// <param name="context">Context for the operation</param>
		protected OperationWorkflowBase(IOperationContext<TResult> context)
		{
			this.Context = context;
		}

		/// <inheritdoc />
		public Task<OperationResult<TResult>> ExecuteAsync(TArguments arguments)
		{
			return this.Context.Scheduler.ExecuteOperation<TResult>(this.Context, _ => this.ExecuteInternalAsync(arguments));
		}

		/// <summary>Executes the workflow on the given set of parameters</summary>
		/// <param name="parameters">Parameters for the operation</param>
		/// <returns>Result of the operation</returns>
		protected abstract Task<OperationResult<TResult>> ExecuteInternalAsync(TArguments parameters);

		/// <summary>Token that will trigger if the operation is canceled during its execution</summary>
		protected CancellationToken Cancellation => this.Context.Cancellation;

		/// <summary>Logs a message using the <see cref="LogLevel.Trace"/> log level</summary>
		protected void LogTrace(string message) => this.Context.LogTrace(message);

		/// <summary>Logs a message using the <see cref="LogLevel.Debug"/> log level</summary>
		protected void LogDebug(string message) => this.Context.LogDebug(message);

		/// <summary>Logs a message using the <see cref="LogLevel.Information"/> log level</summary>
		protected void LogInformation(string message) => this.Context.LogInformation(message);

		/// <summary>Logs a message using the <see cref="LogLevel.Warning"/> log level</summary>
		protected void LogWarning(string message) => this.Context.LogWarning(message);

		/// <summary>Logs a message using the <see cref="LogLevel.Error"/> log level</summary>
		protected void LogError(string message) => this.Context.LogError(message);

		/// <summary>Logs a message using the <see cref="LogLevel.Error"/> log level</summary>
		protected void LogError(Exception e, string message) => this.Context.LogError(e, message);

		/// <summary>Marks the operation as completed successfully with the specified result</summary>
		/// <param name="result">Result returned by the operation.</param>
		/// <returns>Successful operation result</returns>
		protected OperationResult<TResult> Success(TResult result) => this.Context.Success(result);

		/// <summary>Marks the operation as failed, with the specified error.</summary>
		/// <param name="error">Error returned by the operation.</param>
		/// <returns>Failed operation result</returns>
		protected OperationResult<TResult> Failed(OperationError error) => this.Context.Failed(error);

		/// <summary>Marks the operation as failed, with the specified exception.</summary>
		/// <param name="exception">Exception that should be returned to the caller.</param>
		/// <returns>Failed operation result</returns>
		protected OperationResult<TResult> Throw(Exception exception) => this.Context.Throw(exception);

		/// <summary>Creates a new instance of this workflow</summary>
		/// <param name="services">Provider that can be used to instantiate this workflow</param>
		/// <param name="name">Name of the workflow</param>
		/// <param name="scheduler">Scheduler that will be used to run this operation</param>
		/// <param name="ct">Token that can be used to cancel this operation</param>
		/// <returns>New workflow instance that is ready to run an operation using a newly created context.</returns>
		public static TWorkflow CreateInstance(IServiceProvider services, string name, IOperationScheduler scheduler, CancellationToken ct)
		{
			var ctx = scheduler.Create<TResult>(name, null, null, ct);
			return CreateInstance(services, ctx);
		}

		/// <summary>Creates a new instance of this workflow, using an already created operation context.</summary>
		/// <param name="services">Provider that can be used to instantiate this workflow</param>
		/// <param name="ctx">Context that will run this operation</param>
		/// <returns>New workflow instance that is ready to run an operation using the specified context.</returns>
		public static TWorkflow CreateInstance(IServiceProvider services, IOperationContext ctx)
		{
			return ActivatorUtilities.CreateInstance<TWorkflow>(services, ctx);
		}

	}

	[PublicAPI]
	public static class OperationContextExtensions
	{

		/// <summary>Registers the <see cref="IOperationScheduler"/> and <see cref="IEventBus"/> services</summary>
		public static IServiceCollection AddBackgroundOperations(this IServiceCollection services)
		{
#if DEBUG
			if (services.Any(x => x.ServiceType == typeof(IOperationScheduler)))
			{
				throw new InvalidOperationException("Background operations are already registered!");
			}
#endif
			services.TryAddSingleton<IOperationScheduler, OperationScheduler>();
			services.TryAddSingleton<IEventBus, EventBus>();
			return services;
		}

		/// <summary>Runs an Operation on this scheduler</summary>
		/// <typeparam name="TResult">Results of the operation</typeparam>
		/// <param name="scheduler">Scheduler that will run the operation</param>
		/// <param name="type">Type (or category) of this operation.</param>
		/// <param name="key">Key of the operation in this category, or <c>null</c> for operations that are unique per category.</param>
		/// <param name="handler">Lambda that will be called to run the operation.</param>
		/// <param name="ct">Token that can be used to cancel the operation</param>
		/// <returns>Result of the operation (success or failure)</returns>
		public static Task<OperationResult<TResult>> Run<TResult>(this IOperationScheduler scheduler, string type, string? key, Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> handler, CancellationToken ct)
		{
			Contract.NotNull(scheduler);
			Contract.NotNull(type);
			Contract.NotNull(handler);
			return scheduler.ExecuteOperation(scheduler.Create<TResult>(type, key, null, ct), handler);
		}

		/// <summary>Runs an Operation on this scheduler</summary>
		/// <typeparam name="TResult">Results of the operation</typeparam>
		/// <typeparam name="T0">Type of the argument for this operation</typeparam>
		/// <param name="scheduler">Scheduler that will run the operation</param>
		/// <param name="type">Type (or category) of this operation.</param>
		/// <param name="key">Key of the operation in this category, or <c>null</c> for operations that are unique per category.</param>
		/// <param name="handler">Lambda that will be called to run the operation.</param>
		/// <param name="arg0">Argument of the operation</param>
		/// <param name="ct">Token that can be used to cancel the operation</param>
		/// <returns>Result of the operation (success or failure)</returns>
		public static Task<OperationResult<TResult>> Run<TResult, T0>(this IOperationScheduler scheduler, string type, string? key, Func<IOperationContext<TResult>, T0, Task<OperationResult<TResult>>> handler, T0 arg0, CancellationToken ct)
		{
			Contract.NotNull(scheduler);
			Contract.NotNull(type);
			Contract.NotNull(handler);
			return scheduler.ExecuteOperation(scheduler.Create<TResult>(type, key, null, ct), (ctx) => handler(ctx, arg0));
		}

		/// <summary>Runs an Operation on this scheduler</summary>
		/// <typeparam name="TResult">Results of the operation</typeparam>
		/// <typeparam name="T0">Type of the first argument for this operation</typeparam>
		/// <typeparam name="T1">Type of the segment argument for this operation</typeparam>
		/// <param name="scheduler">Scheduler that will run the operation</param>
		/// <param name="type">Type (or category) of this operation.</param>
		/// <param name="key">Key of the operation in this category, or <c>null</c> for operations that are unique per category.</param>
		/// <param name="handler">Lambda that will be called to run the operation.</param>
		/// <param name="arg0">First argument of the operation</param>
		/// <param name="arg1">Second argument of the operation</param>
		/// <param name="ct">Token that can be used to cancel the operation</param>
		/// <returns>Result of the operation (success or failure)</returns>
		public static Task<OperationResult<TResult>> Run<TResult, T0, T1>(this IOperationScheduler scheduler, string type, string? key, Func<IOperationContext<TResult>, T0, T1, Task<OperationResult<TResult>>> handler, T0 arg0, T1 arg1, CancellationToken ct)
		{
			Contract.NotNull(scheduler);
			Contract.NotNull(type);
			Contract.NotNull(handler);
			return scheduler.ExecuteOperation(scheduler.Create<TResult>(type, key, null, ct), (ctx) => handler(ctx, arg0, arg1));
		}

		/// <summary>Runs an Operation on this scheduler</summary>
		/// <typeparam name="TResult">Results of the operation</typeparam>
		/// <typeparam name="T0">Type of the first argument for this operation</typeparam>
		/// <typeparam name="T1">Type of the segment argument for this operation</typeparam>
		/// <typeparam name="T2">Type of the segment argument for this operation</typeparam>
		/// <param name="scheduler">Scheduler that will run the operation</param>
		/// <param name="type">Type (or category) of this operation.</param>
		/// <param name="key">Key of the operation in this category, or <c>null</c> for operations that are unique per category.</param>
		/// <param name="handler">Lambda that will be called to run the operation.</param>
		/// <param name="arg0">First argument of the operation</param>
		/// <param name="arg1">Second argument of the operation</param>
		/// <param name="arg2">Second argument of the operation</param>
		/// <param name="ct">Token that can be used to cancel the operation</param>
		/// <returns>Result of the operation (success or failure)</returns>
		public static Task<OperationResult<TResult>> Run<TResult, T0, T1, T2>(this IOperationScheduler scheduler, string type, string? key, Func<IOperationContext<TResult>, T0, T1, T2, Task<OperationResult<TResult>>> handler, T0 arg0, T1 arg1, T2 arg2, CancellationToken ct)
		{
			Contract.NotNull(scheduler);
			Contract.NotNull(type);
			Contract.NotNull(handler);
			return scheduler.ExecuteOperation(scheduler.Create<TResult>(type, key, null, ct), (ctx) => handler(ctx, arg0, arg1, arg2));
		}

		/// <summary>Runs a sub-operation that will be attached to this parent Operation</summary>
		/// <typeparam name="TResult">Results of the sub-operation</typeparam>
		/// <param name="parent">Parent operation of this new sub-operation.</param>
		/// <param name="type">Type (or category) of this sub-operation.</param>
		/// <param name="key">Key of the sub-operation in this category, or <c>null</c> for operations that are unique per category.</param>
		/// <param name="handler">Lambda that will be called to run the sub-operation.</param>
		/// <returns>Result of the sub-operation (success or failure)</returns>
		public static Task<OperationResult<TResult>> Run<TResult>(this IOperationContext parent, string type, string? key, Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> handler)
		{
			if (key == null)
			{
				key = parent.Key != null ? parent.Key + ":" + type : null;
			}
			else
			{
				key = parent.Key != null ? parent.Key + ":" + key : key;
			}

			var subContext = parent.Scheduler.Create<TResult>(type, key, parent, parent.Cancellation);
			return parent.Scheduler.ExecuteOperation(subContext, handler);
		}

		/// <summary>Throws a <see cref="OperationCanceledException"/> if this context has been aborted</summary>
		public static void ThrowIfCancellationRequested(this IOperationContext context)
		{
			context.Cancellation.ThrowIfCancellationRequested();
		}

		#region OperationResult factories...

		/// <summary>Marks this context as failed</summary>
		/// <typeparam name="TResult">Type of the operation result</typeparam>
		/// <param name="context">Context that has failed</param>
		/// <param name="code">Code that represent the specific error condition (for robots)</param>
		/// <param name="message">Text that describes the error condition (for humans)</param>
		/// <param name="details">Additional details that can help diagnose the error. This object <b>MUST</b> be serializable into JSON (or other format)</param>
		/// <returns>Failed operation result</returns>
		public static OperationResult<TResult> Failed<TResult>(this IOperationContext<TResult> context, string code, string message, object? details = null)
		{
			Contract.Debug.Requires(context != null && code != null);
			return context.Failed(new OperationError
			{
				Code = code,
				Message = message,
				Details = details,
			});
		}

		/// <summary>Marks this context as canceled</summary>
		/// <typeparam name="TResult">Type of the operation result</typeparam>
		/// <param name="context">Context that has been canceled</param>
		/// <returns>Failed operation result</returns>
		public static OperationResult<TResult> Cancelled<TResult>(this IOperationContext<TResult> context)
		{
			Contract.Debug.Requires(context != null && context.Cancellation.IsCancellationRequested);
			return context.Failed(new OperationError
			{
				Code = "operation_cancelled",
				Message = "Operation has been cancelled.",
				Exception = ExceptionDispatchInfo.Capture(new OperationCanceledException(context.Cancellation))
			});
		}

		/// <summary>Marks this context as failed due to a missing required parameter or argument</summary>
		/// <typeparam name="TResult">Type of the operation result</typeparam>
		/// <param name="context">Context that has failed</param>
		/// <param name="paramName">Name of the parameter or argument that is missing</param>
		/// <returns>Failed operation result</returns>
		public static OperationResult<TResult> MissingParameters<TResult>(this IOperationContext<TResult> context, string paramName)
		//REVIEW: why plural? shouldn't it be MissingParameter<..> ?
		{
			return context.Failed(new OperationError
			{
				Code = "invalid_parameter",
				Message = $"Required parameter '{paramName}' is missing.",
				Details = new { ParamName = paramName, Reason = "required" }
			});
		}

		/// <summary>Marks this context as failed due to an invalid parameter or argument</summary>
		/// <typeparam name="TResult">Type of the operation result</typeparam>
		/// <param name="context">Context that has failed</param>
		/// <param name="paramName">Name of the parameter or argument that is invalid</param>
		/// <returns>Failed operation result</returns>
		public static OperationResult<TResult> InvalidParameter<TResult>(this IOperationContext<TResult> context, string paramName)
		{
			return context.Failed(new OperationError
			{
				Code = "invalid_parameter",
				Message = $"Parameter '{paramName}' is invalid.",
				Details = new { ParamName = paramName, Reason = "invalid" }
			});
		}

		/// <summary>Marks this context as failed due to an internal exception</summary>
		/// <typeparam name="TResult">Type of the operation result</typeparam>
		/// <param name="context">Context that has failed</param>
		/// <param name="error">Exception that was caught (or manually thrown) during the execution of this operation</param>
		/// <param name="code">Optional code that represent the specific error condition (for robots)</param>
		/// <param name="message">Optional text that describes the error condition (for humans)</param>
		/// <param name="details">Optional additional details that can help diagnose the error. This object <b>MUST</b> be serializable into JSON (or other format)</param>
		/// <returns>Failed operation result</returns>
		public static OperationResult<TResult> Throw<TResult>(this IOperationContext<TResult> context, Exception error, string? code = null, string? message = null, object? details = null)
		{
			Contract.Debug.Requires(context != null && error != null);

			if (error is OperationErrorException opEx)
			{
				var err = opEx.Error;
				return context.Failed(new OperationError()
				{
					Code = code ?? err.Code,
					Message = message ?? err.Message,
					Details = details ?? err.Details,
					Exception = err.Exception,
				});
			}

			return context.Failed(new OperationError
			{
				Code = code ?? error.GetType().Name,
				Message = message ?? error.Message,
				Details = details,
				Exception = ExceptionDispatchInfo.Capture(error),
			});
		}

		#endregion

		#region Logs...

		/// <summary>Logs a message using the <see cref="LogLevel.Trace"/> log level</summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogTrace(this IOperationContext context, string message) => context.Log(LogLevel.Trace, null, message);
		
		/// <summary>Logs a message using the <see cref="LogLevel.Trace"/> log level</summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogTrace(this IOperationContext context, string format, params object[]? args) => context.Log(LogLevel.Trace, null, format, args);

		/// <summary>Logs a message using the <see cref="LogLevel.Debug"/> log level</summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogDebug(this IOperationContext context, string message) => context.Log(LogLevel.Debug, null, message);
		
		/// <summary>Logs a message using the <see cref="LogLevel.Debug"/> log level</summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogDebug(this IOperationContext context, string format, params object[]? args) => context.Log(LogLevel.Debug, null, format, args);

		/// <summary>Logs a message using the <see cref="LogLevel.Information"/> log level</summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogInformation(this IOperationContext context, string message) => context.Log(LogLevel.Information, null, message);

		/// <summary>Logs a message using the <see cref="LogLevel.Information"/> log level</summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogInformation(this IOperationContext context, string format, params object[]? args) => context.Log(LogLevel.Information, null, format, args);

		/// <summary>Logs a message using the <see cref="LogLevel.Warning"/> log level</summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogWarning(this IOperationContext context, string message) => context.Log(LogLevel.Warning, null, message);

		/// <summary>Logs a message using the <see cref="LogLevel.Warning"/> log level</summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogWarning(this IOperationContext context, string format, params object[]? args) => context.Log(LogLevel.Warning, null, format, args);

		/// <summary>Logs a message using the <see cref="LogLevel.Error"/> log level</summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogError(this IOperationContext context, string message) => context.Log(LogLevel.Error, null, message);
		
		/// <summary>Logs a message using the <see cref="LogLevel.Error"/> log level</summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogError(this IOperationContext context, string format, params object[] args) => context.Log(LogLevel.Error, null, format, args);

		/// <summary>Logs a message using the <see cref="LogLevel.Error"/> log level</summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void LogError(this IOperationContext context, Exception exception, string message) => context.Log(LogLevel.Error, exception, message);

		#endregion

	}

	/// <summary>Context of an operation</summary>
	/// <typeparam name="TResult">Type of the result returned by the operation</typeparam>
	[DebuggerDisplay("Type={Type}, Key={Key}, Id={Id}, State={State}")]
	[PublicAPI]
	public class OperationContext<TResult> : IOperationContext<TResult>
	{

		public OperationContext(OperationScheduler scheduler, string id, OperationState state, string type, string? key, IOperationContext? parent, CancellationTokenSource cts)
		{
			Contract.NotNull(scheduler);

			this.Scheduler = scheduler;
			this.Id = id;
			this.State = state;
			this.Type = type;
			this.Key = key;
			this.Parent = parent;
			this.Lifetime = cts;
		}

		/// <inheritdoc />
		public string Id { get; }

		/// <inheritdoc />
		public OperationState State { get; private set; }

		/// <inheritdoc />
		public string Type { get; }

		/// <inheritdoc />
		public string? Key { get; }

		protected CancellationTokenSource Lifetime { get; }

		/// <inheritdoc />
		public CancellationToken Cancellation => this.Lifetime.Token;

		/// <inheritdoc />
		public IOperationContext? Parent { get; }

		/// <summary>Returns <c>true</c> if the operation attached to this context has completed successfully</summary>
		/// <remarks>
		/// <para>This flag is required because <typeparamref name="TResult"/> can be nullable, and a <c>null</c> <see cref="Result"/> does not necessary mean that the operation failed.</para>
		/// </remarks>
		public bool HasResult { get; private set; }

		/// <summary>Result of the successful completion of the operation attached to this context</summary>
		public TResult? Result { get; private set; }

		/// <summary>Error produced by operation attached to this context.</summary>
		public OperationError? Error { get; private set; }

		/// <summary>Scheduler that handles the execution of this context</summary>
		public OperationScheduler Scheduler { get; }

		/// <inheritdoc />
		IOperationScheduler IOperationContext.Scheduler => this.Scheduler;

		/// <summary>Invokes the handler that will run operation attached to this context</summary>
		internal async Task Run(Func<IOperationContext, Task> handler)
		{
			if (this.Cancellation.IsCancellationRequested)
			{
				if (this.Error == null)
				{
					this.Cancelled();
				}
				return;
			}

			lock (this)
			{
				if (this.State != OperationState.Pending)
				{
					if (this.Error == null)
					{
						Failed(new OperationError { Code = "aborted", Message = "Operation has been aborted.", });
					}
					return;
				}
				this.State = OperationState.Processing;
			}

			try
			{
				await handler(this).ConfigureAwait(false);
			}
			catch (Exception e)
			{
				this.LogError(e, "Operation execution failed.");
				if (this.Error == null)
				{
					Failed(e is OperationErrorException opEx ? opEx.Error : new OperationError
					{
						Code = "execution_failed",
						Message = e.Message,
						Exception = ExceptionDispatchInfo.Capture(e),
						Details = null, //TODO:
					});
				}
			}
			finally
			{
				this.State = OperationState.Completed;
			}

		}

		/// <inheritdoc />
		bool IOperationContext.TryGetResult(out object? result, [MaybeNullWhen(false)] out Type type)
		{
			if (!this.HasResult || this.State != OperationState.Completed)
			{
				result = null;
				type = null;
				return false;
			}

			result = this.Result;
			type = result?.GetType() ?? typeof(object);
			return true;
		}

		/// <inheritdoc />
		public bool TryGetResult([MaybeNullWhen(false)] out TResult result)
		{
			if (!this.HasResult || this.State != OperationState.Completed)
			{
				result = default;
				return false;
			}

			result = this.Result!;
			return true;
		}

		/// <inheritdoc />
		public OperationResult<TResult> Success(TResult result)
		{
			lock (this)
			{
				//REVIEW: should we allow calling Success() after Failed() has been called ?
				if (this.HasResult) throw new InvalidOperationException(this.Error == null ? ("Cannot call " + nameof(Success) + "() multiple times on the same context") : ("Cannot call " + nameof(Success) + "() on a context that has already been failed"));
				this.HasResult = true;
				this.Result = result;
				this.Error = null;
				this.State = OperationState.Completed;
			}
			return new OperationResult<TResult>(this);
		}

		/// <inheritdoc />
		public OperationResult<TResult> Failed(OperationError error)
		{
			Contract.NotNull(error);
			lock (this)
			{
				//REVIEW: should we allow calling Failed() after Success() has been called ?
				if (this.HasResult) throw new InvalidOperationException(this.Error != null ? ("Cannot call " + nameof(Failed) + "() multiple times on the same context") : ("Cannot call " + nameof(Failed) + "() on a context that has already been completed"));
				this.HasResult = false;
				this.Result = default!;
				this.Error = error;
				this.State = OperationState.Completed;

				var activity = this.Activity;
				if (activity != null)
				{
					activity.SetStatus(ActivityStatusCode.Error, error.Code);
					activity.SetTag("operation.error.code", error.Code);
					var ex = error.Exception?.SourceException;
					if (ex != null) activity.AddException(ex);
				}

			}
			return new OperationFailed(this);
		}

		/// <inheritdoc />
		public void Dispatch(IEvent evt)
		{
			this.Scheduler.Dispatch(this, evt);
		}

		/// <inheritdoc />
		public void Log(LogLevel level, Exception? exception, string message, object?[]? args = null)
		{
			this.Scheduler.Log(this, level, exception, message, args);
		}

		/// <inheritdoc />
		public IDisposable ExecuteStep(string id, string? label = null)
		{
			Contract.NotNull(id);
			//BUGBUG: TODO: !
			return Disposable.Empty();
		}

		/// <inheritdoc />
		public Task<OperationResult<TSubResult>> ExecuteSubOperation<TSubResult>(
			IOperationContext<TSubResult> operation,
			Func<IOperationContext<TSubResult>, Task<OperationResult<TSubResult>>> handler)
		{
			Contract.NotNull(operation);
			Contract.NotNull(handler);

			return this.Scheduler.ExecuteOperation(operation, handler);
		}

		/// <inheritdoc />
		public Activity? Activity { get; private set; }

		internal void SetActivity(Activity? activity)
		{
			this.Activity = activity;
			if (activity?.IsAllDataRequested == true)
			{
				activity.SetTag("operation.id", this.Id);
				activity.SetTag("operation.type", this.Type);
				activity.SetTag("operation.key", this.Key);
				activity.SetTag("operation.parent", this.Parent?.Id);
				//TODO: more?
			}
		}

	}

	/// <summary>Service that monitors the executions of operations in the scope of the process</summary>
	[PublicAPI]
	public interface IOperationOverlord
	{

		/// <summary>Returns the context for the operation with the given unique identifier, if it exists</summary>
		/// <param name="id">Identifier of the operation</param>
		/// <param name="context">Receives the context of the corresponding context, if found.</param>
		/// <returns><c>true</c> if there is an operation with the given id; otherwise, <c>false</c></returns>
		bool TryGetOperationById(string id, [MaybeNullWhen(false)] out IOperationContext context);

		/// <summary>Lists all currently running operations</summary>
		/// <returns></returns>
		IOperationContext[] ListOperations();
		//TODO: add filters, like "string? type" ?
		//REVIEW: should we return a List? ReadOnly? a Set (by id), .... ?

	}

	/// <summary>Service that can schedule and run <see cref="IOperationContext">Operations</see></summary>
	[PublicAPI]
	public interface IOperationScheduler
	{

		/// <summary>Creates a new context for running an operation</summary>
		/// <typeparam name="TResult">Type of result returned by the operation</typeparam>
		/// <param name="type">Operation type (for diagnostic purpose)</param>
		/// <param name="key">If not null, used to distinguish multiple concurrent operations of the type <paramref name="type"/></param>
		/// <param name="parent">If not null, parent operation that started this operation</param>
		/// <param name="ct">Token used to abort the execution of the operation</param>
		/// <returns>Context initialized and ready to run</returns>
		IOperationContext<TResult> Create<TResult>(string type, string? key, IOperationContext? parent = null, CancellationToken ct = default);

		/// <summary>Executes an operation under the control of this scheduler</summary>
		/// <typeparam name="TResult">Type of result returned by the operation</typeparam>
		/// <param name="context">Context of the operation</param>
		/// <param name="handler">Handler that will run the operation</param>
		/// <returns>Result of the operation.</returns>
		/// <remarks>
		/// <para>Any exception thrown by <paramref name="handler"/> will be intercepted and wrapped into a failed <see cref="OperationResult{TResult}"/>.</para>
		/// <para>The end result of the operation can be checked using the <see cref="OperationResult{TResult}.Check"/> method.</para>
		/// </remarks>
		Task<OperationResult<TResult>> ExecuteOperation<TResult>(IOperationContext<TResult> context, Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> handler);

		/// <summary>Logs a message that will be visible to the observers of an operation</summary>
		/// <param name="context">Context of the operation that is producing this log</param>
		/// <param name="level">Log level</param>
		/// <param name="exception">Optional exception that is linked to this log message</param>
		/// <param name="message">Log message</param>
		/// <param name="args">Optional arguments used to format the log message</param>
		void Log(IOperationContext context, LogLevel level, Exception? exception, string message, params object[]? args);

		/// <summary>Dispatches an event linked to the specified <see cref="IOperationContext"/></summary>
		/// <param name="context">Context of the operation that is triggering this event</param>
		/// <param name="evt">Event triggered by this operation</param>
		void Dispatch(IOperationContext context, IEvent evt);

	}

	/// <summary>Service that tracks and runs <see cref="IOperationContext">Operations</see></summary>
	public class OperationScheduler : IOperationScheduler, IOperationOverlord
	{

		private static readonly ActivitySource ActivitySource = new("SnowBank.Threading.Operations");

		private ILogger<OperationScheduler> Logger { get; }

		private IEventBus EventBus { get; }

		private CancellationTokenSource Lifetime { get; }

		//private ConcurrentDictionary<string, IOperationContext> OperationsById { get; } = new ConcurrentDictionary<string, IOperationContext>();

		//private ConcurrentDictionary<string, IOperationContext> OperationsByKey { get; } = new ConcurrentDictionary<string, IOperationContext>();

		public OperationScheduler(IEventBus eventBus, ILogger<OperationScheduler> logger)
		{
			this.EventBus = eventBus;
			this.Logger = logger;
			this.Lifetime = new CancellationTokenSource();
		}

		/// <summary>Generates a new unique Operation identifier</summary>
		public string NewId()
		{
			//TODO: external generator?
			return Uuid128.NewUuid().ToString();
		}

		/// <inheritdoc />
		public bool TryGetOperationById(string id, [MaybeNullWhen(false)] out IOperationContext context)
		{
			//BUGBUG: TODO !
			context = null;
			return false;
		}

		/// <inheritdoc />
		public IOperationContext[] ListOperations()
		{
			//BUGBUG: TODO !
			return [ ];
		}

		/// <inheritdoc />
		public IOperationContext<TResult> Create<TResult>(string type, string? key, IOperationContext? parent = null, CancellationToken ct = default)
		{
			var cts = CancellationTokenSource.CreateLinkedTokenSource(this.Lifetime.Token, ct);
			return new OperationContext<TResult>(this, NewId(), OperationState.Pending, type, key, parent, cts);
		}

		private OperationResult<TResult> HandleCancellation<TResult>(IOperationContext<TResult> context)
		{
			Contract.Debug.Requires(context.Cancellation.IsCancellationRequested);
			return context.Error != null ? new OperationFailed(context) : context.Cancelled();
		}

		/// <inheritdoc />
		public async Task<OperationResult<TResult>> ExecuteOperation<TResult>(IOperationContext<TResult> context, Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> handler)
		{
			Contract.NotNull(context);
			Contract.NotNull(handler);

			using var activity = ActivitySource.StartActivity(context.Type + " execute");

			if (activity != null && context is OperationContext<TResult> ctx)
			{
				ctx.SetActivity(activity);
			}

			if (context.Cancellation.IsCancellationRequested)
			{
				return HandleCancellation(context);
			}

			try
			{
				return await handler(context).ConfigureAwait(false);
			}
			catch (OperationErrorException e)
			{
				return context.Failed(e.Error);
			}
			catch (Exception e)
			{
				return context.Failed(new OperationError
				{
					Code = "internal_error",
					Message = e.Message,
					Exception = ExceptionDispatchInfo.Capture(e),
					Details = null,
				});
			}
		}

		/// <inheritdoc />
		public void Log(IOperationContext context, LogLevel level, Exception? exception, string message, params object?[]? args)
		{
			if (exception == null)
			{
				this.Logger.Log(level, $"{context.Id}: {message}", args ?? [ ]);
			}
			else
			{
				this.Logger.Log(level, exception, $"{context.Id}: {message}", args ?? [ ]);
			}
		}

		/// <inheritdoc />
		public void Dispatch(IOperationContext context, IEvent evt)
		{
			this.EventBus.Dispatch(evt);
		}

	}

	[PublicAPI]
	[AttributeUsage(AttributeTargets.Method)]
	public sealed class OperationActionAttribute : Attribute
	{

		public string? Type { get; }

		public OperationActionAttribute() { }

		public OperationActionAttribute(string type) { this.Type = type; }

	}

	[PublicAPI]
	[AttributeUsage(AttributeTargets.Class)]
	public sealed class OperationInvokerAttribute<TService> : Attribute
	{

		public string Type { get; set; }

		public OperationInvokerAttribute(string type)
		{
			this.Type = type;
		}

	}

	[PublicAPI]
	public interface IOperationInvoker<out TService>
	{
		/// <summary>Returns the <see cref="IOperationScheduler"/> used by this invoker</summary>
		/// <returns></returns>
		IOperationScheduler GetScheduler();

		/// <summary>Returns the instance of the service that the invoker will call</summary>
		TService GetInstance();
	}

	/// <summary>Call-site of an operation that takes one argument</summary>
	[PublicAPI]
	public sealed class OperationCallSite<TResult, T0>
	{
		public IOperationScheduler Scheduler { get; }

		public string Type { get; }

		public Func<IOperationContext<TResult>, T0, Task<OperationResult<TResult>>> Handler { get; }

		public OperationCallSite(IOperationScheduler scheduler, string type, Func<IOperationContext<TResult>, T0, Task<OperationResult<TResult>>> handler)
		{
			this.Scheduler = scheduler;
			this.Type = type;
			this.Handler = handler;
		}

		private Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> MakeCallback(T0 arg0)
			=> (ctx) => this.Handler(ctx, arg0);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(string? key, T0 arg0, CancellationToken ct)
			=> this.Scheduler.Run<TResult>(this.Type, key, MakeCallback(arg0), ct);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(IOperationContext parent, string? key, T0 arg0)
			=> parent.Run<TResult>(this.Type, key, MakeCallback(arg0));

	}

	/// <summary>Call-site of an operation that takes two arguments</summary>
	[PublicAPI]
	public sealed class OperationCallSite<TResult, T0, T1>
	{

		public IOperationScheduler Scheduler { get; }

		public string Type { get; }

		public Func<IOperationContext<TResult>, T0, T1, Task<OperationResult<TResult>>> Handler { get; }

		public OperationCallSite(IOperationScheduler scheduler, string type, Func<IOperationContext<TResult>, T0, T1, Task<OperationResult<TResult>>> handler)
		{
			this.Scheduler = scheduler;
			this.Type = type;
			this.Handler = handler;
		}

		private Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> MakeCallback(T0 arg0, T1 arg1)
			=> (ctx) => this.Handler(ctx, arg0, arg1);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(string? key, T0 arg0, T1 arg1, CancellationToken ct)
			=> this.Scheduler.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1), ct);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(IOperationContext parent, string? key, T0 arg0, T1 arg1)
			=> parent.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1));

	}

	/// <summary>Call-site of an operation that takes three arguments</summary>
	[PublicAPI]
	public sealed class OperationCallSite<TResult, T0, T1, T2>
	{

		public IOperationScheduler Scheduler { get; }

		public string Type { get; }

		public Func<IOperationContext<TResult>, T0, T1, T2, Task<OperationResult<TResult>>> Handler { get; }

		public OperationCallSite(IOperationScheduler scheduler, string type, Func<IOperationContext<TResult>, T0, T1, T2, Task<OperationResult<TResult>>> handler)
		{
			this.Scheduler = scheduler;
			this.Type = type;
			this.Handler = handler;
		}

		private Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> MakeCallback(T0 arg0, T1 arg1, T2 arg2)
			=> (ctx) => this.Handler(ctx, arg0, arg1, arg2);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(string? key, T0 arg0, T1 arg1, T2 arg2, CancellationToken ct)
			=> this.Scheduler.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2), ct);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(IOperationContext parent, string? key, T0 arg0, T1 arg1, T2 arg2)
			=> parent.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2));

	}

	/// <summary>Call-site of an operation that takes four arguments</summary>
	[PublicAPI]
	public sealed class OperationCallSite<TResult, T0, T1, T2, T3>
	{

		public IOperationScheduler Scheduler { get; }

		public string Type { get; }

		public Func<IOperationContext<TResult>, T0, T1, T2, T3, Task<OperationResult<TResult>>> Handler { get; }

		public OperationCallSite(IOperationScheduler scheduler, string type, Func<IOperationContext<TResult>, T0, T1, T2, T3, Task<OperationResult<TResult>>> handler)
		{
			this.Scheduler = scheduler;
			this.Type = type;
			this.Handler = handler;
		}

		private Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> MakeCallback(T0 arg0, T1 arg1, T2 arg2, T3 arg3)
			=> (ctx) => this.Handler(ctx, arg0, arg1, arg2, arg3);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(string? key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, CancellationToken ct)
			=> this.Scheduler.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2, arg3), ct);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(IOperationContext parent, string? key, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
			=> parent.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2, arg3));

	}

	/// <summary>Call-site of an operation that takes five arguments</summary>
	[PublicAPI]
	public sealed class OperationCallSite<TResult, T0, T1, T2, T3, T4>
	{

		public IOperationScheduler Scheduler { get; }

		public string Type { get; }

		public Func<IOperationContext<TResult>, T0, T1, T2, T3, T4, Task<OperationResult<TResult>>> Handler { get; }

		public OperationCallSite(IOperationScheduler scheduler, string type, Func<IOperationContext<TResult>, T0, T1, T2, T3, T4, Task<OperationResult<TResult>>> handler)
		{
			this.Scheduler = scheduler;
			this.Type = type;
			this.Handler = handler;
		}

		private Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> MakeCallback(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
			=> (ctx) => this.Handler(ctx, arg0, arg1, arg2, arg3, arg4);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(string? key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CancellationToken ct)
			=> this.Scheduler.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2, arg3, arg4), ct);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(IOperationContext parent, string? key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
			=> parent.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2, arg3, arg4));

	}

	/// <summary>Call-site of an operation that takes six arguments</summary>
	[PublicAPI]
	public sealed class OperationCallSite<TResult, T0, T1, T2, T3, T4, T5>
	{

		public IOperationScheduler Scheduler { get; }

		public string Type { get; }

		public Func<IOperationContext<TResult>, T0, T1, T2, T3, T4, T5, Task<OperationResult<TResult>>> Handler { get; }

		public OperationCallSite(IOperationScheduler scheduler, string type, Func<IOperationContext<TResult>, T0, T1, T2, T3, T4, T5, Task<OperationResult<TResult>>> handler)
		{
			this.Scheduler = scheduler;
			this.Type = type;
			this.Handler = handler;
		}

		private Func<IOperationContext<TResult>, Task<OperationResult<TResult>>> MakeCallback(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
			=> (ctx) => this.Handler(ctx, arg0, arg1, arg2, arg3, arg4, arg5);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(string? key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, CancellationToken ct)
			=> this.Scheduler.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2, arg3, arg4, arg5), ct);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Task<OperationResult<TResult>> Execute(IOperationContext parent, string? key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
			=> parent.Run<TResult>(this.Type, key, MakeCallback(arg0, arg1, arg2, arg3, arg4, arg5));

	}

	/// <summary>Helper methods for Operation Invokers</summary>
	[PublicAPI]
	public static class OperationInvokerExtensions
	{

		#region <T0>

		public static Task<OperationResult<TResult>> Invoke<TResult, T0>(this OperationCallSite<TResult, T0> operation, T0 arg0, CancellationToken ct)
			=> operation.Execute(null, arg0, ct);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0>(this OperationCallSite<TResult, T0> operation, string key, T0 arg0, CancellationToken ct)
			=> operation.Execute(key, arg0, ct);

		public static Task<OperationResult<TResult>> Invoke<TResult, T0>(this OperationCallSite<TResult, T0> operation, IOperationContext parent, T0 arg0)
			=> operation.Execute(parent, null, arg0);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0>(this OperationCallSite<TResult, T0> operation, string key, IOperationContext parent, T0 arg0)
			=> operation.Execute(parent, key, arg0);

		#endregion

		#region <T0, T1>

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1>(this OperationCallSite<TResult, T0, T1> operation, T0 arg0, T1 arg1, CancellationToken ct)
			=> operation.Execute(null, arg0, arg1, ct);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1>(this OperationCallSite<TResult, T0, T1> operation, string key, T0 arg0, T1 arg1, CancellationToken ct)
			=> operation.Execute(key, arg0, arg1, ct);

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1>(this OperationCallSite<TResult, T0, T1> operation, IOperationContext parent, T0 arg0, T1 arg1)
			=> operation.Execute(parent, null, arg0, arg1);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1>(this OperationCallSite<TResult, T0, T1> operation, string key, IOperationContext parent, T0 arg0, T1 arg1)
			=> operation.Execute(parent, key, arg0, arg1);

		#endregion

		#region <T0, T1, T2>

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1, T2>(this OperationCallSite<TResult, T0, T1, T2> operation, T0 arg0, T1 arg1, T2 arg2, CancellationToken ct)
			=> operation.Execute(null, arg0, arg1, arg2, ct);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1, T2>(this OperationCallSite<TResult, T0, T1, T2> operation, string key, T0 arg0, T1 arg1, T2 arg2, CancellationToken ct)
			=> operation.Execute(key, arg0, arg1, arg2, ct);

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1, T2>(this OperationCallSite<TResult, T0, T1, T2> operation, IOperationContext parent, T0 arg0, T1 arg1, T2 arg2)
			=> operation.Execute(parent, null, arg0, arg1, arg2);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1, T2>(this OperationCallSite<TResult, T0, T1, T2> operation, string key, IOperationContext parent, T0 arg0, T1 arg1, T2 arg2)
			=> operation.Execute(parent, key, arg0, arg1, arg2);

		#endregion

		#region <T0, T1, T2, T3>

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1, T2, T3>(this OperationCallSite<TResult, T0, T1, T2, T3> operation, T0 arg0, T1 arg1, T2 arg2, T3 arg3, CancellationToken ct)
			=> operation.Execute(null, arg0, arg1, arg2, arg3, ct);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1, T2, T3>(this OperationCallSite<TResult, T0, T1, T2, T3> operation, string key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, CancellationToken ct)
			=> operation.Execute(key, arg0, arg1, arg2, arg3, ct);

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1, T2, T3>(this OperationCallSite<TResult, T0, T1, T2, T3> operation, IOperationContext parent, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
			=> operation.Execute(parent, null, arg0, arg1, arg2, arg3);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1, T2, T3>(this OperationCallSite<TResult, T0, T1, T2, T3> operation, string key, IOperationContext parent, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
			=> operation.Execute(parent, key, arg0, arg1, arg2, arg3);

		#endregion

		#region <T0, T1, T2, T3, T4>

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1, T2, T3, T4>(this OperationCallSite<TResult, T0, T1, T2, T3, T4> operation, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CancellationToken ct)
			=> operation.Execute(null, arg0, arg1, arg2, arg3, arg4, ct);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1, T2, T3, T4>(this OperationCallSite<TResult, T0, T1, T2, T3, T4> operation, string key, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CancellationToken ct)
			=> operation.Execute(key, arg0, arg1, arg2, arg3, arg4, ct);

		public static Task<OperationResult<TResult>> Invoke<TResult, T0, T1, T2, T3, T4>(this OperationCallSite<TResult, T0, T1, T2, T3, T4> operation, IOperationContext parent, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
			=> operation.Execute(parent, null, arg0, arg1, arg2, arg3, arg4);

		public static Task<OperationResult<TResult>> InvokeWithKey<TResult, T0, T1, T2, T3, T4>(this OperationCallSite<TResult, T0, T1, T2, T3, T4> operation, string key, IOperationContext parent, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
			=> operation.Execute(parent, key, arg0, arg1, arg2, arg3, arg4);

		#endregion

	}

}
